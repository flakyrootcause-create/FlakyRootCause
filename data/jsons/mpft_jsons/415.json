{
  "id": 415,
  "repo": "services",
  "issue_url": "https://github.com/cowprotocol/services/pull/3597",
  "pr_url": "https://github.com/cowprotocol/services/pull/3597",
  "issue_description": "# Description\r\nFixes 3 flaky tests.\r\n\r\n# Changes\r\n- `local_node_store_filtered_solutions`\r\n    - it failed due to timeouts => increased the http delay buffer to give a bit of wiggle room\r\n    - sometimes an auction ran while only 1 of the 2 solutions was included => configure hardcoded solver solutions after both orders have been included in the auction\r\n- `local_node_partially_fillable_pool`\r\n    - solver got deny listed because it failed to produce a working solution for some reason\r\n        - updated the flags to enable that feature to work like `--flag=true` instead of `--flag` (to enable)\r\n        - disabled the feature on all tests except tests specifically for those features\r\n- `local_node_replace_order`\r\n    - order got settled before it could be replaced\r\n        - ban solver until the original order is no longer inside the auction\r\n        - allow unverified quotes for that test due to the banned solver account\r\n\r\n## How to test\r\nused the flaky test runner\r\n- ran all local node tests for 2h -> ~30 successful executions\r\n- `local_node_replace_order` -> flaky test [job](https://github.com/cowprotocol/services/actions/runs/17316920910/job/49161443945) with 369 successful runs",
  "files_changed": [
    {
      "filename": "crates/autopilot/src/arguments.rs",
      "status": "modified",
      "patch": "@@ -290,7 +290,8 @@ pub struct NonSettlingSolversFinderConfig {\n         id = \"non_settling_solvers_blacklisting_enabled\",\n         long = \"non-settling-solvers-blacklisting-enabled\",\n         env = \"NON_SETTLING_SOLVERS_BLACKLISTING_ENABLED\",\n-        default_value = \"true\"\n+        default_value = \"true\",\n+        action = clap::ArgAction::Set,\n     )]\n     pub enabled: bool,\n \n@@ -311,7 +312,8 @@ pub struct LowSettlingSolversFinderConfig {\n         id = \"low_settling_solvers_blacklisting_enabled\",\n         long = \"low-settling-solvers-blacklisting-enabled\",\n         env = \"LOW_SETTLING_SOLVERS_BLACKLISTING_ENABLED\",\n-        default_value = \"true\"\n+        default_value = \"true\",\n+        action = clap::ArgAction::Set,\n     )]\n     pub enabled: bool,\n "
    },
    {
      "filename": "crates/e2e/src/setup/colocation.rs",
      "status": "modified",
      "patch": "@@ -135,7 +135,7 @@ merge-solutions = {merge_solutions}\n quote-using-limit-orders = {quote_using_limit_orders}\n enable-simulation-bad-token-detection = true\n enable-metrics-bad-token-detection = true\n-http-time-buffer = \"10ms\"\n+http-time-buffer = \"100ms\"\n solving-share-of-deadline = 1.0\n \"#\n                 )"
    },
    {
      "filename": "crates/e2e/src/setup/onchain_components/mod.rs",
      "status": "modified",
      "patch": "@@ -308,6 +308,24 @@ impl OnchainComponents {\n         solvers\n     }\n \n+    pub async fn set_solver_allowed(&self, solver: H160, allowed: bool) {\n+        if allowed {\n+            self.contracts\n+                .gp_authenticator\n+                .add_solver(solver)\n+                .send()\n+                .await\n+                .expect(\"failed to add solver\");\n+        } else {\n+            self.contracts\n+                .gp_authenticator\n+                .remove_solver(solver)\n+                .send()\n+                .await\n+                .expect(\"failed to remove solver\");\n+        }\n+    }\n+\n     /// Generate next `N` accounts with the given initial balance and\n     /// authenticate them as solvers on a forked network.\n     pub async fn make_solvers_forked<const N: usize>("
    },
    {
      "filename": "crates/e2e/src/setup/services.rs",
      "status": "modified",
      "patch": "@@ -173,6 +173,8 @@ impl<'a> Services<'a> {\n \n         let args = [\n             \"autopilot\".to_string(),\n+            \"--non-settling-solvers-blacklisting-enabled=false\".to_string(),\n+            \"--low-settling-solvers-blacklisting-enabled=false\".to_string(),\n             \"--max-run-loop-delay=100ms\".to_string(),\n             \"--run-loop-native-price-timeout=500ms\".to_string(),\n             format!(\"--ethflow-contracts={ethflow_contracts}\"),"
    },
    {
      "filename": "crates/e2e/tests/e2e/quoting.rs",
      "status": "modified",
      "patch": "@@ -320,7 +320,7 @@ async fn quote_timeout(web3: Web3) {\n \n     let assert_within_variance = |start_timestamp: Instant, target| {\n         const VARIANCE: u64 = 100; // small buffer to allow for variance in the test\n-        const HTTP_BUFFER: u64 = 10;\n+        const HTTP_BUFFER: u64 = 100;\n         let min = target - HTTP_BUFFER;\n         let max = min + VARIANCE;\n         let elapsed = start_timestamp.elapsed().as_millis() as u64;"
    },
    {
      "filename": "crates/e2e/tests/e2e/replace_order.rs",
      "status": "modified",
      "patch": "@@ -374,10 +374,25 @@ async fn single_replace_order_test(web3: Web3) {\n         token_a.approve(onchain.contracts().allowance, to_wei(15))\n     );\n \n-    // Place Orders\n+    // disble solver to prevent orders from being settled while we\n+    // want to replace them\n+    onchain.set_solver_allowed(solver.address(), false).await;\n+\n     let services = Services::new(&onchain).await;\n-    services.start_protocol(solver).await;\n+    services\n+        .start_protocol_with_args(\n+            ExtraServiceArgs {\n+                // To avoid race conditions we have to start the protocol\n+                // with the solver being banned. To allow us to still create\n+                // orders we override the quote verification to be disabled.\n+                api: vec![\"--quote-verification=prefer\".into()],\n+                ..Default::default()\n+            },\n+            solver.clone(),\n+        )\n+        .await;\n \n+    let balance_before = token_a.balance_of(trader.address()).call().await.unwrap();\n     let order = OrderCreation {\n         sell_token: token_a.address(),\n         sell_amount: to_wei(10),\n@@ -392,7 +407,6 @@ async fn single_replace_order_test(web3: Web3) {\n         &onchain.contracts().domain_separator,\n         SecretKeyRef::from(&SecretKey::from_slice(trader.private_key()).unwrap()),\n     );\n-    onchain.mint_block().await;\n     let order_id = services.create_order(&order).await.unwrap();\n \n     let app_data = format!(\n@@ -426,32 +440,41 @@ async fn single_replace_order_test(web3: Web3) {\n         &onchain.contracts().domain_separator,\n         SecretKeyRef::from(&SecretKey::from_slice(trader.private_key()).unwrap()),\n     );\n-    let balance_before = token_a.balance_of(trader.address()).call().await.unwrap();\n     let new_order_uid = services.create_order(&new_order).await.unwrap();\n \n+    {\n+        // assert that the new order has the expected appdata\n+        let new_order = services.get_order(&new_order_uid).await.unwrap();\n+        let new_order_appdata = new_order\n+            .metadata\n+            .full_app_data\n+            .expect(\"valid full appData\");\n+        assert_eq!(new_order_appdata, app_data);\n+    }\n+\n     // Check the previous order is cancelled\n     let old_order = services.get_order(&order_id).await.unwrap();\n     assert_eq!(old_order.metadata.status, OrderStatus::Cancelled);\n \n-    // Drive solution\n-    tracing::info!(\"Waiting for trade.\");\n+    tracing::info!(\"wait for old order to be removed\");\n     wait_for_condition(TIMEOUT, || async {\n-        let balance_after = token_a.balance_of(trader.address()).call().await.unwrap();\n         onchain.mint_block().await;\n-        balance_before.saturating_sub(balance_after) == to_wei(3)\n+        let auction = services.get_auction().await.auction;\n+        auction.orders.len() == 1 && auction.orders[0].uid == new_order_uid\n     })\n     .await\n     .unwrap();\n+    // now that the order has been cancelled and the original order\n+    // is no longer part of the auction we can reenable the solver\n+    onchain.set_solver_allowed(solver.address(), true).await;\n \n-    // Check the previous order is cancelled\n+    // Drive solution to verify that new order can be settled\n+    tracing::info!(\"Waiting for trade.\");\n     wait_for_condition(TIMEOUT, || async {\n-        let new_order = services.get_order(&new_order_uid).await.unwrap();\n-        let new_order_appdata = new_order\n-            .metadata\n-            .full_app_data\n-            .expect(\"valid full appData\");\n-        new_order_appdata == app_data\n+        let balance_after = token_a.balance_of(trader.address()).call().await.unwrap();\n+        onchain.mint_block().await;\n+        balance_before.saturating_sub(balance_after) == to_wei(3)\n     })\n     .await\n-    .unwrap()\n+    .unwrap();\n }"
    },
    {
      "filename": "crates/e2e/tests/e2e/solver_competition.rs",
      "status": "modified",
      "patch": "@@ -557,7 +557,15 @@ async fn store_filtered_solutions(web3: Web3) {\n \n     let order_ab_id = services.create_order(&order_ab).await.unwrap();\n     let order_ac_id = services.create_order(&order_ac).await.unwrap();\n-    onchain.mint_block().await;\n+\n+    tracing::info!(\"Waiting for both orders to be in the auction\");\n+    wait_for_condition(TIMEOUT, || async {\n+        onchain.mint_block().await;\n+        let auction = services.get_auction().await.auction;\n+        auction.orders.len() == 2\n+    })\n+    .await\n+    .unwrap();\n \n     // good solver settles order_ab at a price 3:1\n     good_solver.configure_solution(Some(Solution {"
    },
    {
      "filename": "crates/e2e/tests/e2e/solver_participation_guard.rs",
      "status": "modified",
      "patch": "@@ -54,8 +54,12 @@ async fn non_settling_solver(web3: Web3) {\n \n     let services = Services::new(&onchain).await;\n     let args = ExtraServiceArgs {\n-        // The solver gets banned for 40s.\n-        autopilot: vec![\"--solver-blacklist-cache-ttl=40s\".to_string()],\n+        autopilot: vec![\n+            \"--non-settling-solvers-blacklisting-enabled=true\".to_string(),\n+            \"--low-settling-solvers-blacklisting-enabled=true\".to_string(),\n+            // The solver gets banned for 40s.\n+            \"--solver-blacklist-cache-ttl=40s\".to_string(),\n+        ],\n         ..Default::default()\n     };\n     services.start_protocol_with_args(args, solver).await;\n@@ -122,6 +126,8 @@ async fn low_settling_solver(web3: Web3) {\n     let services = Services::new(&onchain).await;\n     let args = ExtraServiceArgs {\n         autopilot: vec![\n+            \"--non-settling-solvers-blacklisting-enabled=true\".to_string(),\n+            \"--low-settling-solvers-blacklisting-enabled=true\".to_string(),\n             // The solver gets banned for 40s.\n             \"--solver-blacklist-cache-ttl=40s\".to_string(),\n             // The solver is banned if the failure settlement rate is above 55%."
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}