{
  "id": 371,
  "repo": "kubernetes",
  "issue_url": "https://github.com/kubernetes/kubernetes/pull/126580",
  "pr_url": "https://github.com/kubernetes/kubernetes/pull/126580",
  "issue_description": "[PR Linked Issue]\n# Enhancement Description\r\n* One-line enhancement description (can be used as a release note):\r\n  Auto remove PVCs created by StatefulSet\r\n\r\n* Kubernetes Enhancement Proposal: [KEP-1847: Auto remove PVCs created by StatefulSet](https://github.com/kubernetes/enhancements/tree/master/keps/sig-apps/1847-autoremove-statefulset-pvcs).\r\n* Primary contact (assignee): @mattcary\r\n* Responsible SIGs: @sig-apps (with collaboration by @sig-storage)\r\n* Enhancement target (which target equals to which milestone):\r\n  * Alpha release target 1.23\r\n  * Beta release target 1.27\r\n  * Stable release target 1.32\r\n\r\n\r\n- [x] Beta\r\n  - [x] KEP (`k/enhancements`) update PR(s): https://github.com/kubernetes/enhancements/pull/3800\r\n  - [x] Code (`k/k`) update PR(s):\r\n    - https://github.com/kubernetes/kubernetes/pull/116501\r\n  - [x] Docs (`k/website`) update(s):\r\n    - https://github.com/kubernetes/website/pull/39926\r\n    - https://github.com/kubernetes/website/pull/39819\r\n- [x] Stable\r\n  - [x] KEP (`k/enhancements`) update PR(s): https://github.com/kubernetes/enhancements/pull/4901\r\n  - [x] Code (`k/k`) update PR(s): https://github.com/kubernetes/kubernetes/pull/128247\r\n  - [x] Docs (`k/website`) update(s): https://github.com/kubernetes/website/pull/48484\r\n\r\n\r\n_Please to keep this description up to date. This will help the Enhancement Team track efficiently the evolution of the enhancement_\r\n\r\nResolves [kubernetes/kubernetes#55045](https://github.com/kubernetes/kubernetes/issues/55045)\r\n",
  "files_changed": [
    {
      "filename": "pkg/controller/statefulset/stateful_pod_control.go",
      "status": "modified",
      "patch": "@@ -220,7 +220,7 @@ func (spc *StatefulPodControl) ClaimsMatchRetentionPolicy(ctx context.Context, s\n \t\tcase err != nil:\n \t\t\treturn false, fmt.Errorf(\"Could not retrieve claim %s for %s when checking PVC deletion policy\", claimName, pod.Name)\n \t\tdefault:\n-\t\t\tif !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {\n+\t\t\tif !isClaimOwnerUpToDate(logger, claim, set, pod) {\n \t\t\t\treturn false, nil\n \t\t\t}\n \t\t}\n@@ -242,14 +242,16 @@ func (spc *StatefulPodControl) UpdatePodClaimForRetentionPolicy(ctx context.Cont\n \t\tcase err != nil:\n \t\t\treturn fmt.Errorf(\"Could not retrieve claim %s not found for %s when checking PVC deletion policy: %w\", claimName, pod.Name, err)\n \t\tdefault:\n-\t\t\tif !claimOwnerMatchesSetAndPod(logger, claim, set, pod) {\n+\t\t\tif hasUnexpectedController(claim, set, pod) {\n+\t\t\t\t// Add an event so the user knows they're in a strange configuration. The claim will be cleaned up below.\n+\t\t\t\tmsg := fmt.Sprintf(\"PersistentVolumeClaim %s has a conflicting OwnerReference that acts as a manging controller, the retention policy is ignored for this claim\", claimName)\n+\t\t\t\tspc.recorder.Event(set, v1.EventTypeWarning, \"ConflictingController\", msg)\n+\t\t\t}\n+\t\t\tif !isClaimOwnerUpToDate(logger, claim, set, pod) {\n \t\t\t\tclaim = claim.DeepCopy() // Make a copy so we don't mutate the shared cache.\n-\t\t\t\tneedsUpdate := updateClaimOwnerRefForSetAndPod(logger, claim, set, pod)\n-\t\t\t\tif needsUpdate {\n-\t\t\t\t\terr := spc.objectMgr.UpdateClaim(claim)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn fmt.Errorf(\"Could not update claim %s for delete policy ownerRefs: %w\", claimName, err)\n-\t\t\t\t\t}\n+\t\t\t\tupdateClaimOwnerRefForSetAndPod(logger, claim, set, pod)\n+\t\t\t\tif err := spc.objectMgr.UpdateClaim(claim); err != nil {\n+\t\t\t\t\treturn fmt.Errorf(\"could not update claim %s for delete policy ownerRefs: %w\", claimName, err)\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -275,8 +277,7 @@ func (spc *StatefulPodControl) PodClaimIsStale(set *apps.StatefulSet, pod *v1.Po\n \t\tcase err != nil:\n \t\t\treturn false, err\n \t\tcase err == nil:\n-\t\t\t// A claim is stale if it doesn't match the pod's UID, including if the pod has no UID.\n-\t\t\tif hasStaleOwnerRef(pvc, pod) {\n+\t\t\tif hasStaleOwnerRef(pvc, pod, podKind) {\n \t\t\t\treturn true, nil\n \t\t\t}\n \t\t}"
    },
    {
      "filename": "pkg/controller/statefulset/stateful_pod_control_test.go",
      "status": "modified",
      "patch": "@@ -41,6 +41,7 @@ import (\n \t_ \"k8s.io/kubernetes/pkg/apis/apps/install\"\n \t_ \"k8s.io/kubernetes/pkg/apis/core/install\"\n \t\"k8s.io/kubernetes/pkg/features\"\n+\t\"k8s.io/utils/ptr\"\n )\n \n func TestStatefulPodControlCreatesPods(t *testing.T) {\n@@ -502,7 +503,7 @@ func TestStatefulPodControlDeleteFailure(t *testing.T) {\n }\n \n func TestStatefulPodControlClaimsMatchDeletionPolcy(t *testing.T) {\n-\t// The claimOwnerMatchesSetAndPod is tested exhaustively in stateful_set_utils_test; this\n+\t// The isClaimOwnerUpToDate is tested exhaustively in stateful_set_utils_test; this\n \t// test is for the wiring to the method tested there.\n \t_, ctx := ktesting.NewTestContext(t)\n \tfakeClient := &fake.Clientset{}\n@@ -542,38 +543,64 @@ func TestStatefulPodControlUpdatePodClaimForRetentionPolicy(t *testing.T) {\n \ttestFn := func(t *testing.T) {\n \t\t_, ctx := ktesting.NewTestContext(t)\n \t\tdefer featuregatetesting.SetFeatureGateDuringTest(t, utilfeature.DefaultFeatureGate, features.StatefulSetAutoDeletePVC, true)()\n-\t\tfakeClient := &fake.Clientset{}\n-\t\tindexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})\n-\t\tclaimLister := corelisters.NewPersistentVolumeClaimLister(indexer)\n-\t\tfakeClient.AddReactor(\"update\", \"persistentvolumeclaims\", func(action core.Action) (bool, runtime.Object, error) {\n-\t\t\tupdate := action.(core.UpdateAction)\n-\t\t\tindexer.Update(update.GetObject())\n-\t\t\treturn true, update.GetObject(), nil\n-\t\t})\n-\t\tset := newStatefulSet(3)\n-\t\tset.GetObjectMeta().SetUID(\"set-123\")\n-\t\tpod := newStatefulSetPod(set, 0)\n-\t\tclaims := getPersistentVolumeClaims(set, pod)\n-\t\tfor k := range claims {\n-\t\t\tclaim := claims[k]\n-\t\t\tindexer.Add(&claim)\n-\t\t}\n-\t\tcontrol := NewStatefulPodControl(fakeClient, nil, claimLister, &noopRecorder{})\n-\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n-\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n-\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n-\t\t}\n-\t\tif err := control.UpdatePodClaimForRetentionPolicy(ctx, set, pod); err != nil {\n-\t\t\tt.Errorf(\"Unexpected error for UpdatePodClaimForRetentionPolicy (retain): %v\", err)\n+\n+\t\ttestCases := []struct {\n+\t\t\tname      string\n+\t\t\townerRef  []metav1.OwnerReference\n+\t\t\texpectRef bool\n+\t\t}{\n+\t\t\t{\n+\t\t\t\tname:      \"bare PVC\",\n+\t\t\t\texpectRef: true,\n+\t\t\t},\n+\t\t\t{\n+\t\t\t\tname:      \"PVC already controller\",\n+\t\t\t\townerRef:  []metav1.OwnerReference{{Controller: ptr.To(true), Name: \"foobar\"}},\n+\t\t\t\texpectRef: false,\n+\t\t\t},\n \t\t}\n-\t\texpectRef := utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC)\n-\t\tfor k := range claims {\n-\t\t\tclaim, err := claimLister.PersistentVolumeClaims(claims[k].Namespace).Get(claims[k].Name)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"Unexpected error getting Claim %s/%s: %v\", claim.Namespace, claim.Name, err)\n+\n+\t\tfor _, tc := range testCases {\n+\t\t\tfakeClient := &fake.Clientset{}\n+\t\t\tindexer := cache.NewIndexer(cache.MetaNamespaceKeyFunc, cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc})\n+\t\t\tclaimLister := corelisters.NewPersistentVolumeClaimLister(indexer)\n+\t\t\tfakeClient.AddReactor(\"update\", \"persistentvolumeclaims\", func(action core.Action) (bool, runtime.Object, error) {\n+\t\t\t\tupdate := action.(core.UpdateAction)\n+\t\t\t\tif err := indexer.Update(update.GetObject()); err != nil {\n+\t\t\t\t\tt.Fatalf(\"could not update index: %v\", err)\n+\t\t\t\t}\n+\t\t\t\treturn true, update.GetObject(), nil\n+\t\t\t})\n+\t\t\tset := newStatefulSet(3)\n+\t\t\tset.GetObjectMeta().SetUID(\"set-123\")\n+\t\t\tpod0 := newStatefulSetPod(set, 0)\n+\t\t\tclaims0 := getPersistentVolumeClaims(set, pod0)\n+\t\t\tfor k := range claims0 {\n+\t\t\t\tclaim := claims0[k]\n+\t\t\t\tif tc.ownerRef != nil {\n+\t\t\t\t\tclaim.SetOwnerReferences(tc.ownerRef)\n+\t\t\t\t}\n+\t\t\t\tif err := indexer.Add(&claim); err != nil {\n+\t\t\t\t\tt.Errorf(\"Could not add claim %s: %v\", k, err)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontrol := NewStatefulPodControl(fakeClient, nil, claimLister, &noopRecorder{})\n+\t\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n+\t\t\t}\n+\t\t\tif err := control.UpdatePodClaimForRetentionPolicy(ctx, set, pod0); err != nil {\n+\t\t\t\tt.Errorf(\"Unexpected error for UpdatePodClaimForRetentionPolicy (retain), pod0: %v\", err)\n \t\t\t}\n-\t\t\tif hasOwnerRef(claim, set) != expectRef {\n-\t\t\t\tt.Errorf(\"Claim %s/%s bad set owner ref\", claim.Namespace, claim.Name)\n+\t\t\texpectRef := tc.expectRef && utilfeature.DefaultFeatureGate.Enabled(features.StatefulSetAutoDeletePVC)\n+\t\t\tfor k := range claims0 {\n+\t\t\t\tclaim, err := claimLister.PersistentVolumeClaims(claims0[k].Namespace).Get(claims0[k].Name)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tt.Errorf(\"Unexpected error getting Claim %s/%s: %v\", claim.Namespace, claim.Name, err)\n+\t\t\t\t}\n+\t\t\t\tif hasOwnerRef(claim, set) != expectRef {\n+\t\t\t\t\tt.Errorf(\"%s: Claim %s/%s bad set owner ref\", tc.name, claim.Namespace, claim.Name)\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -663,12 +690,22 @@ func TestPodClaimIsStale(t *testing.T) {\n \t\t\t\tclaimIndexer.Add(&claim)\n \t\t\tcase stale:\n \t\t\t\tclaim.SetOwnerReferences([]metav1.OwnerReference{\n-\t\t\t\t\t{Name: \"set-3\", UID: types.UID(\"stale\")},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:       \"set-3\",\n+\t\t\t\t\t\tUID:        types.UID(\"stale\"),\n+\t\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\t},\n \t\t\t\t})\n \t\t\t\tclaimIndexer.Add(&claim)\n \t\t\tcase withRef:\n \t\t\t\tclaim.SetOwnerReferences([]metav1.OwnerReference{\n-\t\t\t\t\t{Name: \"set-3\", UID: types.UID(\"123\")},\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:       \"set-3\",\n+\t\t\t\t\t\tUID:        types.UID(\"123\"),\n+\t\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\t},\n \t\t\t\t})\n \t\t\t\tclaimIndexer.Add(&claim)\n \t\t\t}\n@@ -710,7 +747,8 @@ func TestStatefulPodControlRetainDeletionPolicyUpdate(t *testing.T) {\n \t\t}\n \t\tfor k := range claims {\n \t\t\tclaim := claims[k]\n-\t\t\tsetOwnerRef(&claim, set, &set.TypeMeta) // This ownerRef should be removed in the update.\n+\t\t\t// This ownerRef should be removed in the update.\n+\t\t\tclaim.SetOwnerReferences(addControllerRef(claim.GetOwnerReferences(), set, controllerKind))\n \t\t\tclaimIndexer.Add(&claim)\n \t\t}\n \t\tcontrol := NewStatefulPodControl(fakeClient, podLister, claimLister, recorder)"
    },
    {
      "filename": "pkg/controller/statefulset/stateful_set.go",
      "status": "modified",
      "patch": "@@ -49,6 +49,9 @@ import (\n // controllerKind contains the schema.GroupVersionKind for this controller type.\n var controllerKind = apps.SchemeGroupVersion.WithKind(\"StatefulSet\")\n \n+// podKind contains the schema.GroupVersionKind for pods.\n+var podKind = v1.SchemeGroupVersion.WithKind(\"Pod\")\n+\n // StatefulSetController controls statefulsets.\n type StatefulSetController struct {\n \t// client interface"
    },
    {
      "filename": "pkg/controller/statefulset/stateful_set_utils.go",
      "status": "modified",
      "patch": "@@ -26,6 +26,7 @@ import (\n \tv1 \"k8s.io/api/core/v1\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/runtime\"\n+\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n \t\"k8s.io/apimachinery/pkg/util/intstr\"\n \t\"k8s.io/apimachinery/pkg/util/strategicpatch\"\n \tutilfeature \"k8s.io/apiserver/pkg/util/feature\"\n@@ -170,9 +171,100 @@ func getPersistentVolumeClaimRetentionPolicy(set *apps.StatefulSet) apps.Statefu\n \treturn policy\n }\n \n-// claimOwnerMatchesSetAndPod returns false if the ownerRefs of the claim are not set consistently with the\n+// matchesRef returns true when the object matches the owner reference, that is the name and GVK are the same.\n+func matchesRef(ref *metav1.OwnerReference, obj metav1.Object, gvk schema.GroupVersionKind) bool {\n+\treturn gvk.GroupVersion().String() == ref.APIVersion && gvk.Kind == ref.Kind && ref.Name == obj.GetName()\n+}\n+\n+// hasUnexpectedController returns true if the set has a retention policy and there is a controller\n+// for the claim that's not the set or pod. Since the retention policy may have been changed, it is\n+// always valid for the set or pod to be a controller.\n+func hasUnexpectedController(claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) bool {\n+\tpolicy := getPersistentVolumeClaimRetentionPolicy(set)\n+\tconst retain = apps.RetainPersistentVolumeClaimRetentionPolicyType\n+\tif policy.WhenScaled == retain && policy.WhenDeleted == retain {\n+\t\t// On a retain policy, it's not a problem for different controller to be managing the claims.\n+\t\treturn false\n+\t}\n+\tfor _, ownerRef := range claim.GetOwnerReferences() {\n+\t\tif matchesRef(&ownerRef, set, controllerKind) {\n+\t\t\tif ownerRef.UID != set.GetUID() {\n+\t\t\t\t// A UID mismatch means that pods were incorrectly orphaned. Treating this as an unexpected\n+\t\t\t\t// controller means we won't touch the PVCs (eg, leave it to the garbage collector to clean\n+\t\t\t\t// up if appropriate).\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tcontinue // This is us.\n+\t\t}\n+\n+\t\tif matchesRef(&ownerRef, pod, podKind) {\n+\t\t\tif ownerRef.UID != pod.GetUID() {\n+\t\t\t\t// This is the same situation as the set UID mismatch, above.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tcontinue // This is us.\n+\t\t}\n+\t\tif ownerRef.Controller != nil && *ownerRef.Controller {\n+\t\t\treturn true // This is another controller.\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// hasNonControllerOwner returns true if the pod or set is an owner but not controller of the claim.\n+func hasNonControllerOwner(claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) bool {\n+\tfor _, ownerRef := range claim.GetOwnerReferences() {\n+\t\tif ownerRef.UID == set.GetUID() || ownerRef.UID == pod.GetUID() {\n+\t\t\tif ownerRef.Controller == nil || !*ownerRef.Controller {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// removeRefs removes any owner refs from the list matching predicate. Returns true if the list was changed and\n+// the new (or unchanged list).\n+func removeRefs(refs []metav1.OwnerReference, predicate func(ref *metav1.OwnerReference) bool) []metav1.OwnerReference {\n+\tnewRefs := []metav1.OwnerReference{}\n+\tfor _, ownerRef := range refs {\n+\t\tif !predicate(&ownerRef) {\n+\t\t\tnewRefs = append(newRefs, ownerRef)\n+\t\t}\n+\t}\n+\treturn newRefs\n+}\n+\n+// isClaimOwnerUpToDate returns false if the ownerRefs of the claim are not set consistently with the\n // PVC deletion policy for the StatefulSet.\n-func claimOwnerMatchesSetAndPod(logger klog.Logger, claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) bool {\n+//\n+// If there are stale references or unexpected controllers, this returns true in order to not touch\n+// PVCs that have gotten into this unknown state. Otherwise the ownerships are checked to match the\n+// PVC retention policy:\n+//\n+//\tRetain on scaling and set deletion: no owner ref\n+//\tRetain on scaling and delete on set deletion: owner ref on the set only\n+//\tDelete on scaling and retain on set deletion: owner ref on the pod only\n+//\tDelete on scaling and set deletion: owner refs on both set and pod.\n+func isClaimOwnerUpToDate(logger klog.Logger, claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) bool {\n+\tif hasStaleOwnerRef(claim, set, controllerKind) || hasStaleOwnerRef(claim, pod, podKind) {\n+\t\t// The claim is being managed by previous, presumably deleted, version of the controller. It should not be touched.\n+\t\treturn true\n+\t}\n+\n+\tif hasUnexpectedController(claim, set, pod) {\n+\t\tif hasOwnerRef(claim, set) || hasOwnerRef(claim, pod) {\n+\t\t\treturn false // Need to clean up the conflicting controllers\n+\t\t}\n+\t\t// The claim refs are good, we don't want to add any controllers on top of the unexpected one.\n+\t\treturn true\n+\t}\n+\n+\tif hasNonControllerOwner(claim, set, pod) {\n+\t\t// Some resource has an owner ref, but there is no controller. This needs to be updated.\n+\t\treturn false\n+\t}\n+\n \tpolicy := getPersistentVolumeClaimRetentionPolicy(set)\n \tconst retain = apps.RetainPersistentVolumeClaimRetentionPolicyType\n \tconst delete = apps.DeletePersistentVolumeClaimRetentionPolicyType\n@@ -214,64 +306,53 @@ func claimOwnerMatchesSetAndPod(logger klog.Logger, claim *v1.PersistentVolumeCl\n \n // updateClaimOwnerRefForSetAndPod updates the ownerRefs for the claim according to the deletion policy of\n // the StatefulSet. Returns true if the claim was changed and should be updated and false otherwise.\n-func updateClaimOwnerRefForSetAndPod(logger klog.Logger, claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) bool {\n-\tneedsUpdate := false\n-\t// Sometimes the version and kind are not set {pod,set}.TypeMeta. These are necessary for the ownerRef.\n-\t// This is the case both in real clusters and the unittests.\n-\t// TODO: there must be a better way to do this other than hardcoding the pod version?\n-\tupdateMeta := func(tm *metav1.TypeMeta, kind string) {\n-\t\tif tm.APIVersion == \"\" {\n-\t\t\tif kind == \"StatefulSet\" {\n-\t\t\t\ttm.APIVersion = \"apps/v1\"\n-\t\t\t} else {\n-\t\t\t\ttm.APIVersion = \"v1\"\n-\t\t\t}\n-\t\t}\n-\t\tif tm.Kind == \"\" {\n-\t\t\ttm.Kind = kind\n-\t\t}\n+// isClaimOwnerUpToDate should be called before this to avoid an expensive update operation.\n+func updateClaimOwnerRefForSetAndPod(logger klog.Logger, claim *v1.PersistentVolumeClaim, set *apps.StatefulSet, pod *v1.Pod) {\n+\trefs := claim.GetOwnerReferences()\n+\n+\tunexpectedController := hasUnexpectedController(claim, set, pod)\n+\n+\t// Scrub any ownerRefs to our set & pod.\n+\trefs = removeRefs(refs, func(ref *metav1.OwnerReference) bool {\n+\t\treturn matchesRef(ref, set, controllerKind) || matchesRef(ref, pod, podKind)\n+\t})\n+\n+\tif unexpectedController {\n+\t\t// Leave ownerRefs to our set & pod scrubed and return without creating new ones.\n+\t\tclaim.SetOwnerReferences(refs)\n+\t\treturn\n \t}\n-\tpodMeta := pod.TypeMeta\n-\tupdateMeta(&podMeta, \"Pod\")\n-\tsetMeta := set.TypeMeta\n-\tupdateMeta(&setMeta, \"StatefulSet\")\n+\n \tpolicy := getPersistentVolumeClaimRetentionPolicy(set)\n \tconst retain = apps.RetainPersistentVolumeClaimRetentionPolicyType\n \tconst delete = apps.DeletePersistentVolumeClaimRetentionPolicyType\n \tswitch {\n \tdefault:\n \t\tlogger.Error(nil, \"Unknown policy, treating as Retain\", \"policy\", set.Spec.PersistentVolumeClaimRetentionPolicy)\n-\t\tfallthrough\n+\t\t// Nothing to do\n \tcase policy.WhenScaled == retain && policy.WhenDeleted == retain:\n-\t\tneedsUpdate = removeOwnerRef(claim, set) || needsUpdate\n-\t\tneedsUpdate = removeOwnerRef(claim, pod) || needsUpdate\n+\t\t// Nothing to do\n \tcase policy.WhenScaled == retain && policy.WhenDeleted == delete:\n-\t\tneedsUpdate = setOwnerRef(claim, set, &setMeta) || needsUpdate\n-\t\tneedsUpdate = removeOwnerRef(claim, pod) || needsUpdate\n+\t\trefs = addControllerRef(refs, set, controllerKind)\n \tcase policy.WhenScaled == delete && policy.WhenDeleted == retain:\n-\t\tneedsUpdate = removeOwnerRef(claim, set) || needsUpdate\n \t\tpodScaledDown := !podInOrdinalRange(pod, set)\n \t\tif podScaledDown {\n-\t\t\tneedsUpdate = setOwnerRef(claim, pod, &podMeta) || needsUpdate\n-\t\t}\n-\t\tif !podScaledDown {\n-\t\t\tneedsUpdate = removeOwnerRef(claim, pod) || needsUpdate\n+\t\t\trefs = addControllerRef(refs, pod, podKind)\n \t\t}\n \tcase policy.WhenScaled == delete && policy.WhenDeleted == delete:\n \t\tpodScaledDown := !podInOrdinalRange(pod, set)\n \t\tif podScaledDown {\n-\t\t\tneedsUpdate = removeOwnerRef(claim, set) || needsUpdate\n-\t\t\tneedsUpdate = setOwnerRef(claim, pod, &podMeta) || needsUpdate\n+\t\t\trefs = addControllerRef(refs, pod, podKind)\n \t\t}\n \t\tif !podScaledDown {\n-\t\t\tneedsUpdate = setOwnerRef(claim, set, &setMeta) || needsUpdate\n-\t\t\tneedsUpdate = removeOwnerRef(claim, pod) || needsUpdate\n+\t\t\trefs = addControllerRef(refs, set, controllerKind)\n \t\t}\n \t}\n-\treturn needsUpdate\n+\tclaim.SetOwnerReferences(refs)\n }\n \n-// hasOwnerRef returns true if target has an ownerRef to owner.\n+// hasOwnerRef returns true if target has an ownerRef to owner (as its UID).\n+// This does not check if the owner is a controller.\n func hasOwnerRef(target, owner metav1.Object) bool {\n \townerUID := owner.GetUID()\n \tfor _, ownerRef := range target.GetOwnerReferences() {\n@@ -282,53 +363,28 @@ func hasOwnerRef(target, owner metav1.Object) bool {\n \treturn false\n }\n \n-// hasStaleOwnerRef returns true if target has a ref to owner that appears to be stale.\n-func hasStaleOwnerRef(target, owner metav1.Object) bool {\n+// hasStaleOwnerRef returns true if target has a ref to owner that appears to be stale, that is,\n+// the ref matches the object but not the UID.\n+func hasStaleOwnerRef(target *v1.PersistentVolumeClaim, obj metav1.Object, gvk schema.GroupVersionKind) bool {\n \tfor _, ownerRef := range target.GetOwnerReferences() {\n-\t\tif ownerRef.Name == owner.GetName() && ownerRef.UID != owner.GetUID() {\n-\t\t\treturn true\n+\t\tif matchesRef(&ownerRef, obj, gvk) {\n+\t\t\treturn ownerRef.UID != obj.GetUID()\n \t\t}\n \t}\n \treturn false\n }\n \n-// setOwnerRef adds owner to the ownerRefs of target, if necessary. Returns true if target needs to be\n-// updated and false otherwise.\n-func setOwnerRef(target, owner metav1.Object, ownerType *metav1.TypeMeta) bool {\n-\tif hasOwnerRef(target, owner) {\n-\t\treturn false\n-\t}\n-\townerRefs := append(\n-\t\ttarget.GetOwnerReferences(),\n-\t\tmetav1.OwnerReference{\n-\t\t\tAPIVersion: ownerType.APIVersion,\n-\t\t\tKind:       ownerType.Kind,\n-\t\t\tName:       owner.GetName(),\n-\t\t\tUID:        owner.GetUID(),\n-\t\t})\n-\ttarget.SetOwnerReferences(ownerRefs)\n-\treturn true\n-}\n-\n-// removeOwnerRef removes owner from the ownerRefs of target, if necessary. Returns true if target needs\n-// to be updated and false otherwise.\n-func removeOwnerRef(target, owner metav1.Object) bool {\n-\tif !hasOwnerRef(target, owner) {\n-\t\treturn false\n-\t}\n-\townerUID := owner.GetUID()\n-\toldRefs := target.GetOwnerReferences()\n-\tnewRefs := make([]metav1.OwnerReference, len(oldRefs)-1)\n-\tskip := 0\n-\tfor i := range oldRefs {\n-\t\tif oldRefs[i].UID == ownerUID {\n-\t\t\tskip = -1\n-\t\t} else {\n-\t\t\tnewRefs[i+skip] = oldRefs[i]\n+// addControllerRef returns refs with owner added as a controller, if necessary.\n+func addControllerRef(refs []metav1.OwnerReference, owner metav1.Object, gvk schema.GroupVersionKind) []metav1.OwnerReference {\n+\tfor _, ref := range refs {\n+\t\tif ref.UID == owner.GetUID() {\n+\t\t\t// Already added. Since we scrub our refs before making any changes, we know it's already\n+\t\t\t// a controller if appropriate.\n+\t\t\treturn refs\n \t\t}\n \t}\n-\ttarget.SetOwnerReferences(newRefs)\n-\treturn true\n+\n+\treturn append(refs, *metav1.NewControllerRef(owner, gvk))\n }\n \n // getPersistentVolumeClaims gets a map of PersistentVolumeClaims to their template names, as defined in set. The"
    },
    {
      "filename": "pkg/controller/statefulset/stateful_set_utils_test.go",
      "status": "modified",
      "patch": "@@ -23,19 +23,20 @@ import (\n \t\"regexp\"\n \t\"sort\"\n \t\"strconv\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n+\tapps \"k8s.io/api/apps/v1\"\n+\tv1 \"k8s.io/api/core/v1\"\n \t\"k8s.io/apimachinery/pkg/api/resource\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/runtime\"\n+\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n \t\"k8s.io/apimachinery/pkg/types\"\n \t\"k8s.io/apimachinery/pkg/util/intstr\"\n \t\"k8s.io/klog/v2\"\n \t\"k8s.io/klog/v2/ktesting\"\n-\n-\tapps \"k8s.io/api/apps/v1\"\n-\tv1 \"k8s.io/api/core/v1\"\n \tpodutil \"k8s.io/kubernetes/pkg/api/v1/pod\"\n \t\"k8s.io/kubernetes/pkg/controller/history\"\n \t\"k8s.io/utils/ptr\"\n@@ -63,6 +64,88 @@ func getClaimPodName(set *apps.StatefulSet, claim *v1.PersistentVolumeClaim) str\n \treturn matches[1]\n }\n \n+// ownerRefsChanged returns true if newRefs does not match originalRefs.\n+func ownerRefsChanged(originalRefs, newRefs []metav1.OwnerReference) bool {\n+\tif len(originalRefs) != len(newRefs) {\n+\t\treturn true\n+\t}\n+\tkey := func(ref *metav1.OwnerReference) string {\n+\t\treturn fmt.Sprintf(\"%s-%s-%s\", ref.APIVersion, ref.Kind, ref.Name)\n+\t}\n+\trefs := map[string]bool{}\n+\tfor i := range originalRefs {\n+\t\trefs[key(&originalRefs[i])] = true\n+\t}\n+\tfor i := range newRefs {\n+\t\tk := key(&newRefs[i])\n+\t\tif val, found := refs[k]; !found || !val {\n+\t\t\treturn true\n+\t\t}\n+\t\trefs[k] = false\n+\t}\n+\treturn false\n+}\n+\n+func TestOwnerRefsChanged(t *testing.T) {\n+\ttoRefs := func(strs []string) []metav1.OwnerReference {\n+\t\trefs := []metav1.OwnerReference{}\n+\t\tfor _, s := range strs {\n+\t\t\tpieces := strings.Split(s, \"/\")\n+\t\t\trefs = append(refs, metav1.OwnerReference{\n+\t\t\t\tAPIVersion: pieces[0],\n+\t\t\t\tKind:       pieces[1],\n+\t\t\t\tName:       pieces[2],\n+\t\t\t})\n+\t\t}\n+\t\treturn refs\n+\t}\n+\ttestCases := []struct {\n+\t\torig, new []string\n+\t\tchanged   bool\n+\t}{\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\"},\n+\t\t\tnew:     []string{},\n+\t\t\tchanged: true,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\"},\n+\t\t\tnew:     []string{\"v1/pod/foo\"},\n+\t\t\tchanged: false,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\"},\n+\t\t\tnew:     []string{\"v1/pod/bar\"},\n+\t\t\tchanged: true,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\", \"v1/set/bob\"},\n+\t\t\tnew:     []string{\"v1/pod/foo\", \"v1/set/alice\"},\n+\t\t\tchanged: true,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\", \"v1/set/bob\"},\n+\t\t\tnew:     []string{\"v1/pod/foo\", \"v1/set/bob\"},\n+\t\t\tchanged: false,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\", \"v1/set/bob\"},\n+\t\t\tnew:     []string{\"v1/pod/foo\", \"v1/set/bob\", \"v1/set/bob\"},\n+\t\t\tchanged: true,\n+\t\t},\n+\t\t{\n+\t\t\torig:    []string{\"v1/pod/foo\", \"v1/set/bob\"},\n+\t\t\tnew:     []string{\"v1/set/bob\", \"v1/pod/foo\"},\n+\t\t\tchanged: false,\n+\t\t},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tif ownerRefsChanged(toRefs(tc.orig), toRefs(tc.new)) != tc.changed {\n+\t\t\tt.Errorf(\"Expected change=%t but got %t for %v vs %v\", tc.changed, !tc.changed, tc.orig, tc.new)\n+\t\t}\n+\t}\n+}\n+\n func TestGetParentNameAndOrdinal(t *testing.T) {\n \tset := newStatefulSet(3)\n \tpod := newStatefulSetPod(set, 1)\n@@ -253,7 +336,84 @@ func TestGetPersistentVolumeClaimRetentionPolicy(t *testing.T) {\n \t}\n }\n \n-func TestClaimOwnerMatchesSetAndPod(t *testing.T) {\n+func TestMatchesRef(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\tref         metav1.OwnerReference\n+\t\tobj         metav1.ObjectMeta\n+\t\tschema      schema.GroupVersionKind\n+\t\tshouldMatch bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"full match\",\n+\t\t\tref: metav1.OwnerReference{\n+\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\tKind:       \"Pod\",\n+\t\t\t\tName:       \"fred\",\n+\t\t\t\tUID:        \"abc\",\n+\t\t\t},\n+\t\t\tobj: metav1.ObjectMeta{\n+\t\t\t\tName: \"fred\",\n+\t\t\t\tUID:  \"abc\",\n+\t\t\t},\n+\t\t\tschema:      podKind,\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"match without UID\",\n+\t\t\tref: metav1.OwnerReference{\n+\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\tKind:       \"Pod\",\n+\t\t\t\tName:       \"fred\",\n+\t\t\t\tUID:        \"abc\",\n+\t\t\t},\n+\t\t\tobj: metav1.ObjectMeta{\n+\t\t\t\tName: \"fred\",\n+\t\t\t\tUID:  \"not-matching\",\n+\t\t\t},\n+\t\t\tschema:      podKind,\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"mismatch name\",\n+\t\t\tref: metav1.OwnerReference{\n+\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\tKind:       \"Pod\",\n+\t\t\t\tName:       \"fred\",\n+\t\t\t\tUID:        \"abc\",\n+\t\t\t},\n+\t\t\tobj: metav1.ObjectMeta{\n+\t\t\t\tName: \"joan\",\n+\t\t\t\tUID:  \"abc\",\n+\t\t\t},\n+\t\t\tschema:      podKind,\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"wrong schema\",\n+\t\t\tref: metav1.OwnerReference{\n+\t\t\t\tAPIVersion: \"beta2\",\n+\t\t\t\tKind:       \"Pod\",\n+\t\t\t\tName:       \"fred\",\n+\t\t\t\tUID:        \"abc\",\n+\t\t\t},\n+\t\t\tobj: metav1.ObjectMeta{\n+\t\t\t\tName: \"fred\",\n+\t\t\t\tUID:  \"abc\",\n+\t\t\t},\n+\t\t\tschema:      podKind,\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\tgot := matchesRef(&tc.ref, &tc.obj, tc.schema)\n+\t\tif got != tc.shouldMatch {\n+\t\t\tt.Errorf(\"Failed %s: got %t, expected %t\", tc.name, got, tc.shouldMatch)\n+\t\t}\n+\t}\n+}\n+\n+func TestIsClaimOwnerUpToDate(t *testing.T) {\n \ttestCases := []struct {\n \t\tname            string\n \t\tscaleDownPolicy apps.PersistentVolumeClaimRetentionPolicyType\n@@ -334,24 +494,32 @@ func TestClaimOwnerMatchesSetAndPod(t *testing.T) {\n \t\t\t\t\t\tWhenDeleted: tc.setDeletePolicy,\n \t\t\t\t\t}\n \t\t\t\t\tset.Spec.Replicas = &tc.replicas\n+\t\t\t\t\tclaimRefs := claim.GetOwnerReferences()\n \t\t\t\t\tif setPodRef {\n-\t\t\t\t\t\tsetOwnerRef(&claim, &pod, &pod.TypeMeta)\n+\t\t\t\t\t\tclaimRefs = addControllerRef(claimRefs, &pod, podKind)\n \t\t\t\t\t}\n \t\t\t\t\tif setSetRef {\n-\t\t\t\t\t\tsetOwnerRef(&claim, &set, &set.TypeMeta)\n+\t\t\t\t\t\tclaimRefs = addControllerRef(claimRefs, &set, controllerKind)\n \t\t\t\t\t}\n \t\t\t\t\tif useOtherRefs {\n-\t\t\t\t\t\trandomObject1 := v1.Pod{}\n-\t\t\t\t\t\trandomObject1.Name = \"rand1\"\n-\t\t\t\t\t\trandomObject1.GetObjectMeta().SetUID(\"rand1-abc\")\n-\t\t\t\t\t\trandomObject2 := v1.Pod{}\n-\t\t\t\t\t\trandomObject2.Name = \"rand2\"\n-\t\t\t\t\t\trandomObject2.GetObjectMeta().SetUID(\"rand2-def\")\n-\t\t\t\t\t\tsetOwnerRef(&claim, &randomObject1, &randomObject1.TypeMeta)\n-\t\t\t\t\t\tsetOwnerRef(&claim, &randomObject2, &randomObject2.TypeMeta)\n+\t\t\t\t\t\tclaimRefs = append(\n+\t\t\t\t\t\t\tclaimRefs,\n+\t\t\t\t\t\t\tmetav1.OwnerReference{\n+\t\t\t\t\t\t\t\tName:       \"rand1\",\n+\t\t\t\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\t\t\t\tUID:        \"rand1-uid\",\n+\t\t\t\t\t\t\t},\n+\t\t\t\t\t\t\tmetav1.OwnerReference{\n+\t\t\t\t\t\t\t\tName:       \"rand2\",\n+\t\t\t\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\t\t\t\tUID:        \"rand2-uid\",\n+\t\t\t\t\t\t\t})\n \t\t\t\t\t}\n+\t\t\t\t\tclaim.SetOwnerReferences(claimRefs)\n \t\t\t\t\tshouldMatch := setPodRef == tc.needsPodRef && setSetRef == tc.needsSetRef\n-\t\t\t\t\tif claimOwnerMatchesSetAndPod(logger, &claim, &set, &pod) != shouldMatch {\n+\t\t\t\t\tif isClaimOwnerUpToDate(logger, &claim, &set, &pod) != shouldMatch {\n \t\t\t\t\t\tt.Errorf(\"Bad match for %s with pod=%v,set=%v,others=%v\", tc.name, setPodRef, setSetRef, useOtherRefs)\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -360,14 +528,194 @@ func TestClaimOwnerMatchesSetAndPod(t *testing.T) {\n \t}\n }\n \n+func TestClaimOwnerUpToDateEdgeCases(t *testing.T) {\n+\t_, ctx := ktesting.NewTestContext(t)\n+\tlogger := klog.FromContext(ctx)\n+\n+\ttestCases := []struct {\n+\t\tname        string\n+\t\townerRefs   []metav1.OwnerReference\n+\t\tpolicy      apps.StatefulSetPersistentVolumeClaimRetentionPolicy\n+\t\tshouldMatch bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"normal controller, pod\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"pod-1\",\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tUID:        \"pod-123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"non-controller causes policy mismatch, pod\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"pod-1\",\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tUID:        \"pod-123\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"stale controller does not affect policy, pod\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"pod-1\",\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tUID:        \"pod-stale\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"unexpected controller causes policy mismatch, pod\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"pod-1\",\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tUID:        \"pod-123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"Random\",\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tUID:        \"random\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"normal controller, set\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"stateful-set\",\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tUID:        \"ss-456\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"non-controller causes policy mismatch, set\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"stateful-set\",\n+\t\t\t\t\tAPIVersion: \"appsv1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tUID:        \"ss-456\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"stale controller ignored, set\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"stateful-set\",\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tUID:        \"set-stale\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"unexpected controller causes policy mismatch, set\",\n+\t\t\townerRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"stateful-set\",\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tUID:        \"ss-456\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tName:       \"Random\",\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tUID:        \"random\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tpolicy: apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  apps.RetainPersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t},\n+\t\t\tshouldMatch: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tclaim := v1.PersistentVolumeClaim{}\n+\t\tclaim.Name = \"target-claim\"\n+\t\tpod := v1.Pod{}\n+\t\tpod.Name = \"pod-1\"\n+\t\tpod.GetObjectMeta().SetUID(\"pod-123\")\n+\t\tset := apps.StatefulSet{}\n+\t\tset.Name = \"stateful-set\"\n+\t\tset.GetObjectMeta().SetUID(\"ss-456\")\n+\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &tc.policy\n+\t\tset.Spec.Replicas = ptr.To(int32(1))\n+\t\tclaim.SetOwnerReferences(tc.ownerRefs)\n+\t\tgot := isClaimOwnerUpToDate(logger, &claim, &set, &pod)\n+\t\tif got != tc.shouldMatch {\n+\t\t\tt.Errorf(\"Unexpected match for %s, got %t expected %t\", tc.name, got, tc.shouldMatch)\n+\t\t}\n+\t}\n+}\n+\n func TestUpdateClaimOwnerRefForSetAndPod(t *testing.T) {\n \ttestCases := []struct {\n-\t\tname            string\n-\t\tscaleDownPolicy apps.PersistentVolumeClaimRetentionPolicyType\n-\t\tsetDeletePolicy apps.PersistentVolumeClaimRetentionPolicyType\n-\t\tcondemned       bool\n-\t\tneedsPodRef     bool\n-\t\tneedsSetRef     bool\n+\t\tname                 string\n+\t\tscaleDownPolicy      apps.PersistentVolumeClaimRetentionPolicyType\n+\t\tsetDeletePolicy      apps.PersistentVolumeClaimRetentionPolicyType\n+\t\tcondemned            bool\n+\t\tneedsPodRef          bool\n+\t\tneedsSetRef          bool\n+\t\tunexpectedController bool\n \t}{\n \t\t{\n \t\t\tname:            \"retain\",\n@@ -417,71 +765,656 @@ func TestUpdateClaimOwnerRefForSetAndPod(t *testing.T) {\n \t\t\tneedsPodRef:     true,\n \t\t\tneedsSetRef:     false,\n \t\t},\n+\t\t{\n+\t\t\tname:                 \"unexpected controller\",\n+\t\t\tscaleDownPolicy:      apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\tsetDeletePolicy:      apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\tcondemned:            true,\n+\t\t\tneedsPodRef:          false,\n+\t\t\tneedsSetRef:          false,\n+\t\t\tunexpectedController: true,\n+\t\t},\n \t}\n \tfor _, tc := range testCases {\n-\t\tfor _, hasPodRef := range []bool{true, false} {\n-\t\t\tfor _, hasSetRef := range []bool{true, false} {\n-\t\t\t\t_, ctx := ktesting.NewTestContext(t)\n-\t\t\t\tlogger := klog.FromContext(ctx)\n-\t\t\t\tset := apps.StatefulSet{}\n-\t\t\t\tset.Name = \"ss\"\n-\t\t\t\tnumReplicas := int32(5)\n-\t\t\t\tset.Spec.Replicas = &numReplicas\n-\t\t\t\tset.SetUID(\"ss-123\")\n-\t\t\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n-\t\t\t\t\tWhenScaled:  tc.scaleDownPolicy,\n-\t\t\t\t\tWhenDeleted: tc.setDeletePolicy,\n-\t\t\t\t}\n-\t\t\t\tpod := v1.Pod{}\n-\t\t\t\tif tc.condemned {\n-\t\t\t\t\tpod.Name = \"pod-8\"\n-\t\t\t\t} else {\n-\t\t\t\t\tpod.Name = \"pod-1\"\n-\t\t\t\t}\n-\t\t\t\tpod.SetUID(\"pod-456\")\n-\t\t\t\tclaim := v1.PersistentVolumeClaim{}\n-\t\t\t\tif hasPodRef {\n-\t\t\t\t\tsetOwnerRef(&claim, &pod, &pod.TypeMeta)\n-\t\t\t\t}\n-\t\t\t\tif hasSetRef {\n-\t\t\t\t\tsetOwnerRef(&claim, &set, &set.TypeMeta)\n-\t\t\t\t}\n-\t\t\t\tneedsUpdate := hasPodRef != tc.needsPodRef || hasSetRef != tc.needsSetRef\n-\t\t\t\tshouldUpdate := updateClaimOwnerRefForSetAndPod(logger, &claim, &set, &pod)\n-\t\t\t\tif shouldUpdate != needsUpdate {\n-\t\t\t\t\tt.Errorf(\"Bad update for %s hasPodRef=%v hasSetRef=%v\", tc.name, hasPodRef, hasSetRef)\n-\t\t\t\t}\n-\t\t\t\tif hasOwnerRef(&claim, &pod) != tc.needsPodRef {\n-\t\t\t\t\tt.Errorf(\"Bad pod ref for %s hasPodRef=%v hasSetRef=%v\", tc.name, hasPodRef, hasSetRef)\n-\t\t\t\t}\n-\t\t\t\tif hasOwnerRef(&claim, &set) != tc.needsSetRef {\n-\t\t\t\t\tt.Errorf(\"Bad set ref for %s hasPodRef=%v hasSetRef=%v\", tc.name, hasPodRef, hasSetRef)\n+\t\tfor variations := 0; variations < 8; variations++ {\n+\t\t\thasPodRef := (variations & 1) != 0\n+\t\t\thasSetRef := (variations & 2) != 0\n+\t\t\textraOwner := (variations & 3) != 0\n+\t\t\t_, ctx := ktesting.NewTestContext(t)\n+\t\t\tlogger := klog.FromContext(ctx)\n+\t\t\tset := apps.StatefulSet{}\n+\t\t\tset.Name = \"ss\"\n+\t\t\tnumReplicas := int32(5)\n+\t\t\tset.Spec.Replicas = &numReplicas\n+\t\t\tset.SetUID(\"ss-123\")\n+\t\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\tWhenScaled:  tc.scaleDownPolicy,\n+\t\t\t\tWhenDeleted: tc.setDeletePolicy,\n+\t\t\t}\n+\t\t\tpod := v1.Pod{}\n+\t\t\tif tc.condemned {\n+\t\t\t\tpod.Name = \"pod-8\"\n+\t\t\t} else {\n+\t\t\t\tpod.Name = \"pod-1\"\n+\t\t\t}\n+\t\t\tpod.SetUID(\"pod-456\")\n+\t\t\tclaim := v1.PersistentVolumeClaim{}\n+\t\t\tclaimRefs := claim.GetOwnerReferences()\n+\t\t\tif hasPodRef {\n+\t\t\t\tclaimRefs = addControllerRef(claimRefs, &pod, podKind)\n+\t\t\t}\n+\t\t\tif hasSetRef {\n+\t\t\t\tclaimRefs = addControllerRef(claimRefs, &set, controllerKind)\n+\t\t\t}\n+\t\t\tif extraOwner {\n+\t\t\t\t// Note the extra owner should not affect our owner references.\n+\t\t\t\tclaimRefs = append(claimRefs, metav1.OwnerReference{\n+\t\t\t\t\tAPIVersion: \"custom/v1\",\n+\t\t\t\t\tKind:       \"random\",\n+\t\t\t\t\tName:       \"random\",\n+\t\t\t\t\tUID:        \"abc\",\n+\t\t\t\t})\n+\t\t\t}\n+\t\t\tif tc.unexpectedController {\n+\t\t\t\tclaimRefs = append(claimRefs, metav1.OwnerReference{\n+\t\t\t\t\tAPIVersion: \"custom/v1\",\n+\t\t\t\t\tKind:       \"Unknown\",\n+\t\t\t\t\tName:       \"unknown\",\n+\t\t\t\t\tUID:        \"xyz\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t})\n+\t\t\t}\n+\t\t\tclaim.SetOwnerReferences(claimRefs)\n+\t\t\tupdateClaimOwnerRefForSetAndPod(logger, &claim, &set, &pod)\n+\t\t\t// Confirm that after the update, the specified owner is set as the only controller.\n+\t\t\t// Any other controllers will be cleaned update by the update.\n+\t\t\tcheck := func(target, owner metav1.Object) bool {\n+\t\t\t\tfor _, ref := range target.GetOwnerReferences() {\n+\t\t\t\t\tif ref.UID == owner.GetUID() {\n+\t\t\t\t\t\treturn ref.Controller != nil && *ref.Controller\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\treturn false\n \t\t\t}\n+\t\t\tif check(&claim, &pod) != tc.needsPodRef {\n+\t\t\t\tt.Errorf(\"Bad pod ref for %s hasPodRef=%v hasSetRef=%v\", tc.name, hasPodRef, hasSetRef)\n+\t\t\t}\n+\t\t\tif check(&claim, &set) != tc.needsSetRef {\n+\t\t\t\tt.Errorf(\"Bad set ref for %s hasPodRef=%v hasSetRef=%v\", tc.name, hasPodRef, hasSetRef)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestUpdateClaimControllerRef(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname         string\n+\t\toriginalRefs []metav1.OwnerReference\n+\t\texpectedRefs []metav1.OwnerReference\n+\t}{\n+\t\t{\n+\t\t\tname: \"set correctly\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"someone\",\n+\t\t\t\t\tKind:       \"Else\",\n+\t\t\t\t\tName:       \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"someone\",\n+\t\t\t\t\tKind:       \"Else\",\n+\t\t\t\t\tName:       \"foo\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"missing controller\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"matching name but missing\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"someone\",\n+\t\t\t\t\tKind:       \"else\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"456\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\texpectedRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"someone\",\n+\t\t\t\t\tKind:       \"else\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"456\",\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname:         \"not present\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{},\n+\t\t\texpectedRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tUID:        \"123\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"controller, but no UID\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t// The missing UID is interpreted as an unexpected stale reference.\n+\t\t\texpectedRefs: []metav1.OwnerReference{},\n+\t\t},\n+\t\t{\n+\t\t\tname: \"neither controller nor UID\",\n+\t\t\toriginalRefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"sts\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t// The missing UID is interpreted as an unexpected stale reference.\n+\t\t\texpectedRefs: []metav1.OwnerReference{},\n+\t\t},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\t_, ctx := ktesting.NewTestContext(t)\n+\t\tlogger := klog.FromContext(ctx)\n+\t\tset := apps.StatefulSet{}\n+\t\tset.Name = \"sts\"\n+\t\tset.Spec.Replicas = ptr.To(int32(1))\n+\t\tset.SetUID(\"123\")\n+\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\tWhenScaled:  apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\tWhenDeleted: apps.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t}\n+\t\tpod := v1.Pod{}\n+\t\tpod.Name = \"pod-0\"\n+\t\tpod.SetUID(\"456\")\n+\t\tclaim := v1.PersistentVolumeClaim{}\n+\t\tclaim.SetOwnerReferences(tc.originalRefs)\n+\t\tupdateClaimOwnerRefForSetAndPod(logger, &claim, &set, &pod)\n+\t\tif ownerRefsChanged(tc.expectedRefs, claim.GetOwnerReferences()) {\n+\t\t\tt.Errorf(\"%s: expected %v, got %v\", tc.name, tc.expectedRefs, claim.GetOwnerReferences())\n \t\t}\n \t}\n }\n \n func TestHasOwnerRef(t *testing.T) {\n \ttarget := v1.Pod{}\n \ttarget.SetOwnerReferences([]metav1.OwnerReference{\n-\t\t{UID: \"123\"}, {UID: \"456\"}})\n-\townerA := v1.Pod{}\n-\townerA.GetObjectMeta().SetUID(\"123\")\n-\townerB := v1.Pod{}\n-\townerB.GetObjectMeta().SetUID(\"789\")\n-\tif !hasOwnerRef(&target, &ownerA) {\n-\t\tt.Error(\"Missing owner\")\n+\t\t{UID: \"123\", Controller: ptr.To(true)},\n+\t\t{UID: \"456\", Controller: ptr.To(false)},\n+\t\t{UID: \"789\"},\n+\t})\n+\ttestCases := []struct {\n+\t\tuid    types.UID\n+\t\thasRef bool\n+\t}{\n+\t\t{\n+\t\t\tuid:    \"123\",\n+\t\t\thasRef: true,\n+\t\t},\n+\t\t{\n+\t\t\tuid:    \"456\",\n+\t\t\thasRef: true,\n+\t\t},\n+\t\t{\n+\t\t\tuid:    \"789\",\n+\t\t\thasRef: true,\n+\t\t},\n+\t\t{\n+\t\t\tuid:    \"012\",\n+\t\t\thasRef: false,\n+\t\t},\n \t}\n-\tif hasOwnerRef(&target, &ownerB) {\n-\t\tt.Error(\"Unexpected owner\")\n+\tfor _, tc := range testCases {\n+\t\towner := v1.Pod{}\n+\t\towner.GetObjectMeta().SetUID(tc.uid)\n+\t\tgot := hasOwnerRef(&target, &owner)\n+\t\tif got != tc.hasRef {\n+\t\t\tt.Errorf(\"Expected %t for %s, got %t\", tc.hasRef, tc.uid, got)\n+\t\t}\n+\t}\n+}\n+\n+func TestHasUnexpectedController(t *testing.T) {\n+\t// Each test case will be tested against a StatefulSet named \"set\" and a Pod named \"pod\" with UIDs \"123\".\n+\ttestCases := []struct {\n+\t\tname                             string\n+\t\trefs                             []metav1.OwnerReference\n+\t\tshouldReportUnexpectedController bool\n+\t}{\n+\t\t{\n+\t\t\tname: \"custom controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"chipmunks/v1\",\n+\t\t\t\t\tKind:       \"CustomController\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom non-controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"chipmunks/v1\",\n+\t\t\t\t\tKind:       \"CustomController\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(false),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"custom unspecified controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"chipmunks/v1\",\n+\t\t\t\t\tKind:       \"CustomController\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"other pod controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"other set controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"own set controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"own set controller, stale uid\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"StatefulSet\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"stale-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"own pod controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"own pod controller, stale uid\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"stale-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\t// API validation should prevent two controllers from being set,\n+\t\t\t// but for completeness it is still tested.\n+\t\t\tname: \"own controller and another\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"chipmunks/v1\",\n+\t\t\t\t\tKind:       \"CustomController\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"own controller and a non-controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod-uid\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"chipmunks/v1\",\n+\t\t\t\t\tKind:       \"CustomController\",\n+\t\t\t\t\tName:       \"simon\",\n+\t\t\t\t\tUID:        \"other-uid\",\n+\t\t\t\t\tController: ptr.To(false),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tshouldReportUnexpectedController: false,\n+\t\t},\n+\t}\n+\tfor _, tc := range testCases {\n+\t\ttarget := &v1.PersistentVolumeClaim{}\n+\t\ttarget.SetOwnerReferences(tc.refs)\n+\t\tset := &apps.StatefulSet{}\n+\t\tset.SetName(\"set\")\n+\t\tset.SetUID(\"set-uid\")\n+\t\tpod := &v1.Pod{}\n+\t\tpod.SetName(\"pod\")\n+\t\tpod.SetUID(\"pod-uid\")\n+\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = nil\n+\t\tif hasUnexpectedController(target, set, pod) {\n+\t\t\tt.Errorf(\"Any controller should be allowed when no retention policy (retain behavior) is specified. Incorrectly identified unexpected controller at %s\", tc.name)\n+\t\t}\n+\t\tfor _, policy := range []apps.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t{WhenDeleted: \"Retain\", WhenScaled: \"Delete\"},\n+\t\t\t{WhenDeleted: \"Delete\", WhenScaled: \"Retain\"},\n+\t\t\t{WhenDeleted: \"Delete\", WhenScaled: \"Delete\"},\n+\t\t} {\n+\t\t\tset.Spec.PersistentVolumeClaimRetentionPolicy = &policy\n+\t\t\tgot := hasUnexpectedController(target, set, pod)\n+\t\t\tif got != tc.shouldReportUnexpectedController {\n+\t\t\t\tt.Errorf(\"Unexpected controller mismatch at %s (policy %v)\", tc.name, policy)\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func TestNonController(t *testing.T) {\n+\ttestCases := []struct {\n+\t\tname string\n+\t\trefs []metav1.OwnerReference\n+\t\t// The set and pod objets will be created with names \"set\" and \"pod\", respectively.\n+\t\tsetUID        types.UID\n+\t\tpodUID        types.UID\n+\t\tnonController bool\n+\t}{\n+\t\t{\n+\t\t\t// API validation should prevent two controllers from being set,\n+\t\t\t// but for completeness the semantics here are tested.\n+\t\t\tname: \"set and pod controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"set controller, pod noncontroller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod\",\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"set noncontroller, pod controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"set controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"pod controller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"Pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod\",\n+\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname:          \"nothing\",\n+\t\t\trefs:          []metav1.OwnerReference{},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: false,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"set noncontroller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"set noncontroller with ptr\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"apps/v1\",\n+\t\t\t\t\tKind:       \"Set\",\n+\t\t\t\t\tName:       \"set\",\n+\t\t\t\t\tUID:        \"set\",\n+\t\t\t\t\tController: ptr.To(false),\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"pod noncontroller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"pod\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: true,\n+\t\t},\n+\t\t{\n+\t\t\tname: \"other noncontroller\",\n+\t\t\trefs: []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"pod\",\n+\t\t\t\t\tName:       \"pod\",\n+\t\t\t\t\tUID:        \"not-matching\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tsetUID:        \"set\",\n+\t\t\tpodUID:        \"pod\",\n+\t\t\tnonController: false,\n+\t\t},\n+\t}\n+\n+\tfor _, tc := range testCases {\n+\t\tclaim := v1.PersistentVolumeClaim{}\n+\t\tclaim.SetOwnerReferences(tc.refs)\n+\t\tpod := v1.Pod{}\n+\t\tpod.SetUID(tc.podUID)\n+\t\tpod.SetName(\"pod\")\n+\t\tset := apps.StatefulSet{}\n+\t\tset.SetUID(tc.setUID)\n+\t\tset.SetName(\"set\")\n+\t\tgot := hasNonControllerOwner(&claim, &set, &pod)\n+\t\tif got != tc.nonController {\n+\t\t\tt.Errorf(\"Failed %s: got %t, expected %t\", tc.name, got, tc.nonController)\n+\t\t}\n \t}\n }\n \n func TestHasStaleOwnerRef(t *testing.T) {\n-\ttarget := v1.Pod{}\n+\ttarget := v1.PersistentVolumeClaim{}\n \ttarget.SetOwnerReferences([]metav1.OwnerReference{\n-\t\t{Name: \"bob\", UID: \"123\"}, {Name: \"shirley\", UID: \"456\"}})\n+\t\t{Name: \"bob\", UID: \"123\", APIVersion: \"v1\", Kind: \"Pod\"},\n+\t\t{Name: \"shirley\", UID: \"456\", APIVersion: \"v1\", Kind: \"Pod\"},\n+\t})\n \townerA := v1.Pod{}\n \townerA.SetUID(\"123\")\n \townerA.Name = \"bob\"\n@@ -491,93 +1424,17 @@ func TestHasStaleOwnerRef(t *testing.T) {\n \townerC := v1.Pod{}\n \townerC.Name = \"yvonne\"\n \townerC.SetUID(\"345\")\n-\tif hasStaleOwnerRef(&target, &ownerA) {\n+\tif hasStaleOwnerRef(&target, &ownerA, podKind) {\n \t\tt.Error(\"ownerA should not be stale\")\n \t}\n-\tif !hasStaleOwnerRef(&target, &ownerB) {\n+\tif !hasStaleOwnerRef(&target, &ownerB, podKind) {\n \t\tt.Error(\"ownerB should be stale\")\n \t}\n-\tif hasStaleOwnerRef(&target, &ownerC) {\n+\tif hasStaleOwnerRef(&target, &ownerC, podKind) {\n \t\tt.Error(\"ownerC should not be stale\")\n \t}\n }\n \n-func TestSetOwnerRef(t *testing.T) {\n-\ttarget := v1.Pod{}\n-\townerA := v1.Pod{}\n-\townerA.Name = \"A\"\n-\townerA.GetObjectMeta().SetUID(\"ABC\")\n-\tif setOwnerRef(&target, &ownerA, &ownerA.TypeMeta) != true {\n-\t\tt.Errorf(\"Unexpected lack of update\")\n-\t}\n-\townerRefs := target.GetObjectMeta().GetOwnerReferences()\n-\tif len(ownerRefs) != 1 {\n-\t\tt.Errorf(\"Unexpected owner ref count: %d\", len(ownerRefs))\n-\t}\n-\tif ownerRefs[0].UID != \"ABC\" {\n-\t\tt.Errorf(\"Unexpected owner UID %v\", ownerRefs[0].UID)\n-\t}\n-\tif setOwnerRef(&target, &ownerA, &ownerA.TypeMeta) != false {\n-\t\tt.Errorf(\"Unexpected update\")\n-\t}\n-\tif len(target.GetObjectMeta().GetOwnerReferences()) != 1 {\n-\t\tt.Error(\"Unexpected duplicate reference\")\n-\t}\n-\townerB := v1.Pod{}\n-\townerB.Name = \"B\"\n-\townerB.GetObjectMeta().SetUID(\"BCD\")\n-\tif setOwnerRef(&target, &ownerB, &ownerB.TypeMeta) != true {\n-\t\tt.Error(\"Unexpected lack of second update\")\n-\t}\n-\townerRefs = target.GetObjectMeta().GetOwnerReferences()\n-\tif len(ownerRefs) != 2 {\n-\t\tt.Errorf(\"Unexpected owner ref count: %d\", len(ownerRefs))\n-\t}\n-\tif ownerRefs[0].UID != \"ABC\" || ownerRefs[1].UID != \"BCD\" {\n-\t\tt.Errorf(\"Bad second ownerRefs: %v\", ownerRefs)\n-\t}\n-}\n-\n-func TestRemoveOwnerRef(t *testing.T) {\n-\ttarget := v1.Pod{}\n-\townerA := v1.Pod{}\n-\townerA.Name = \"A\"\n-\townerA.GetObjectMeta().SetUID(\"ABC\")\n-\tif removeOwnerRef(&target, &ownerA) != false {\n-\t\tt.Error(\"Unexpected update on empty remove\")\n-\t}\n-\tsetOwnerRef(&target, &ownerA, &ownerA.TypeMeta)\n-\tif removeOwnerRef(&target, &ownerA) != true {\n-\t\tt.Error(\"Unexpected lack of update\")\n-\t}\n-\tif len(target.GetObjectMeta().GetOwnerReferences()) != 0 {\n-\t\tt.Error(\"Unexpected owner reference remains\")\n-\t}\n-\n-\townerB := v1.Pod{}\n-\townerB.Name = \"B\"\n-\townerB.GetObjectMeta().SetUID(\"BCD\")\n-\n-\tsetOwnerRef(&target, &ownerA, &ownerA.TypeMeta)\n-\tif removeOwnerRef(&target, &ownerB) != false {\n-\t\tt.Error(\"Unexpected update for mismatched owner\")\n-\t}\n-\tif len(target.GetObjectMeta().GetOwnerReferences()) != 1 {\n-\t\tt.Error(\"Missing ref after no-op remove\")\n-\t}\n-\tsetOwnerRef(&target, &ownerB, &ownerB.TypeMeta)\n-\tif removeOwnerRef(&target, &ownerA) != true {\n-\t\tt.Error(\"Missing update for second remove\")\n-\t}\n-\townerRefs := target.GetObjectMeta().GetOwnerReferences()\n-\tif len(ownerRefs) != 1 {\n-\t\tt.Error(\"Extra ref after second remove\")\n-\t}\n-\tif ownerRefs[0].UID != \"BCD\" {\n-\t\tt.Error(\"Bad UID after second remove\")\n-\t}\n-}\n-\n func TestIsRunningAndReady(t *testing.T) {\n \tset := newStatefulSet(3)\n \tpod := newStatefulSetPod(set, 1)"
    },
    {
      "filename": "test/e2e/apps/statefulset.go",
      "status": "modified",
      "patch": "@@ -22,6 +22,7 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"regexp\"\n+\t\"slices\"\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n@@ -34,6 +35,7 @@ import (\n \tappsv1 \"k8s.io/api/apps/v1\"\n \tautoscalingv1 \"k8s.io/api/autoscaling/v1\"\n \tv1 \"k8s.io/api/core/v1\"\n+\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n \tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n \t\"k8s.io/apimachinery/pkg/fields\"\n \tklabels \"k8s.io/apimachinery/pkg/labels\"\n@@ -59,6 +61,7 @@ import (\n \timageutils \"k8s.io/kubernetes/test/utils/image\"\n \tadmissionapi \"k8s.io/pod-security-admission/api\"\n \t\"k8s.io/utils/pointer\"\n+\t\"k8s.io/utils/ptr\"\n )\n \n const (\n@@ -1339,6 +1342,84 @@ var _ = SIGDescribe(\"StatefulSet\", func() {\n \t\t\tframework.ExpectNoError(err)\n \t\t})\n \n+\t\tginkgo.It(\"should not delete PVC with OnScaledown policy if another controller owns the PVC\", func(ctx context.Context) {\n+\t\t\te2epv.SkipIfNoDefaultStorageClass(ctx, c)\n+\t\t\tginkgo.By(\"Creating statefulset \" + ssName + \" in namespace \" + ns)\n+\t\t\t*(ss.Spec.Replicas) = 3\n+\t\t\t_, err := c.AppsV1().StatefulSets(ns).Create(ctx, ss, metav1.CreateOptions{})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Confirm PVC has been created\")\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{0, 1, 2})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Create configmap to use as dummy controller\")\n+\t\t\tdummyConfigMap, err := c.CoreV1().ConfigMaps(ns).Create(ctx, &v1.ConfigMap{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tGenerateName: \"dummy-controller\",\n+\t\t\t\t\tNamespace:    ns,\n+\t\t\t\t},\n+\t\t\t}, metav1.CreateOptions{})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t\tdefer func() {\n+\t\t\t\t// Will be cleaned up with the namespace if this fails.\n+\t\t\t\t_ = c.CoreV1().ConfigMaps(ns).Delete(ctx, dummyConfigMap.Name, metav1.DeleteOptions{})\n+\t\t\t}()\n+\n+\t\t\tginkgo.By(\"Update PVC 1 owner ref\")\n+\t\t\tpvc1Name := fmt.Sprintf(\"datadir-%s-1\", ss.Name)\n+\t\t\t_, err = updatePVCWithRetries(ctx, c, ns, pvc1Name, func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\tupdate.OwnerReferences = []metav1.OwnerReference{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tName:       dummyConfigMap.GetName(),\n+\t\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\t\tKind:       \"ConfigMap\",\n+\t\t\t\t\t\tUID:        dummyConfigMap.GetUID(),\n+\t\t\t\t\t\tController: ptr.To(true),\n+\t\t\t\t\t},\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Update StatefulSet retention policy\")\n+\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ss.Name, func(update *appsv1.StatefulSet) {\n+\t\t\t\tupdate.Spec.PersistentVolumeClaimRetentionPolicy = &appsv1.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\t\tWhenScaled: appsv1.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Scale StatefulSet down to 0\")\n+\t\t\t_, err = e2estatefulset.Scale(ctx, c, ss, 0)\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Verify PVC 1 still exists\")\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{1})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Remove PVC 1 owner ref\")\n+\t\t\t_, err = updatePVCWithRetries(ctx, c, ns, pvc1Name, func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\tupdate.OwnerReferences = nil\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Scale set back up to 2\")\n+\t\t\t_, err = e2estatefulset.Scale(ctx, c, ss, 2)\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Confirm PVCs scaled up as well\")\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{0, 1})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Scale set down to 1\")\n+\t\t\t_, err = e2estatefulset.Scale(ctx, c, ss, 1)\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Confirm PVC 1 deleted this time\")\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{0})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t})\n+\n \t\tginkgo.It(\"should delete PVCs after adopting pod (WhenDeleted)\", func(ctx context.Context) {\n \t\t\te2epv.SkipIfNoDefaultStorageClass(ctx, c)\n \t\t\tginkgo.By(\"Creating statefulset \" + ssName + \" in namespace \" + ns)\n@@ -1400,6 +1481,191 @@ var _ = SIGDescribe(\"StatefulSet\", func() {\n \t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{0})\n \t\t\tframework.ExpectNoError(err)\n \t\t})\n+\n+\t\tginkgo.It(\"should not delete PVCs when there is another controller\", func(ctx context.Context) {\n+\t\t\te2epv.SkipIfNoDefaultStorageClass(ctx, c)\n+\t\t\tginkgo.By(\"Creating statefulset \" + ssName + \" with no retention policy in namespace \" + ns)\n+\n+\t\t\t*(ss.Spec.Replicas) = 4\n+\t\t\t_, err := c.AppsV1().StatefulSets(ns).Create(ctx, ss, metav1.CreateOptions{})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Confirming all 4 PVCs exist\")\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{0, 1, 2, 3})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tclaimNames := make([]string, 4)\n+\t\t\tfor i := 0; i < 4; i++ {\n+\t\t\t\tclaimNames[i] = fmt.Sprintf(\"%s-%s-%d\", statefulPodMounts[0].Name, ssName, i)\n+\t\t\t}\n+\n+\t\t\tginkgo.By(\"Create configmap to use as random owner\")\n+\t\t\trandomConfigMap, err := c.CoreV1().ConfigMaps(ns).Create(ctx, &v1.ConfigMap{\n+\t\t\t\tObjectMeta: metav1.ObjectMeta{\n+\t\t\t\t\tGenerateName: \"random-owner\",\n+\t\t\t\t\tNamespace:    ns,\n+\t\t\t\t},\n+\t\t\t}, metav1.CreateOptions{})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t\tdefer func() {\n+\t\t\t\t// Will be cleaned up by the namespace delete if this fails\n+\t\t\t\t_ = c.CoreV1().ConfigMaps(ns).Delete(ctx, randomConfigMap.Name, metav1.DeleteOptions{})\n+\t\t\t}()\n+\n+\t\t\tginkgo.By(\"Add external owner to PVC 1\")\n+\t\t\texpectedExternalRef := []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion: \"v1\",\n+\t\t\t\t\tKind:       \"ConfigMap\",\n+\t\t\t\t\tName:       randomConfigMap.GetName(),\n+\t\t\t\t\tUID:        randomConfigMap.GetUID(),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\t_, err = updatePVCWithRetries(ctx, c, ns, claimNames[1], func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\tupdate.SetOwnerReferences(expectedExternalRef)\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Add stale statefulset controller to PVC 3, with finalizer to prevent garbage collection\")\n+\t\t\texpectedStaleRef := []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion:         \"apps/v1\",\n+\t\t\t\t\tKind:               \"StatefulSet\",\n+\t\t\t\t\tName:               \"unknown\",\n+\t\t\t\t\tUID:                \"9d86d6ae-4e06-4ff1-bc55-f77f52e272e9\",\n+\t\t\t\t\tController:         ptr.To(true),\n+\t\t\t\t\tBlockOwnerDeletion: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\t_, err = updatePVCWithRetries(ctx, c, ns, claimNames[3], func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\tupdate.SetOwnerReferences(expectedStaleRef)\n+\t\t\t\tupdate.SetFinalizers([]string{\"keep-with/stale-ref\"})\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tdefer func() {\n+\t\t\t\tif _, err := c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[3], metav1.GetOptions{}); apierrors.IsNotFound(err) {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\t_, err := updatePVCWithRetries(ctx, c, ns, claimNames[3], func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\t\tupdate.SetFinalizers([]string{})\n+\t\t\t\t})\n+\t\t\t\tframework.ExpectNoError(err)\n+\t\t\t}()\n+\n+\t\t\tginkgo.By(\"Check references updated\")\n+\t\t\terr = wait.PollUntilContextTimeout(ctx, e2estatefulset.StatefulSetPoll, e2estatefulset.StatefulSetTimeout, true, func(ctx context.Context) (bool, error) {\n+\t\t\t\tclaim, err := c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[1], metav1.GetOptions{})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(claim.GetOwnerReferences(), expectedExternalRef) {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tclaim, err = c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[3], metav1.GetOptions{})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(claim.GetOwnerReferences(), expectedStaleRef) {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\treturn true, nil // found them all!\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Update retention policy to delete to force claims to resync\")\n+\t\t\tvar ssUID types.UID\n+\t\t\t_, err = updateStatefulSetWithRetries(ctx, c, ns, ssName, func(update *appsv1.StatefulSet) {\n+\t\t\t\tupdate.Spec.PersistentVolumeClaimRetentionPolicy = &appsv1.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\t\tWhenDeleted: appsv1.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\t}\n+\t\t\t\tssUID = update.GetUID()\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\texpectedOwnerRef := []metav1.OwnerReference{\n+\t\t\t\t{\n+\t\t\t\t\tAPIVersion:         \"apps/v1\",\n+\t\t\t\t\tKind:               \"StatefulSet\",\n+\t\t\t\t\tName:               ssName,\n+\t\t\t\t\tUID:                ssUID,\n+\t\t\t\t\tController:         ptr.To(true),\n+\t\t\t\t\tBlockOwnerDeletion: ptr.To(true),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t\tginkgo.By(\"Expect claims 0, 1 and 2 to have ownerRefs to the statefulset, and 3 to have a stale reference\")\n+\t\t\terr = wait.PollUntilContextTimeout(ctx, e2estatefulset.StatefulSetPoll, e2estatefulset.StatefulSetTimeout, true, func(ctx context.Context) (bool, error) {\n+\t\t\t\tfor _, i := range []int{0, 2} {\n+\t\t\t\t\tclaim, err := c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[i], metav1.GetOptions{})\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t\t}\n+\t\t\t\t\tif !reflect.DeepEqual(claim.GetOwnerReferences(), expectedOwnerRef) {\n+\t\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tclaim, err := c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[1], metav1.GetOptions{})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\t// Claim 1's external owner is neither its pod nor its set, so it should get updated with a controller.\n+\t\t\t\tif !reflect.DeepEqual(claim.GetOwnerReferences(), slices.Concat(expectedExternalRef, expectedOwnerRef)) {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tclaim, err = c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[3], metav1.GetOptions{})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tif !reflect.DeepEqual(claim.GetOwnerReferences(), expectedStaleRef) {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\treturn true, nil // found them all!\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Remove controller flag from claim 0\")\n+\t\t\t_, err = updatePVCWithRetries(ctx, c, ns, claimNames[0], func(update *v1.PersistentVolumeClaim) {\n+\t\t\t\tupdate.SetOwnerReferences([]metav1.OwnerReference{\n+\t\t\t\t\t{\n+\t\t\t\t\t\tAPIVersion:         \"apps/v1\",\n+\t\t\t\t\t\tKind:               \"StatefulSet\",\n+\t\t\t\t\t\tName:               ssName,\n+\t\t\t\t\t\tUID:                ssUID,\n+\t\t\t\t\t\tController:         ptr.To(false),\n+\t\t\t\t\t\tBlockOwnerDeletion: ptr.To(true),\n+\t\t\t\t\t},\n+\t\t\t\t})\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\tginkgo.By(\"Update statefulset to provoke a reconcile\")\n+\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ssName, func(update *appsv1.StatefulSet) {\n+\t\t\t\tupdate.Spec.PersistentVolumeClaimRetentionPolicy = &appsv1.StatefulSetPersistentVolumeClaimRetentionPolicy{\n+\t\t\t\t\tWhenDeleted: appsv1.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\t\tWhenScaled:  appsv1.DeletePersistentVolumeClaimRetentionPolicyType,\n+\t\t\t\t}\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t\tginkgo.By(\"Expect controller flag for claim 0 to reconcile back to true\")\n+\t\t\terr = wait.PollUntilContextTimeout(ctx, e2estatefulset.StatefulSetPoll, e2estatefulset.StatefulSetTimeout, true, func(ctx context.Context) (bool, error) {\n+\t\t\t\tclaim, err := c.CoreV1().PersistentVolumeClaims(ns).Get(ctx, claimNames[0], metav1.GetOptions{})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, nil // retry\n+\t\t\t\t}\n+\t\t\t\tif reflect.DeepEqual(claim.GetOwnerReferences(), expectedOwnerRef) {\n+\t\t\t\t\treturn true, nil // success!\n+\t\t\t\t}\n+\t\t\t\treturn false, nil // retry\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err)\n+\n+\t\t\t// Claim 1 has an external owner, and 3 has a finalizer still, so they will not be deleted.\n+\t\t\tginkgo.By(\"Delete the stateful set and wait for claims 0 and 2 but not 1 and 3 to disappear\")\n+\t\t\terr = c.AppsV1().StatefulSets(ns).Delete(ctx, ssName, metav1.DeleteOptions{})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t\terr = verifyStatefulSetPVCsExist(ctx, c, ss, []int{1, 3})\n+\t\t\tframework.ExpectNoError(err)\n+\t\t})\n \t})\n \n \tginkgo.Describe(\"Automatically recreate PVC for pending pod when PVC is missing\", func() {\n@@ -1587,7 +1853,7 @@ var _ = SIGDescribe(\"StatefulSet\", func() {\n \t\t\tframework.ExpectNoError(err)\n \n \t\t\tginkgo.By(\"Increasing .spec.ordinals.start = 4\")\n-\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ss.Name, func(update *appsv1.StatefulSet) {\n+\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ssName, func(update *appsv1.StatefulSet) {\n \t\t\t\tupdate.Spec.Ordinals = &appsv1.StatefulSetOrdinals{\n \t\t\t\t\tStart: 4,\n \t\t\t\t}\n@@ -1621,7 +1887,7 @@ var _ = SIGDescribe(\"StatefulSet\", func() {\n \t\t\tframework.ExpectNoError(err)\n \n \t\t\tginkgo.By(\"Decreasing .spec.ordinals.start = 2\")\n-\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ss.Name, func(update *appsv1.StatefulSet) {\n+\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ssName, func(update *appsv1.StatefulSet) {\n \t\t\t\tupdate.Spec.Ordinals = &appsv1.StatefulSetOrdinals{\n \t\t\t\t\tStart: 2,\n \t\t\t\t}\n@@ -1654,14 +1920,14 @@ var _ = SIGDescribe(\"StatefulSet\", func() {\n \t\t\tframework.ExpectNoError(err)\n \n \t\t\tginkgo.By(\"Removing .spec.ordinals\")\n-\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ss.Name, func(update *appsv1.StatefulSet) {\n+\t\t\tss, err = updateStatefulSetWithRetries(ctx, c, ns, ssName, func(update *appsv1.StatefulSet) {\n \t\t\t\tupdate.Spec.Ordinals = nil\n \t\t\t})\n \t\t\tframework.ExpectNoError(err)\n \n \t\t\t// since we are replacing 2 pods for 2, we need to ensure we wait\n \t\t\t// for the new ones to show up, not just for any random 2\n-\t\t\tframework.Logf(\"Confirming 2 replicas, with start ordinal 0\")\n+\t\t\tginkgo.By(\"Confirming 2 replicas, with start ordinal 0\")\n \t\t\twaitForStatus(ctx, c, ss)\n \t\t\twaitForPodNames(ctx, c, ss, []string{\"ss-0\", \"ss-1\"})\n \t\t\te2estatefulset.WaitForStatusReplicas(ctx, c, ss, 2)\n@@ -2231,7 +2497,7 @@ type updateStatefulSetFunc func(*appsv1.StatefulSet)\n func updateStatefulSetWithRetries(ctx context.Context, c clientset.Interface, namespace, name string, applyUpdate updateStatefulSetFunc) (statefulSet *appsv1.StatefulSet, err error) {\n \tstatefulSets := c.AppsV1().StatefulSets(namespace)\n \tvar updateErr error\n-\tpollErr := wait.PollWithContext(ctx, 10*time.Millisecond, 1*time.Minute, func(ctx context.Context) (bool, error) {\n+\tpollErr := wait.PollUntilContextTimeout(ctx, 10*time.Millisecond, 1*time.Minute, true, func(ctx context.Context) (bool, error) {\n \t\tif statefulSet, err = statefulSets.Get(ctx, name, metav1.GetOptions{}); err != nil {\n \t\t\treturn false, err\n \t\t}\n@@ -2245,11 +2511,34 @@ func updateStatefulSetWithRetries(ctx context.Context, c clientset.Interface, na\n \t\treturn false, nil\n \t})\n \tif wait.Interrupted(pollErr) {\n-\t\tpollErr = fmt.Errorf(\"couldn't apply the provided updated to stateful set %q: %v\", name, updateErr)\n+\t\tpollErr = fmt.Errorf(\"couldn't apply the provided updated to stateful set %q: %w\", name, updateErr)\n \t}\n \treturn statefulSet, pollErr\n }\n \n+// updatePVCWithRetries updates PVCs with retries.\n+func updatePVCWithRetries(ctx context.Context, c clientset.Interface, namespace, name string, applyUpdate func(*v1.PersistentVolumeClaim)) (pvc *v1.PersistentVolumeClaim, err error) {\n+\tpvcs := c.CoreV1().PersistentVolumeClaims(namespace)\n+\tvar updateErr error\n+\tpollErr := wait.PollUntilContextTimeout(ctx, 10*time.Millisecond, 1*time.Minute, true, func(ctx context.Context) (bool, error) {\n+\t\tif pvc, err = pvcs.Get(ctx, name, metav1.GetOptions{}); err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\t// Apply the update, then attempt to push it to the apiserver.\n+\t\tapplyUpdate(pvc)\n+\t\tif pvc, err = pvcs.Update(ctx, pvc, metav1.UpdateOptions{}); err == nil {\n+\t\t\tframework.Logf(\"Updating pvc %s\", name)\n+\t\t\treturn true, nil\n+\t\t}\n+\t\tupdateErr = err\n+\t\treturn false, nil\n+\t})\n+\tif wait.Interrupted(pollErr) {\n+\t\tpollErr = fmt.Errorf(\"couldn't apply the provided updated to stateful set %q: %w\", name, updateErr)\n+\t}\n+\treturn pvc, pollErr\n+}\n+\n // getStatefulSet gets the StatefulSet named name in namespace.\n func getStatefulSet(ctx context.Context, c clientset.Interface, namespace, name string) *appsv1.StatefulSet {\n \tss, err := c.AppsV1().StatefulSets(namespace).Get(ctx, name, metav1.GetOptions{})"
    }
  ],
  "fix_category": "Lock atomic region",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": NaN
}