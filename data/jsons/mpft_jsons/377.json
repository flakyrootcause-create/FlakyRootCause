{
  "id": 377,
  "repo": "alloy",
  "issue_url": "https://github.com/grafana/alloy/pull/4387",
  "pr_url": "https://github.com/grafana/alloy/pull/4387",
  "issue_description": "",
  "files_changed": [
    {
      "filename": "internal/component/database_observability/postgres/collector/query_sample_test.go",
      "status": "modified",
      "patch": "@@ -1,9 +1,9 @@\n package collector\n \n import (\n+\t\"bytes\"\n \t\"database/sql\"\n \t\"fmt\"\n-\t\"os\"\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n@@ -33,7 +33,7 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\tname                  string\n \t\tsetupMock             func(mock sqlmock.Sqlmock)\n \t\tdisableQueryRedaction bool\n-\t\texpectedError         bool\n+\t\texpectedErrorLine     string\n \t\texpectedLabels        []model.LabelSet\n \t\texpectedLines         []string\n \t}{\n@@ -57,7 +57,6 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t\t\"SELECT * FROM users\",\n \t\t\t\t\t))\n \t\t\t},\n-\t\t\texpectedError: false,\n \n \t\t\texpectedLabels: []model.LabelSet{\n \t\t\t\t{\"op\": OP_QUERY_SAMPLE},\n@@ -86,7 +85,6 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t\t\"SELECT * FROM large_table\",\n \t\t\t\t\t))\n \t\t\t},\n-\t\t\texpectedError: false,\n \n \t\t\texpectedLabels: []model.LabelSet{\n \t\t\t\t{\"op\": OP_QUERY_SAMPLE},\n@@ -120,7 +118,6 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t\t\"UPDATE users SET status = 'active'\",\n \t\t\t\t\t))\n \t\t\t},\n-\t\t\texpectedError: false,\n \n \t\t\texpectedLabels: []model.LabelSet{\n \t\t\t\t{\"op\": OP_QUERY_SAMPLE},\n@@ -151,9 +148,9 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t\t\"<insufficient privilege>\",\n \t\t\t\t\t))\n \t\t\t},\n-\t\t\texpectedError:  false,\n-\t\t\texpectedLabels: []model.LabelSet{}, // No Loki entries expected\n-\t\t\texpectedLines:  []string{},         // No Loki entries expected\n+\t\t\texpectedErrorLine: `err=\"insufficient privilege to access query`,\n+\t\t\texpectedLabels:    []model.LabelSet{}, // No Loki entries expected\n+\t\t\texpectedLines:     []string{},         // No Loki entries expected\n \t\t},\n \t\t{\n \t\t\tname: \"null database name - no loki entries expected\",\n@@ -175,9 +172,9 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t\t\"SELECT * FROM users\",\n \t\t\t\t\t))\n \t\t\t},\n-\t\t\texpectedError:  false,\n-\t\t\texpectedLabels: []model.LabelSet{}, // No Loki entries expected\n-\t\t\texpectedLines:  []string{},         // No Loki entries expected\n+\t\t\texpectedErrorLine: `err=\"database name is not valid`,\n+\t\t\texpectedLabels:    []model.LabelSet{}, // No Loki entries expected\n+\t\t\texpectedLines:     []string{},         // No Loki entries expected\n \t\t},\n \t\t{\n \t\t\tname: \"query with redaction disabled\",\n@@ -200,7 +197,6 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t\t\t))\n \t\t\t},\n \t\t\tdisableQueryRedaction: true,\n-\t\t\texpectedError:         false,\n \t\t\texpectedLabels: []model.LabelSet{\n \t\t\t\t{\"op\": OP_QUERY_SAMPLE},\n \t\t\t},\n@@ -218,14 +214,14 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\trequire.NoError(t, err)\n \t\t\tdefer db.Close()\n \n-\t\t\tlogger := log.NewLogfmtLogger(os.Stderr)\n+\t\t\tvar logBuffer bytes.Buffer\n \t\t\tlokiClient := loki_fake.NewClient(func() {})\n \n \t\t\tsampleCollector, err := NewQuerySample(QuerySampleArguments{\n \t\t\t\tDB:                    db,\n \t\t\t\tCollectInterval:       time.Second * 5,\n \t\t\t\tEntryHandler:          lokiClient,\n-\t\t\t\tLogger:                logger,\n+\t\t\t\tLogger:                log.NewLogfmtLogger(&logBuffer),\n \t\t\t\tDisableQueryRedaction: tc.disableQueryRedaction,\n \t\t\t})\n \t\t\trequire.NoError(t, err)\n@@ -237,27 +233,41 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\terr = sampleCollector.Start(t.Context())\n \t\t\trequire.NoError(t, err)\n \n-\t\t\t// Wait for Loki entries to be generated and verify their content, labels, and timestamps.\n-\t\t\trequire.Eventually(t, func() bool {\n-\t\t\t\tentries := lokiClient.Received()\n-\t\t\t\tif len(entries) != len(tc.expectedLines) {\n-\t\t\t\t\treturn false\n-\t\t\t\t}\n-\t\t\t\tfor i, entry := range entries {\n-\t\t\t\t\tif !reflect.DeepEqual(entry.Labels, tc.expectedLabels[i]) {\n+\t\t\tif len(tc.expectedErrorLine) > 0 {\n+\t\t\t\trequire.Eventually(t, func() bool {\n+\t\t\t\t\tif mock.ExpectationsWereMet() != nil {\n \t\t\t\t\t\treturn false\n \t\t\t\t\t}\n-\t\t\t\t\tif !strings.Contains(entry.Line, tc.expectedLines[i]) {\n+\t\t\t\t\tentries := lokiClient.Received()\n+\t\t\t\t\treturn strings.Contains(logBuffer.String(), tc.expectedErrorLine) && len(entries) == len(tc.expectedLines)\n+\t\t\t\t}, 2*time.Second, 50*time.Millisecond)\n+\t\t\t}\n+\n+\t\t\tif len(tc.expectedLines) > 0 {\n+\t\t\t\trequire.Eventually(t, func() bool {\n+\t\t\t\t\tif mock.ExpectationsWereMet() != nil {\n \t\t\t\t\t\treturn false\n \t\t\t\t\t}\n-\t\t\t\t\t// Verify that BuildLokiEntryWithTimestamp is setting the timestamp correctly\n-\t\t\t\t\texpectedTimestamp := time.Unix(0, now.UnixNano())\n-\t\t\t\t\tif !entry.Timestamp.Equal(expectedTimestamp) {\n+\t\t\t\t\tentries := lokiClient.Received()\n+\t\t\t\t\tif len(entries) != len(tc.expectedLines) {\n \t\t\t\t\t\treturn false\n \t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\treturn true\n-\t\t\t}, 5*time.Second, 100*time.Millisecond)\n+\t\t\t\t\tfor i, entry := range entries {\n+\t\t\t\t\t\tif !reflect.DeepEqual(entry.Labels, tc.expectedLabels[i]) {\n+\t\t\t\t\t\t\treturn false\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif !strings.Contains(entry.Line, tc.expectedLines[i]) {\n+\t\t\t\t\t\t\treturn false\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\t// Verify that BuildLokiEntryWithTimestamp is setting the timestamp correctly\n+\t\t\t\t\t\texpectedTimestamp := time.Unix(0, now.UnixNano())\n+\t\t\t\t\t\tif !entry.Timestamp.Equal(expectedTimestamp) {\n+\t\t\t\t\t\t\treturn false\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\treturn true\n+\t\t\t\t}, 2*time.Second, 50*time.Millisecond)\n+\t\t\t}\n \n \t\t\tsampleCollector.Stop()\n \n@@ -271,10 +281,6 @@ func TestQuerySample_FetchQuerySample(t *testing.T) {\n \t\t\t// Give time for goroutines to clean up\n \t\t\ttime.Sleep(100 * time.Millisecond)\n \n-\t\t\t// Verify mock expectations and Loki entries\n-\t\t\terr = mock.ExpectationsWereMet()\n-\t\t\trequire.NoError(t, err)\n-\n \t\t\tlokiEntries := lokiClient.Received()\n \t\t\trequire.Equal(t, len(tc.expectedLines), len(lokiEntries))\n \t\t\tfor i, entry := range lokiEntries {"
    },
    {
      "filename": "internal/component/database_observability/postgres/collector/schema_table_test.go",
      "status": "modified",
      "patch": "@@ -1,9 +1,11 @@\n package collector\n \n import (\n+\t\"bytes\"\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"os\"\n+\t\"strings\"\n \t\"testing\"\n \t\"time\"\n \n@@ -79,15 +81,15 @@ func TestSchemaTable(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn len(lokiClient.Received()) == 3\n \t\t}, 2*time.Second, 100*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n \t\tlokiEntries := lokiClient.Received()\n \n \t\tassert.Len(t, lokiEntries, 3)\n@@ -189,15 +191,15 @@ func TestSchemaTable(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn len(lokiClient.Received()) == 8\n \t\t}, 2*time.Second, 100*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n \t\tlokiEntries := lokiClient.Received()\n \n \t\tassert.Len(t, lokiEntries, 8)\n@@ -232,10 +234,11 @@ func TestSchemaTable(t *testing.T) {\n \n \t\tlokiClient := loki_fake.NewClient(func() {})\n \n+\t\tvar logBuffer bytes.Buffer\n \t\tcollector, err := NewSchemaTable(SchemaTableArguments{\n \t\t\tDB:           db,\n \t\t\tEntryHandler: lokiClient,\n-\t\t\tLogger:       log.NewLogfmtLogger(os.Stderr),\n+\t\t\tLogger:       log.NewLogfmtLogger(&logBuffer),\n \t\t})\n \t\trequire.NoError(t, err)\n \t\trequire.NotNil(t, collector)\n@@ -260,17 +263,16 @@ func TestSchemaTable(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n-\t\t\treturn len(lokiClient.Received()) == 0\n-\t\t}, 2*time.Second, 100*time.Millisecond)\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n+\t\t\treturn strings.Contains(logBuffer.String(), `msg=\"no schema detected from pg_namespace\"`)\n+\t\t}, 2*time.Second, 50*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n-\t\tlokiEntries := lokiClient.Received()\n-\t\tassert.Len(t, lokiEntries, 0)\n+\t\tassert.Len(t, lokiClient.Received(), 0)\n \t})\n \n \tt.Run(\"collector logs column with null and empty string default values\", func(t *testing.T) {\n@@ -331,15 +333,15 @@ func TestSchemaTable(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn len(lokiClient.Received()) == 3\n \t\t}, 2*time.Second, 100*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n \t\tlokiEntries := lokiClient.Received()\n \t\tassert.Len(t, lokiEntries, 3)\n \t\trequire.Equal(t, model.LabelSet{\"op\": OP_SCHEMA_DETECTION}, lokiEntries[0].Labels)\n@@ -412,15 +414,15 @@ func Test_collector_detects_auto_increment_column(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn len(lokiClient.Received()) == 3\n \t\t}, 2*time.Second, 100*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n \t\tlokiEntries := lokiClient.Received()\n \t\tassert.Len(t, lokiEntries, 3)\n \t\trequire.Equal(t, model.LabelSet{\"op\": OP_SCHEMA_DETECTION}, lokiEntries[0].Labels)\n@@ -490,15 +492,15 @@ func Test_collector_detects_auto_increment_column(t *testing.T) {\n \t\trequire.NoError(t, err)\n \n \t\trequire.Eventually(t, func() bool {\n+\t\t\tif mock.ExpectationsWereMet() != nil {\n+\t\t\t\treturn false\n+\t\t\t}\n \t\t\treturn len(lokiClient.Received()) == 3\n \t\t}, 2*time.Second, 100*time.Millisecond)\n \n \t\tcollector.Stop()\n \t\tlokiClient.Stop()\n \n-\t\terr = mock.ExpectationsWereMet()\n-\t\trequire.NoError(t, err)\n-\n \t\tlokiEntries := lokiClient.Received()\n \t\tassert.Len(t, lokiEntries, 3)\n \t\trequire.Equal(t, model.LabelSet{\"op\": OP_SCHEMA_DETECTION}, lokiEntries[0].Labels)"
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}