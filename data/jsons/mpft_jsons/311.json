{
  "id": 311,
  "repo": "sentry-python",
  "issue_url": "https://github.com/getsentry/sentry-python/pull/4510",
  "pr_url": "https://github.com/getsentry/sentry-python/pull/4510",
  "issue_description": "* remove casts\r\n* generalize `is_valid_sample_rate` to return the validated float\r\n* added a `validate_scopes` helper method to validate the scopes entry on the context and return the narrowed type\r\n* added a `get_typed_attribute` helper method to narrow the type on getting attributes from otel\r\n* fix a flaky test on gevent",
  "files_changed": [
    {
      "filename": "sentry_sdk/opentelemetry/contextvars_context.py",
      "status": "modified",
      "patch": "@@ -1,4 +1,5 @@\n-from typing import cast, TYPE_CHECKING\n+from __future__ import annotations\n+from typing import TYPE_CHECKING\n \n from opentelemetry.trace import get_current_span, set_span_in_context\n from opentelemetry.trace.span import INVALID_SPAN\n@@ -13,36 +14,37 @@\n     SENTRY_USE_CURRENT_SCOPE_KEY,\n     SENTRY_USE_ISOLATION_SCOPE_KEY,\n )\n+from sentry_sdk.opentelemetry.scope import PotelScope, validate_scopes\n \n if TYPE_CHECKING:\n-    from typing import Optional\n     from contextvars import Token\n-    import sentry_sdk.opentelemetry.scope as scope\n \n \n class SentryContextVarsRuntimeContext(ContextVarsRuntimeContext):\n-    def attach(self, context):\n-        # type: (Context) -> Token[Context]\n-        scopes = get_value(SENTRY_SCOPES_KEY, context)\n+    def attach(self, context: Context) -> Token[Context]:\n+        scopes = validate_scopes(get_value(SENTRY_SCOPES_KEY, context))\n \n-        should_fork_isolation_scope = context.pop(\n-            SENTRY_FORK_ISOLATION_SCOPE_KEY, False\n+        should_fork_isolation_scope = bool(\n+            context.pop(SENTRY_FORK_ISOLATION_SCOPE_KEY, False)\n         )\n-        should_fork_isolation_scope = cast(\"bool\", should_fork_isolation_scope)\n \n         should_use_isolation_scope = context.pop(SENTRY_USE_ISOLATION_SCOPE_KEY, None)\n-        should_use_isolation_scope = cast(\n-            \"Optional[scope.PotelScope]\", should_use_isolation_scope\n+        should_use_isolation_scope = (\n+            should_use_isolation_scope\n+            if isinstance(should_use_isolation_scope, PotelScope)\n+            else None\n         )\n \n         should_use_current_scope = context.pop(SENTRY_USE_CURRENT_SCOPE_KEY, None)\n-        should_use_current_scope = cast(\n-            \"Optional[scope.PotelScope]\", should_use_current_scope\n+        should_use_current_scope = (\n+            should_use_current_scope\n+            if isinstance(should_use_current_scope, PotelScope)\n+            else None\n         )\n \n         if scopes:\n-            scopes = cast(\"tuple[scope.PotelScope, scope.PotelScope]\", scopes)\n-            (current_scope, isolation_scope) = scopes\n+            current_scope = scopes[0]\n+            isolation_scope = scopes[1]\n         else:\n             current_scope = sentry_sdk.get_current_scope()\n             isolation_scope = sentry_sdk.get_isolation_scope()"
    },
    {
      "filename": "sentry_sdk/opentelemetry/propagator.py",
      "status": "modified",
      "patch": "@@ -1,4 +1,4 @@\n-from typing import cast\n+from __future__ import annotations\n \n from opentelemetry import trace\n from opentelemetry.context import (\n@@ -37,21 +37,25 @@\n     extract_sentrytrace_data,\n     should_propagate_trace,\n )\n+from sentry_sdk.opentelemetry.scope import validate_scopes\n \n from typing import TYPE_CHECKING\n \n if TYPE_CHECKING:\n     from typing import Optional, Set\n-    import sentry_sdk.opentelemetry.scope as scope\n \n \n class SentryPropagator(TextMapPropagator):\n     \"\"\"\n     Propagates tracing headers for Sentry's tracing system in a way OTel understands.\n     \"\"\"\n \n-    def extract(self, carrier, context=None, getter=default_getter):\n-        # type: (CarrierT, Optional[Context], Getter[CarrierT]) -> Context\n+    def extract(\n+        self,\n+        carrier: CarrierT,\n+        context: Optional[Context] = None,\n+        getter: Getter[CarrierT] = default_getter,\n+    ) -> Context:\n         if context is None:\n             context = get_current()\n \n@@ -93,13 +97,16 @@ def extract(self, carrier, context=None, getter=default_getter):\n         modified_context = trace.set_span_in_context(span, context)\n         return modified_context\n \n-    def inject(self, carrier, context=None, setter=default_setter):\n-        # type: (CarrierT, Optional[Context], Setter[CarrierT]) -> None\n-        scopes = get_value(SENTRY_SCOPES_KEY, context)\n+    def inject(\n+        self,\n+        carrier: CarrierT,\n+        context: Optional[Context] = None,\n+        setter: Setter[CarrierT] = default_setter,\n+    ) -> None:\n+        scopes = validate_scopes(get_value(SENTRY_SCOPES_KEY, context))\n         if not scopes:\n             return\n \n-        scopes = cast(\"tuple[scope.PotelScope, scope.PotelScope]\", scopes)\n         (current_scope, _) = scopes\n \n         span = current_scope.span\n@@ -114,6 +121,5 @@ def inject(self, carrier, context=None, setter=default_setter):\n             setter.set(carrier, key, value)\n \n     @property\n-    def fields(self):\n-        # type: () -> Set[str]\n+    def fields(self) -> Set[str]:\n         return {SENTRY_TRACE_HEADER_NAME, BAGGAGE_HEADER_NAME}"
    },
    {
      "filename": "sentry_sdk/opentelemetry/sampler.py",
      "status": "modified",
      "patch": "@@ -1,5 +1,5 @@\n+from __future__ import annotations\n from decimal import Decimal\n-from typing import cast\n \n from opentelemetry import trace\n from opentelemetry.sdk.trace.sampling import Sampler, SamplingResult, Decision\n@@ -21,15 +21,16 @@\n from typing import TYPE_CHECKING\n \n if TYPE_CHECKING:\n-    from typing import Any, Optional, Sequence, Union\n+    from typing import Any, Optional, Sequence\n     from opentelemetry.context import Context\n     from opentelemetry.trace import Link, SpanKind\n     from opentelemetry.trace.span import SpanContext\n     from opentelemetry.util.types import Attributes\n \n \n-def get_parent_sampled(parent_context, trace_id):\n-    # type: (Optional[SpanContext], int) -> Optional[bool]\n+def get_parent_sampled(\n+    parent_context: Optional[SpanContext], trace_id: int\n+) -> Optional[bool]:\n     if parent_context is None:\n         return None\n \n@@ -54,8 +55,9 @@ def get_parent_sampled(parent_context, trace_id):\n     return None\n \n \n-def get_parent_sample_rate(parent_context, trace_id):\n-    # type: (Optional[SpanContext], int) -> Optional[float]\n+def get_parent_sample_rate(\n+    parent_context: Optional[SpanContext], trace_id: int\n+) -> Optional[float]:\n     if parent_context is None:\n         return None\n \n@@ -74,8 +76,9 @@ def get_parent_sample_rate(parent_context, trace_id):\n     return None\n \n \n-def get_parent_sample_rand(parent_context, trace_id):\n-    # type: (Optional[SpanContext], int) -> Optional[Decimal]\n+def get_parent_sample_rand(\n+    parent_context: Optional[SpanContext], trace_id: int\n+) -> Optional[Decimal]:\n     if parent_context is None:\n         return None\n \n@@ -91,8 +94,12 @@ def get_parent_sample_rand(parent_context, trace_id):\n     return None\n \n \n-def dropped_result(span_context, attributes, sample_rate=None, sample_rand=None):\n-    # type: (SpanContext, Attributes, Optional[float], Optional[Decimal]) -> SamplingResult\n+def dropped_result(\n+    span_context: SpanContext,\n+    attributes: Attributes,\n+    sample_rate: Optional[float] = None,\n+    sample_rand: Optional[Decimal] = None,\n+) -> SamplingResult:\n     \"\"\"\n     React to a span getting unsampled and return a DROP SamplingResult.\n \n@@ -129,8 +136,12 @@ def dropped_result(span_context, attributes, sample_rate=None, sample_rand=None)\n     )\n \n \n-def sampled_result(span_context, attributes, sample_rate=None, sample_rand=None):\n-    # type: (SpanContext, Attributes, Optional[float], Optional[Decimal]) -> SamplingResult\n+def sampled_result(\n+    span_context: SpanContext,\n+    attributes: Attributes,\n+    sample_rate: Optional[float] = None,\n+    sample_rand: Optional[Decimal] = None,\n+) -> SamplingResult:\n     \"\"\"\n     React to a span being sampled and return a sampled SamplingResult.\n \n@@ -151,8 +162,12 @@ def sampled_result(span_context, attributes, sample_rate=None, sample_rand=None)\n     )\n \n \n-def _update_trace_state(span_context, sampled, sample_rate=None, sample_rand=None):\n-    # type: (SpanContext, bool, Optional[float], Optional[Decimal]) -> TraceState\n+def _update_trace_state(\n+    span_context: SpanContext,\n+    sampled: bool,\n+    sample_rate: Optional[float] = None,\n+    sample_rand: Optional[Decimal] = None,\n+) -> TraceState:\n     trace_state = span_context.trace_state\n \n     sampled = \"true\" if sampled else \"false\"\n@@ -175,15 +190,14 @@ def _update_trace_state(span_context, sampled, sample_rate=None, sample_rand=Non\n class SentrySampler(Sampler):\n     def should_sample(\n         self,\n-        parent_context,  # type: Optional[Context]\n-        trace_id,  # type: int\n-        name,  # type: str\n-        kind=None,  # type: Optional[SpanKind]\n-        attributes=None,  # type: Attributes\n-        links=None,  # type: Optional[Sequence[Link]]\n-        trace_state=None,  # type: Optional[TraceState]\n-    ):\n-        # type: (...) -> SamplingResult\n+        parent_context: Optional[Context],\n+        trace_id: int,\n+        name: str,\n+        kind: Optional[SpanKind] = None,\n+        attributes: Attributes = None,\n+        links: Optional[Sequence[Link]] = None,\n+        trace_state: Optional[TraceState] = None,\n+    ) -> SamplingResult:\n         client = sentry_sdk.get_client()\n \n         parent_span_context = trace.get_current_span(parent_context).get_span_context()\n@@ -209,13 +223,12 @@ def should_sample(\n             sample_rand = parent_sample_rand\n         else:\n             # We are the head SDK and we need to generate a new sample_rand\n-            sample_rand = cast(Decimal, _generate_sample_rand(str(trace_id), (0, 1)))\n+            sample_rand = _generate_sample_rand(str(trace_id), (0, 1))\n \n         # Explicit sampled value provided at start_span\n-        custom_sampled = cast(\n-            \"Optional[bool]\", attributes.get(SentrySpanAttribute.CUSTOM_SAMPLED)\n-        )\n-        if custom_sampled is not None:\n+        custom_sampled = attributes.get(SentrySpanAttribute.CUSTOM_SAMPLED)\n+\n+        if custom_sampled is not None and isinstance(custom_sampled, bool):\n             if is_root_span:\n                 sample_rate = float(custom_sampled)\n                 if sample_rate > 0:\n@@ -262,7 +275,8 @@ def should_sample(\n                 sample_rate_to_propagate = sample_rate\n \n         # If the sample rate is invalid, drop the span\n-        if not is_valid_sample_rate(sample_rate, source=self.__class__.__name__):\n+        sample_rate = is_valid_sample_rate(sample_rate, source=self.__class__.__name__)\n+        if sample_rate is None:\n             logger.warning(\n                 f\"[Tracing.Sampler] Discarding {name} because of invalid sample rate.\"\n             )\n@@ -275,7 +289,6 @@ def should_sample(\n                 sample_rate_to_propagate = sample_rate\n \n         # Compare sample_rand to sample_rate to make the final sampling decision\n-        sample_rate = float(cast(\"Union[bool, float, int]\", sample_rate))\n         sampled = sample_rand < Decimal.from_float(sample_rate)\n \n         if sampled:\n@@ -307,9 +320,13 @@ def get_description(self) -> str:\n         return self.__class__.__name__\n \n \n-def create_sampling_context(name, attributes, parent_span_context, trace_id):\n-    # type: (str, Attributes, Optional[SpanContext], int) -> dict[str, Any]\n-    sampling_context = {\n+def create_sampling_context(\n+    name: str,\n+    attributes: Attributes,\n+    parent_span_context: Optional[SpanContext],\n+    trace_id: int,\n+) -> dict[str, Any]:\n+    sampling_context: dict[str, Any] = {\n         \"transaction_context\": {\n             \"name\": name,\n             \"op\": attributes.get(SentrySpanAttribute.OP) if attributes else None,\n@@ -318,7 +335,7 @@ def create_sampling_context(name, attributes, parent_span_context, trace_id):\n             ),\n         },\n         \"parent_sampled\": get_parent_sampled(parent_span_context, trace_id),\n-    }  # type: dict[str, Any]\n+    }\n \n     if attributes is not None:\n         sampling_context.update(attributes)"
    },
    {
      "filename": "sentry_sdk/opentelemetry/scope.py",
      "status": "modified",
      "patch": "@@ -1,4 +1,4 @@\n-from typing import cast\n+from __future__ import annotations\n from contextlib import contextmanager\n import warnings\n \n@@ -24,9 +24,6 @@\n     SENTRY_USE_ISOLATION_SCOPE_KEY,\n     TRACESTATE_SAMPLED_KEY,\n )\n-from sentry_sdk.opentelemetry.contextvars_context import (\n-    SentryContextVarsRuntimeContext,\n-)\n from sentry_sdk.opentelemetry.utils import trace_state_from_baggage\n from sentry_sdk.scope import Scope, ScopeType\n from sentry_sdk.tracing import Span\n@@ -38,52 +35,46 @@\n \n class PotelScope(Scope):\n     @classmethod\n-    def _get_scopes(cls):\n-        # type: () -> Optional[Tuple[PotelScope, PotelScope]]\n+    def _get_scopes(cls) -> Optional[Tuple[PotelScope, PotelScope]]:\n         \"\"\"\n         Returns the current scopes tuple on the otel context. Internal use only.\n         \"\"\"\n-        return cast(\n-            \"Optional[Tuple[PotelScope, PotelScope]]\", get_value(SENTRY_SCOPES_KEY)\n-        )\n+        return validate_scopes(get_value(SENTRY_SCOPES_KEY))\n \n     @classmethod\n-    def get_current_scope(cls):\n-        # type: () -> PotelScope\n+    def get_current_scope(cls) -> PotelScope:\n         \"\"\"\n         Returns the current scope.\n         \"\"\"\n         return cls._get_current_scope() or _INITIAL_CURRENT_SCOPE\n \n     @classmethod\n-    def _get_current_scope(cls):\n-        # type: () -> Optional[PotelScope]\n+    def _get_current_scope(cls) -> Optional[PotelScope]:\n         \"\"\"\n         Returns the current scope without creating a new one. Internal use only.\n         \"\"\"\n         scopes = cls._get_scopes()\n         return scopes[0] if scopes else None\n \n     @classmethod\n-    def get_isolation_scope(cls):\n-        # type: () -> PotelScope\n+    def get_isolation_scope(cls) -> PotelScope:\n         \"\"\"\n         Returns the isolation scope.\n         \"\"\"\n         return cls._get_isolation_scope() or _INITIAL_ISOLATION_SCOPE\n \n     @classmethod\n-    def _get_isolation_scope(cls):\n-        # type: () -> Optional[PotelScope]\n+    def _get_isolation_scope(cls) -> Optional[PotelScope]:\n         \"\"\"\n         Returns the isolation scope without creating a new one. Internal use only.\n         \"\"\"\n         scopes = cls._get_scopes()\n         return scopes[1] if scopes else None\n \n     @contextmanager\n-    def continue_trace(self, environ_or_headers):\n-        # type: (Dict[str, Any]) -> Generator[None, None, None]\n+    def continue_trace(\n+        self, environ_or_headers: Dict[str, Any]\n+    ) -> Generator[None, None, None]:\n         \"\"\"\n         Sets the propagation context from environment or headers to continue an incoming trace.\n         Any span started within this context manager will use the same trace_id, parent_span_id\n@@ -98,8 +89,7 @@ def continue_trace(self, environ_or_headers):\n             with use_span(NonRecordingSpan(span_context)):\n                 yield\n \n-    def _incoming_otel_span_context(self):\n-        # type: () -> Optional[SpanContext]\n+    def _incoming_otel_span_context(self) -> Optional[SpanContext]:\n         if self._propagation_context is None:\n             return None\n         # If sentry-trace extraction didn't have a parent_span_id, we don't have an upstream header\n@@ -132,8 +122,7 @@ def _incoming_otel_span_context(self):\n \n         return span_context\n \n-    def start_transaction(self, **kwargs):\n-        # type: (Any) -> Span\n+    def start_transaction(self, **kwargs: Any) -> Span:\n         \"\"\"\n         .. deprecated:: 3.0.0\n             This function is deprecated and will be removed in a future release.\n@@ -146,17 +135,15 @@ def start_transaction(self, **kwargs):\n         )\n         return self.start_span(**kwargs)\n \n-    def start_span(self, **kwargs):\n-        # type: (Any) -> Span\n+    def start_span(self, **kwargs: Any) -> Span:\n         return Span(**kwargs)\n \n \n _INITIAL_CURRENT_SCOPE = PotelScope(ty=ScopeType.CURRENT)\n _INITIAL_ISOLATION_SCOPE = PotelScope(ty=ScopeType.ISOLATION)\n \n \n-def setup_initial_scopes():\n-    # type: () -> None\n+def setup_initial_scopes() -> None:\n     global _INITIAL_CURRENT_SCOPE, _INITIAL_ISOLATION_SCOPE\n     _INITIAL_CURRENT_SCOPE = PotelScope(ty=ScopeType.CURRENT)\n     _INITIAL_ISOLATION_SCOPE = PotelScope(ty=ScopeType.ISOLATION)\n@@ -165,17 +152,18 @@ def setup_initial_scopes():\n     attach(set_value(SENTRY_SCOPES_KEY, scopes))\n \n \n-def setup_scope_context_management():\n-    # type: () -> None\n+def setup_scope_context_management() -> None:\n     import opentelemetry.context\n+    from sentry_sdk.opentelemetry.contextvars_context import (\n+        SentryContextVarsRuntimeContext,\n+    )\n \n     opentelemetry.context._RUNTIME_CONTEXT = SentryContextVarsRuntimeContext()\n     setup_initial_scopes()\n \n \n @contextmanager\n-def isolation_scope():\n-    # type: () -> Generator[PotelScope, None, None]\n+def isolation_scope() -> Generator[PotelScope, None, None]:\n     context = set_value(SENTRY_FORK_ISOLATION_SCOPE_KEY, True)\n     token = attach(context)\n     try:\n@@ -185,8 +173,7 @@ def isolation_scope():\n \n \n @contextmanager\n-def new_scope():\n-    # type: () -> Generator[PotelScope, None, None]\n+def new_scope() -> Generator[PotelScope, None, None]:\n     token = attach(get_current())\n     try:\n         yield PotelScope.get_current_scope()\n@@ -195,8 +182,7 @@ def new_scope():\n \n \n @contextmanager\n-def use_scope(scope):\n-    # type: (PotelScope) -> Generator[PotelScope, None, None]\n+def use_scope(scope: PotelScope) -> Generator[PotelScope, None, None]:\n     context = set_value(SENTRY_USE_CURRENT_SCOPE_KEY, scope)\n     token = attach(context)\n \n@@ -207,12 +193,25 @@ def use_scope(scope):\n \n \n @contextmanager\n-def use_isolation_scope(isolation_scope):\n-    # type: (PotelScope) -> Generator[PotelScope, None, None]\n+def use_isolation_scope(\n+    isolation_scope: PotelScope,\n+) -> Generator[PotelScope, None, None]:\n     context = set_value(SENTRY_USE_ISOLATION_SCOPE_KEY, isolation_scope)\n     token = attach(context)\n \n     try:\n         yield isolation_scope\n     finally:\n         detach(token)\n+\n+\n+def validate_scopes(scopes: Any) -> Optional[Tuple[PotelScope, PotelScope]]:\n+    if (\n+        isinstance(scopes, tuple)\n+        and len(scopes) == 2\n+        and isinstance(scopes[0], PotelScope)\n+        and isinstance(scopes[1], PotelScope)\n+    ):\n+        return scopes\n+    else:\n+        return None"
    },
    {
      "filename": "sentry_sdk/opentelemetry/span_processor.py",
      "status": "modified",
      "patch": "@@ -1,5 +1,5 @@\n+from __future__ import annotations\n from collections import deque, defaultdict\n-from typing import cast\n \n from opentelemetry.trace import (\n     format_trace_id,\n@@ -52,30 +52,24 @@ class SentrySpanProcessor(SpanProcessor):\n     Converts OTel spans into Sentry spans so they can be sent to the Sentry backend.\n     \"\"\"\n \n-    def __new__(cls):\n-        # type: () -> SentrySpanProcessor\n+    def __new__(cls) -> SentrySpanProcessor:\n         if not hasattr(cls, \"instance\"):\n             cls.instance = super().__new__(cls)\n \n         return cls.instance\n \n-    def __init__(self):\n-        # type: () -> None\n-        self._children_spans = defaultdict(\n-            list\n-        )  # type: DefaultDict[int, List[ReadableSpan]]\n-        self._dropped_spans = defaultdict(lambda: 0)  # type: DefaultDict[int, int]\n+    def __init__(self) -> None:\n+        self._children_spans: DefaultDict[int, List[ReadableSpan]] = defaultdict(list)\n+        self._dropped_spans: DefaultDict[int, int] = defaultdict(lambda: 0)\n \n-    def on_start(self, span, parent_context=None):\n-        # type: (Span, Optional[Context]) -> None\n+    def on_start(self, span: Span, parent_context: Optional[Context] = None) -> None:\n         if is_sentry_span(span):\n             return\n \n         self._add_root_span(span, get_current_span(parent_context))\n         self._start_profile(span)\n \n-    def on_end(self, span):\n-        # type: (ReadableSpan) -> None\n+    def on_end(self, span: ReadableSpan) -> None:\n         if is_sentry_span(span):\n             return\n \n@@ -88,18 +82,15 @@ def on_end(self, span):\n             self._append_child_span(span)\n \n     # TODO-neel-potel not sure we need a clear like JS\n-    def shutdown(self):\n-        # type: () -> None\n+    def shutdown(self) -> None:\n         pass\n \n     # TODO-neel-potel change default? this is 30 sec\n     # TODO-neel-potel call this in client.flush\n-    def force_flush(self, timeout_millis=30000):\n-        # type: (int) -> bool\n+    def force_flush(self, timeout_millis: int = 30000) -> bool:\n         return True\n \n-    def _add_root_span(self, span, parent_span):\n-        # type: (Span, AbstractSpan) -> None\n+    def _add_root_span(self, span: Span, parent_span: AbstractSpan) -> None:\n         \"\"\"\n         This is required to make Span.root_span work\n         since we can't traverse back to the root purely with otel efficiently.\n@@ -112,8 +103,7 @@ def _add_root_span(self, span, parent_span):\n             # root span points to itself\n             set_sentry_meta(span, \"root_span\", span)\n \n-    def _start_profile(self, span):\n-        # type: (Span) -> None\n+    def _start_profile(self, span: Span) -> None:\n         try_autostart_continuous_profiler()\n \n         profiler_id = get_profiler_id()\n@@ -148,14 +138,12 @@ def _start_profile(self, span):\n                 span.set_attribute(SPANDATA.PROFILER_ID, profiler_id)\n             set_sentry_meta(span, \"continuous_profile\", continuous_profile)\n \n-    def _stop_profile(self, span):\n-        # type: (ReadableSpan) -> None\n+    def _stop_profile(self, span: ReadableSpan) -> None:\n         continuous_profiler = get_sentry_meta(span, \"continuous_profile\")\n         if continuous_profiler:\n             continuous_profiler.stop()\n \n-    def _flush_root_span(self, span):\n-        # type: (ReadableSpan) -> None\n+    def _flush_root_span(self, span: ReadableSpan) -> None:\n         transaction_event = self._root_span_to_transaction_event(span)\n         if not transaction_event:\n             return\n@@ -176,8 +164,7 @@ def _flush_root_span(self, span):\n         sentry_sdk.capture_event(transaction_event)\n         self._cleanup_references([span] + collected_spans)\n \n-    def _append_child_span(self, span):\n-        # type: (ReadableSpan) -> None\n+    def _append_child_span(self, span: ReadableSpan) -> None:\n         if not span.parent:\n             return\n \n@@ -192,14 +179,13 @@ def _append_child_span(self, span):\n         else:\n             self._dropped_spans[span.parent.span_id] += 1\n \n-    def _collect_children(self, span):\n-        # type: (ReadableSpan) -> tuple[List[ReadableSpan], int]\n+    def _collect_children(self, span: ReadableSpan) -> tuple[List[ReadableSpan], int]:\n         if not span.context:\n             return [], 0\n \n         children = []\n         dropped_spans = 0\n-        bfs_queue = deque()  # type: Deque[int]\n+        bfs_queue: Deque[int] = deque()\n         bfs_queue.append(span.context.span_id)\n \n         while bfs_queue:\n@@ -215,8 +201,7 @@ def _collect_children(self, span):\n \n     # we construct the event from scratch here\n     # and not use the current Transaction class for easier refactoring\n-    def _root_span_to_transaction_event(self, span):\n-        # type: (ReadableSpan) -> Optional[Event]\n+    def _root_span_to_transaction_event(self, span: ReadableSpan) -> Optional[Event]:\n         if not span.context:\n             return None\n \n@@ -250,23 +235,20 @@ def _root_span_to_transaction_event(self, span):\n             }\n         )\n \n-        profile = cast(\"Optional[Profile]\", get_sentry_meta(span, \"profile\"))\n-        if profile:\n+        profile = get_sentry_meta(span, \"profile\")\n+        if profile is not None and isinstance(profile, Profile):\n             profile.__exit__(None, None, None)\n             if profile.valid():\n                 event[\"profile\"] = profile\n \n         return event\n \n-    def _span_to_json(self, span):\n-        # type: (ReadableSpan) -> Optional[dict[str, Any]]\n+    def _span_to_json(self, span: ReadableSpan) -> Optional[dict[str, Any]]:\n         if not span.context:\n             return None\n \n-        # This is a safe cast because dict[str, Any] is a superset of Event\n-        span_json = cast(\n-            \"dict[str, Any]\", self._common_span_transaction_attributes_as_json(span)\n-        )\n+        # need to ignore the type here due to TypedDict nonsense\n+        span_json: Optional[dict[str, Any]] = self._common_span_transaction_attributes_as_json(span)  # type: ignore\n         if span_json is None:\n             return None\n \n@@ -299,29 +281,28 @@ def _span_to_json(self, span):\n \n         return span_json\n \n-    def _common_span_transaction_attributes_as_json(self, span):\n-        # type: (ReadableSpan) -> Optional[Event]\n+    def _common_span_transaction_attributes_as_json(\n+        self, span: ReadableSpan\n+    ) -> Optional[Event]:\n         if not span.start_time or not span.end_time:\n             return None\n \n-        common_json = {\n+        common_json: Event = {\n             \"start_timestamp\": convert_from_otel_timestamp(span.start_time),\n             \"timestamp\": convert_from_otel_timestamp(span.end_time),\n-        }  # type: Event\n+        }\n \n         tags = extract_span_attributes(span, SentrySpanAttribute.TAG)\n         if tags:\n             common_json[\"tags\"] = tags\n \n         return common_json\n \n-    def _cleanup_references(self, spans):\n-        # type: (List[ReadableSpan]) -> None\n+    def _cleanup_references(self, spans: List[ReadableSpan]) -> None:\n         for span in spans:\n             delete_sentry_meta(span)\n \n-    def _log_debug_info(self):\n-        # type: () -> None\n+    def _log_debug_info(self) -> None:\n         import pprint\n \n         pprint.pprint("
    },
    {
      "filename": "sentry_sdk/opentelemetry/tracing.py",
      "status": "modified",
      "patch": "@@ -1,3 +1,4 @@\n+from __future__ import annotations\n from opentelemetry import trace\n from opentelemetry.propagate import set_global_textmap\n from opentelemetry.sdk.trace import TracerProvider, Span, ReadableSpan\n@@ -10,25 +11,22 @@\n from sentry_sdk.utils import logger\n \n \n-def patch_readable_span():\n-    # type: () -> None\n+def patch_readable_span() -> None:\n     \"\"\"\n     We need to pass through sentry specific metadata/objects from Span to ReadableSpan\n     to work with them consistently in the SpanProcessor.\n     \"\"\"\n     old_readable_span = Span._readable_span\n \n-    def sentry_patched_readable_span(self):\n-        # type: (Span) -> ReadableSpan\n+    def sentry_patched_readable_span(self: Span) -> ReadableSpan:\n         readable_span = old_readable_span(self)\n         readable_span._sentry_meta = getattr(self, \"_sentry_meta\", {})  # type: ignore[attr-defined]\n         return readable_span\n \n     Span._readable_span = sentry_patched_readable_span  # type: ignore[method-assign]\n \n \n-def setup_sentry_tracing():\n-    # type: () -> None\n+def setup_sentry_tracing() -> None:\n     # TracerProvider can only be set once. If we're the first ones setting it,\n     # there's no issue. If it already exists, we need to patch it.\n     from opentelemetry.trace import _TRACER_PROVIDER"
    },
    {
      "filename": "sentry_sdk/opentelemetry/utils.py",
      "status": "modified",
      "patch": "@@ -1,5 +1,5 @@\n+from __future__ import annotations\n import re\n-from typing import cast\n from datetime import datetime, timezone\n \n from urllib3.util import parse_url as urlparse\n@@ -30,9 +30,11 @@\n from sentry_sdk._types import TYPE_CHECKING\n \n if TYPE_CHECKING:\n-    from typing import Any, Optional, Mapping, Sequence, Union\n+    from typing import Any, Optional, Mapping, Sequence, Union, Type, TypeVar\n     from sentry_sdk._types import OtelExtractedSpanData\n \n+    T = TypeVar(\"T\")\n+\n \n GRPC_ERROR_MAP = {\n     \"1\": SPANSTATUS.CANCELLED,\n@@ -54,8 +56,7 @@\n }\n \n \n-def is_sentry_span(span):\n-    # type: (ReadableSpan) -> bool\n+def is_sentry_span(span: ReadableSpan) -> bool:\n     \"\"\"\n     Break infinite loop:\n     HTTP requests to Sentry are caught by OTel and send again to Sentry.\n@@ -65,10 +66,8 @@ def is_sentry_span(span):\n     if not span.attributes:\n         return False\n \n-    span_url = span.attributes.get(SpanAttributes.HTTP_URL, None)\n-    span_url = cast(\"Optional[str]\", span_url)\n-\n-    if not span_url:\n+    span_url = get_typed_attribute(span.attributes, SpanAttributes.HTTP_URL, str)\n+    if span_url is None:\n         return False\n \n     dsn_url = None\n@@ -89,48 +88,46 @@ def is_sentry_span(span):\n     return False\n \n \n-def convert_from_otel_timestamp(time):\n-    # type: (int) -> datetime\n+def convert_from_otel_timestamp(time: int) -> datetime:\n     \"\"\"Convert an OTel nanosecond-level timestamp to a datetime.\"\"\"\n     return datetime.fromtimestamp(time / 1e9, timezone.utc)\n \n \n-def convert_to_otel_timestamp(time):\n-    # type: (Union[datetime, float]) -> int\n+def convert_to_otel_timestamp(time: Union[datetime, float]) -> int:\n     \"\"\"Convert a datetime to an OTel timestamp (with nanosecond precision).\"\"\"\n     if isinstance(time, datetime):\n         return int(time.timestamp() * 1e9)\n     return int(time * 1e9)\n \n \n-def extract_transaction_name_source(span):\n-    # type: (ReadableSpan) -> tuple[Optional[str], Optional[str]]\n+def extract_transaction_name_source(\n+    span: ReadableSpan,\n+) -> tuple[Optional[str], Optional[str]]:\n     if not span.attributes:\n         return (None, None)\n     return (\n-        cast(\"Optional[str]\", span.attributes.get(SentrySpanAttribute.NAME)),\n-        cast(\"Optional[str]\", span.attributes.get(SentrySpanAttribute.SOURCE)),\n+        get_typed_attribute(span.attributes, SentrySpanAttribute.NAME, str),\n+        get_typed_attribute(span.attributes, SentrySpanAttribute.SOURCE, str),\n     )\n \n \n-def extract_span_data(span):\n-    # type: (ReadableSpan) -> OtelExtractedSpanData\n+def extract_span_data(span: ReadableSpan) -> OtelExtractedSpanData:\n     op = span.name\n     description = span.name\n     status, http_status = extract_span_status(span)\n     origin = None\n     if span.attributes is None:\n         return (op, description, status, http_status, origin)\n \n-    attribute_op = cast(\"Optional[str]\", span.attributes.get(SentrySpanAttribute.OP))\n+    attribute_op = get_typed_attribute(span.attributes, SentrySpanAttribute.OP, str)\n     op = attribute_op or op\n-    description = cast(\n-        \"str\", span.attributes.get(SentrySpanAttribute.DESCRIPTION) or description\n+    description = (\n+        get_typed_attribute(span.attributes, SentrySpanAttribute.DESCRIPTION, str)\n+        or description\n     )\n-    origin = cast(\"Optional[str]\", span.attributes.get(SentrySpanAttribute.ORIGIN))\n+    origin = get_typed_attribute(span.attributes, SentrySpanAttribute.ORIGIN, str)\n \n-    http_method = span.attributes.get(SpanAttributes.HTTP_METHOD)\n-    http_method = cast(\"Optional[str]\", http_method)\n+    http_method = get_typed_attribute(span.attributes, SpanAttributes.HTTP_METHOD, str)\n     if http_method:\n         return span_data_for_http_method(span)\n \n@@ -165,11 +162,10 @@ def extract_span_data(span):\n     return (op, description, status, http_status, origin)\n \n \n-def span_data_for_http_method(span):\n-    # type: (ReadableSpan) -> OtelExtractedSpanData\n+def span_data_for_http_method(span: ReadableSpan) -> OtelExtractedSpanData:\n     span_attributes = span.attributes or {}\n \n-    op = cast(\"Optional[str]\", span_attributes.get(SentrySpanAttribute.OP))\n+    op = get_typed_attribute(span_attributes, SentrySpanAttribute.OP, str)\n     if op is None:\n         op = \"http\"\n \n@@ -184,10 +180,9 @@ def span_data_for_http_method(span):\n     peer_name = span_attributes.get(SpanAttributes.NET_PEER_NAME)\n \n     # TODO-neel-potel remove description completely\n-    description = span_attributes.get(\n-        SentrySpanAttribute.DESCRIPTION\n-    ) or span_attributes.get(SentrySpanAttribute.NAME)\n-    description = cast(\"Optional[str]\", description)\n+    description = get_typed_attribute(\n+        span_attributes, SentrySpanAttribute.DESCRIPTION, str\n+    ) or get_typed_attribute(span_attributes, SentrySpanAttribute.NAME, str)\n     if description is None:\n         description = f\"{http_method}\"\n \n@@ -199,7 +194,7 @@ def span_data_for_http_method(span):\n             description = f\"{http_method} {peer_name}\"\n         else:\n             url = span_attributes.get(SpanAttributes.HTTP_URL)\n-            url = cast(\"Optional[str]\", url)\n+            url = get_typed_attribute(span_attributes, SpanAttributes.HTTP_URL, str)\n \n             if url:\n                 parsed_url = urlparse(url)\n@@ -210,28 +205,24 @@ def span_data_for_http_method(span):\n \n     status, http_status = extract_span_status(span)\n \n-    origin = cast(\"Optional[str]\", span_attributes.get(SentrySpanAttribute.ORIGIN))\n+    origin = get_typed_attribute(span_attributes, SentrySpanAttribute.ORIGIN, str)\n \n     return (op, description, status, http_status, origin)\n \n \n-def span_data_for_db_query(span):\n-    # type: (ReadableSpan) -> OtelExtractedSpanData\n+def span_data_for_db_query(span: ReadableSpan) -> OtelExtractedSpanData:\n     span_attributes = span.attributes or {}\n \n-    op = cast(\"str\", span_attributes.get(SentrySpanAttribute.OP, OP.DB))\n-\n-    statement = span_attributes.get(SpanAttributes.DB_STATEMENT, None)\n-    statement = cast(\"Optional[str]\", statement)\n+    op = get_typed_attribute(span_attributes, SentrySpanAttribute.OP, str) or OP.DB\n+    statement = get_typed_attribute(span_attributes, SpanAttributes.DB_STATEMENT, str)\n \n     description = statement or span.name\n-    origin = cast(\"Optional[str]\", span_attributes.get(SentrySpanAttribute.ORIGIN))\n+    origin = get_typed_attribute(span_attributes, SentrySpanAttribute.ORIGIN, str)\n \n     return (op, description, None, None, origin)\n \n \n-def extract_span_status(span):\n-    # type: (ReadableSpan) -> tuple[Optional[str], Optional[int]]\n+def extract_span_status(span: ReadableSpan) -> tuple[Optional[str], Optional[int]]:\n     span_attributes = span.attributes or {}\n     status = span.status or None\n \n@@ -266,8 +257,19 @@ def extract_span_status(span):\n         return (SPANSTATUS.UNKNOWN_ERROR, None)\n \n \n-def infer_status_from_attributes(span_attributes):\n-    # type: (Mapping[str, str | bool | int | float | Sequence[str] | Sequence[bool] | Sequence[int] | Sequence[float]]) -> tuple[Optional[str], Optional[int]]\n+def infer_status_from_attributes(\n+    span_attributes: Mapping[\n+        str,\n+        str\n+        | bool\n+        | int\n+        | float\n+        | Sequence[str]\n+        | Sequence[bool]\n+        | Sequence[int]\n+        | Sequence[float],\n+    ],\n+) -> tuple[Optional[str], Optional[int]]:\n     http_status = get_http_status_code(span_attributes)\n \n     if http_status:\n@@ -280,10 +282,23 @@ def infer_status_from_attributes(span_attributes):\n     return (None, None)\n \n \n-def get_http_status_code(span_attributes):\n-    # type: (Mapping[str, str | bool | int | float | Sequence[str] | Sequence[bool] | Sequence[int] | Sequence[float]]) -> Optional[int]\n+def get_http_status_code(\n+    span_attributes: Mapping[\n+        str,\n+        str\n+        | bool\n+        | int\n+        | float\n+        | Sequence[str]\n+        | Sequence[bool]\n+        | Sequence[int]\n+        | Sequence[float],\n+    ],\n+) -> Optional[int]:\n     try:\n-        http_status = span_attributes.get(SpanAttributes.HTTP_RESPONSE_STATUS_CODE)\n+        http_status = get_typed_attribute(\n+            span_attributes, SpanAttributes.HTTP_RESPONSE_STATUS_CODE, int\n+        )\n     except AttributeError:\n         # HTTP_RESPONSE_STATUS_CODE was added in 1.21, so if we're on an older\n         # OTel version SpanAttributes.HTTP_RESPONSE_STATUS_CODE will throw an\n@@ -292,19 +307,18 @@ def get_http_status_code(span_attributes):\n \n     if http_status is None:\n         # Fall back to the deprecated attribute\n-        http_status = span_attributes.get(SpanAttributes.HTTP_STATUS_CODE)\n-\n-    http_status = cast(\"Optional[int]\", http_status)\n+        http_status = get_typed_attribute(\n+            span_attributes, SpanAttributes.HTTP_STATUS_CODE, int\n+        )\n \n     return http_status\n \n \n-def extract_span_attributes(span, namespace):\n-    # type: (ReadableSpan, str) -> dict[str, Any]\n+def extract_span_attributes(span: ReadableSpan, namespace: str) -> dict[str, Any]:\n     \"\"\"\n     Extract Sentry-specific span attributes and make them look the way Sentry expects.\n     \"\"\"\n-    extracted_attrs = {}  # type: dict[str, Any]\n+    extracted_attrs: dict[str, Any] = {}\n \n     for attr, value in (span.attributes or {}).items():\n         if attr.startswith(namespace):\n@@ -314,8 +328,9 @@ def extract_span_attributes(span, namespace):\n     return extracted_attrs\n \n \n-def get_trace_context(span, span_data=None):\n-    # type: (ReadableSpan, Optional[OtelExtractedSpanData]) -> dict[str, Any]\n+def get_trace_context(\n+    span: ReadableSpan, span_data: Optional[OtelExtractedSpanData] = None\n+) -> dict[str, Any]:\n     if not span.context:\n         return {}\n \n@@ -328,13 +343,13 @@ def get_trace_context(span, span_data=None):\n \n     (op, _, status, _, origin) = span_data\n \n-    trace_context = {\n+    trace_context: dict[str, Any] = {\n         \"trace_id\": trace_id,\n         \"span_id\": span_id,\n         \"parent_span_id\": parent_span_id,\n         \"op\": op,\n         \"origin\": origin or DEFAULT_SPAN_ORIGIN,\n-    }  # type: dict[str, Any]\n+    }\n \n     if status:\n         trace_context[\"status\"] = status\n@@ -350,8 +365,7 @@ def get_trace_context(span, span_data=None):\n     return trace_context\n \n \n-def trace_state_from_baggage(baggage):\n-    # type: (Baggage) -> TraceState\n+def trace_state_from_baggage(baggage: Baggage) -> TraceState:\n     items = []\n     for k, v in baggage.sentry_items.items():\n         key = Baggage.SENTRY_PREFIX + quote(k)\n@@ -360,22 +374,19 @@ def trace_state_from_baggage(baggage):\n     return TraceState(items)\n \n \n-def baggage_from_trace_state(trace_state):\n-    # type: (TraceState) -> Baggage\n+def baggage_from_trace_state(trace_state: TraceState) -> Baggage:\n     return Baggage(dsc_from_trace_state(trace_state))\n \n \n-def serialize_trace_state(trace_state):\n-    # type: (TraceState) -> str\n+def serialize_trace_state(trace_state: TraceState) -> str:\n     sentry_items = []\n     for k, v in trace_state.items():\n         if Baggage.SENTRY_PREFIX_REGEX.match(k):\n             sentry_items.append((k, v))\n     return \",\".join(key + \"=\" + value for key, value in sentry_items)\n \n \n-def dsc_from_trace_state(trace_state):\n-    # type: (TraceState) -> dict[str, str]\n+def dsc_from_trace_state(trace_state: TraceState) -> dict[str, str]:\n     dsc = {}\n     for k, v in trace_state.items():\n         if Baggage.SENTRY_PREFIX_REGEX.match(k):\n@@ -384,16 +395,14 @@ def dsc_from_trace_state(trace_state):\n     return dsc\n \n \n-def has_incoming_trace(trace_state):\n-    # type: (TraceState) -> bool\n+def has_incoming_trace(trace_state: TraceState) -> bool:\n     \"\"\"\n     The existence of a sentry-trace_id in the baggage implies we continued an upstream trace.\n     \"\"\"\n     return (Baggage.SENTRY_PREFIX + \"trace_id\") in trace_state\n \n \n-def get_trace_state(span):\n-    # type: (Union[AbstractSpan, ReadableSpan]) -> TraceState\n+def get_trace_state(span: Union[AbstractSpan, ReadableSpan]) -> TraceState:\n     \"\"\"\n     Get the existing trace_state with sentry items\n     or populate it if we are the head SDK.\n@@ -451,34 +460,45 @@ def get_trace_state(span):\n         return trace_state\n \n \n-def get_sentry_meta(span, key):\n-    # type: (Union[AbstractSpan, ReadableSpan], str) -> Any\n+def get_sentry_meta(span: Union[AbstractSpan, ReadableSpan], key: str) -> Any:\n     sentry_meta = getattr(span, \"_sentry_meta\", None)\n     return sentry_meta.get(key) if sentry_meta else None\n \n \n-def set_sentry_meta(span, key, value):\n-    # type: (Union[AbstractSpan, ReadableSpan], str, Any) -> None\n+def set_sentry_meta(\n+    span: Union[AbstractSpan, ReadableSpan], key: str, value: Any\n+) -> None:\n     sentry_meta = getattr(span, \"_sentry_meta\", {})\n     sentry_meta[key] = value\n     span._sentry_meta = sentry_meta  # type: ignore[union-attr]\n \n \n-def delete_sentry_meta(span):\n-    # type: (Union[AbstractSpan, ReadableSpan]) -> None\n+def delete_sentry_meta(span: Union[AbstractSpan, ReadableSpan]) -> None:\n     try:\n         del span._sentry_meta  # type: ignore[union-attr]\n     except AttributeError:\n         pass\n \n \n-def get_profile_context(span):\n-    # type: (ReadableSpan) -> Optional[dict[str, str]]\n+def get_profile_context(span: ReadableSpan) -> Optional[dict[str, str]]:\n     if not span.attributes:\n         return None\n \n-    profiler_id = cast(\"Optional[str]\", span.attributes.get(SPANDATA.PROFILER_ID))\n+    profiler_id = get_typed_attribute(span.attributes, SPANDATA.PROFILER_ID, str)\n     if profiler_id is None:\n         return None\n \n     return {\"profiler_id\": profiler_id}\n+\n+\n+def get_typed_attribute(\n+    attributes: Mapping[str, Any], key: str, type: Type[T]\n+) -> Optional[T]:\n+    \"\"\"\n+    helper method to coerce types of attribute values\n+    \"\"\"\n+    value = attributes.get(key)\n+    if value is not None and isinstance(value, type):\n+        return value\n+    else:\n+        return None"
    },
    {
      "filename": "sentry_sdk/profiler/transaction_profiler.py",
      "status": "modified",
      "patch": "@@ -281,7 +281,8 @@ def _set_initial_sampling_decision(self, sampling_context):\n             self.sampled = False\n             return\n \n-        if not is_valid_sample_rate(sample_rate, source=\"Profiling\"):\n+        sample_rate = is_valid_sample_rate(sample_rate, source=\"Profiling\")\n+        if sample_rate is None:\n             logger.warning(\n                 \"[Profiling] Discarding profile because of invalid sample rate.\"\n             )\n@@ -291,14 +292,14 @@ def _set_initial_sampling_decision(self, sampling_context):\n         # Now we roll the dice. random.random is inclusive of 0, but not of 1,\n         # so strict < is safe here. In case sample_rate is a boolean, cast it\n         # to a float (True becomes 1.0 and False becomes 0.0)\n-        self.sampled = random.random() < float(sample_rate)\n+        self.sampled = random.random() < sample_rate\n \n         if self.sampled:\n             logger.debug(\"[Profiling] Initializing profile\")\n         else:\n             logger.debug(\n                 \"[Profiling] Discarding profile because it's not included in the random sample (sample rate = {sample_rate})\".format(\n-                    sample_rate=float(sample_rate)\n+                    sample_rate=sample_rate\n                 )\n             )\n "
    },
    {
      "filename": "sentry_sdk/tracing_utils.py",
      "status": "modified",
      "patch": "@@ -752,7 +752,7 @@ def get_current_span(\n def _generate_sample_rand(\n     trace_id: Optional[str],\n     interval: tuple[float, float] = (0.0, 1.0),\n-) -> Optional[Decimal]:\n+) -> Decimal:\n     \"\"\"Generate a sample_rand value from a trace ID.\n \n     The generated value will be pseudorandomly chosen from the provided"
    },
    {
      "filename": "sentry_sdk/utils.py",
      "status": "modified",
      "patch": "@@ -1561,10 +1561,11 @@ def parse_url(url: str, sanitize: bool = True) -> ParsedUrl:\n     )\n \n \n-def is_valid_sample_rate(rate: Any, source: str) -> bool:\n+def is_valid_sample_rate(rate: Any, source: str) -> Optional[float]:\n     \"\"\"\n     Checks the given sample rate to make sure it is valid type and value (a\n     boolean or a number between 0 and 1, inclusive).\n+    Returns the final float value to use if valid.\n     \"\"\"\n \n     # both booleans and NaN are instances of Real, so a) checking for Real\n@@ -1576,7 +1577,7 @@ def is_valid_sample_rate(rate: Any, source: str) -> bool:\n                 source=source, rate=rate, type=type(rate)\n             )\n         )\n-        return False\n+        return None\n \n     # in case rate is a boolean, it will get cast to 1 if it's True and 0 if it's False\n     rate = float(rate)\n@@ -1586,9 +1587,9 @@ def is_valid_sample_rate(rate: Any, source: str) -> bool:\n                 source=source, rate=rate\n             )\n         )\n-        return False\n+        return None\n \n-    return True\n+    return rate\n \n \n def match_regex_list("
    },
    {
      "filename": "tests/integrations/logging/test_logging.py",
      "status": "modified",
      "patch": "@@ -259,8 +259,8 @@ def test_logging_captured_warnings(sentry_init, capture_events, recwarn):\n     assert events[1][\"logentry\"][\"params\"] == []\n \n     # Using recwarn suppresses the \"third\" warning in the test output\n-    assert len(recwarn) == 1\n-    assert str(recwarn[0].message) == \"third\"\n+    third_warnings = [w for w in recwarn if str(w.message) == \"third\"]\n+    assert len(third_warnings) == 1\n \n \n def test_ignore_logger(sentry_init, capture_events):"
    },
    {
      "filename": "tests/test_utils.py",
      "status": "modified",
      "patch": "@@ -493,7 +493,7 @@ def test_accepts_valid_sample_rate(rate):\n     with mock.patch.object(logger, \"warning\", mock.Mock()):\n         result = is_valid_sample_rate(rate, source=\"Testing\")\n         assert logger.warning.called is False\n-        assert result is True\n+        assert result == float(rate)\n \n \n @pytest.mark.parametrize(\n@@ -514,7 +514,7 @@ def test_warns_on_invalid_sample_rate(rate, StringContaining):  # noqa: N803\n     with mock.patch.object(logger, \"warning\", mock.Mock()):\n         result = is_valid_sample_rate(rate, source=\"Testing\")\n         logger.warning.assert_any_call(StringContaining(\"Given sample rate is invalid\"))\n-        assert result is False\n+        assert result is None\n \n \n @pytest.mark.parametrize("
    }
  ],
  "fix_category": "Change assertion",
  "root_cause_category": "Test order dependency",
  "root_cause_subcategory": NaN
}