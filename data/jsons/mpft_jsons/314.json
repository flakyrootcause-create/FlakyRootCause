{
  "id": 314,
  "repo": "kafka",
  "issue_url": "https://github.com/apache/kafka/pull/20496",
  "pr_url": "https://github.com/apache/kafka/pull/20496",
  "issue_description": "This PR moves the topic creation before consumer creations in\n`PlaintextAdminIntegrationTest.testListGroups`, to avoid potential\nerrors if consumer creates topic due to metadata update.\n\nSee discussion\nhttps://github.com/apache/kafka/pull/20244#discussion_r2325557949\n\nReviewers: @chia7712, bbejeck@apache.org\n",
  "files_changed": [
    {
      "filename": "core/src/test/scala/integration/kafka/api/PlaintextAdminIntegrationTest.scala",
      "status": "modified",
      "patch": "@@ -2580,6 +2580,12 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n     val config = createConfig\n     client = Admin.create(config)\n \n+    client.createTopics(util.Set.of(\n+      new NewTopic(testTopicName, 1, 1.toShort)\n+    )).all().get()\n+    waitForTopics(client, List(testTopicName), List())\n+    val topicPartition = new TopicPartition(testTopicName, 0)\n+\n     consumerConfig.put(ConsumerConfig.GROUP_PROTOCOL_CONFIG, GroupProtocol.CLASSIC.name)\n     val classicGroupConfig = new Properties(consumerConfig)\n     classicGroupConfig.put(ConsumerConfig.GROUP_ID_CONFIG, classicGroupId)\n@@ -2600,12 +2606,6 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n     )\n \n     try {\n-      client.createTopics(util.Set.of(\n-        new NewTopic(testTopicName, 1, 1.toShort)\n-      )).all().get()\n-      waitForTopics(client, List(testTopicName), List())\n-      val topicPartition = new TopicPartition(testTopicName, 0)\n-\n       classicGroup.subscribe(util.Set.of(testTopicName))\n       classicGroup.poll(JDuration.ofMillis(1000))\n       consumerGroup.subscribe(util.Set.of(testTopicName))\n@@ -2628,20 +2628,22 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n       val consumerGroupListing = new GroupListing(consumerGroupId, Optional.of(GroupType.CONSUMER), \"consumer\", Optional.of(GroupState.STABLE))\n       val shareGroupListing = new GroupListing(shareGroupId, Optional.of(GroupType.SHARE), \"share\", Optional.of(GroupState.STABLE))\n       val simpleGroupListing = new GroupListing(simpleGroupId, Optional.of(GroupType.CLASSIC), \"\", Optional.of(GroupState.EMPTY))\n-      // Streams group could either be in STABLE or NOT_READY state\n-      val streamsGroupListingStable = new GroupListing(streamsGroupId, Optional.of(GroupType.STREAMS), \"streams\", Optional.of(GroupState.STABLE))\n-      val streamsGroupListingNotReady = new GroupListing(streamsGroupId, Optional.of(GroupType.STREAMS), \"streams\", Optional.of(GroupState.NOT_READY))\n+      val streamsGroupListing = new GroupListing(streamsGroupId, Optional.of(GroupType.STREAMS), \"streams\", Optional.of(GroupState.STABLE))\n \n       var listGroupsResult = client.listGroups()\n       assertTrue(listGroupsResult.errors().get().isEmpty)\n \n-      val expectedStreamListings = Set(streamsGroupListingStable, streamsGroupListingNotReady)\n-      val expectedListings = Set(classicGroupListing, simpleGroupListing, consumerGroupListing, shareGroupListing)\n-      val actualListings = listGroupsResult.all().get().asScala.toSet\n-\n-      // Check that actualListings contains all expectedListings and one of the streams listings\n-      assertTrue(expectedListings.subsetOf(actualListings))\n-      assertTrue(actualListings.exists(expectedStreamListings.contains))\n+      TestUtils.waitUntilTrue(() => {\n+        val listGroupResultScala = client.listGroups().all().get().asScala\n+        val filteredStreamsGroups = listGroupResultScala.filter(_.groupId() == streamsGroupId)\n+        val filteredClassicGroups = listGroupResultScala.filter(_.groupId() == classicGroupId)\n+        val filteredConsumerGroups = listGroupResultScala.filter(_.groupId() == consumerGroupId)\n+        val filteredShareGroups = listGroupResultScala.filter(_.groupId() == shareGroupId)\n+        filteredClassicGroups.forall(_.groupState().orElse(null) == GroupState.STABLE) &&\n+          filteredConsumerGroups.forall(_.groupState().orElse(null) == GroupState.STABLE) &&\n+          filteredShareGroups.forall(_.groupState().orElse(null) == GroupState.STABLE) &&\n+          filteredStreamsGroups.forall(_.groupState().orElse(null) == GroupState.STABLE)\n+      }, \"Groups not stable yet\")\n \n       listGroupsResult = client.listGroups(new ListGroupsOptions().withTypes(util.Set.of(GroupType.CLASSIC)))\n       assertTrue(listGroupsResult.errors().get().isEmpty)\n@@ -2660,10 +2662,8 @@ class PlaintextAdminIntegrationTest extends BaseAdminIntegrationTest {\n \n       listGroupsResult = client.listGroups(new ListGroupsOptions().withTypes(util.Set.of(GroupType.STREAMS)))\n       assertTrue(listGroupsResult.errors().get().isEmpty)\n-      assertTrue(listGroupsResult.all().get().asScala.toSet.equals(Set(streamsGroupListingStable)) ||\n-        listGroupsResult.all().get().asScala.toSet.equals(Set(streamsGroupListingNotReady)))\n-      assertTrue(listGroupsResult.valid().get().asScala.toSet.equals(Set(streamsGroupListingStable)) ||\n-        listGroupsResult.valid().get().asScala.toSet.equals(Set(streamsGroupListingNotReady)))\n+      assertEquals(Set(streamsGroupListing), listGroupsResult.all().get().asScala.toSet)\n+      assertEquals(Set(streamsGroupListing), listGroupsResult.valid().get().asScala.toSet)\n \n     } finally {\n       Utils.closeQuietly(classicGroup, \"classicGroup\")"
    }
  ],
  "fix_category": "Reorder execution",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}