{
  "id": 68,
  "repo": "uv",
  "issue_url": "https://github.com/astral-sh/uv/pull/1144",
  "pr_url": "https://github.com/astral-sh/uv/pull/1144",
  "issue_description": "## Summary\r\n\r\nThis is my guess as to the source of the resolver flake, based on information and extensive debugging from @zanieb. In short, if we rely on `self.index.packages` as a source of truth during error reporting, we open ourselves up to a source of non-determinism, because we fetch package metadata asynchronously in the background while we solve -- so packages _could_ be included in or excluded from the index depending on the order in which those requests are returned.\r\n\r\nSo, instead, we now track the set of packages that _were_ visited by the solver. Visiting a package _requires_ that we wait for its metadata to be available. By limiting analysis to those packages that were visited during solving, we are faithfully representing the state of the solver at the time of failure.\r\n\r\nCloses #863 ",
  "files_changed": [
    {
      "filename": ".config/nextest.toml",
      "status": "modified",
      "patch": "@@ -1,13 +1,3 @@\n [profile.default]\n # Mark tests that take longer than 10s as slow\n slow-timeout = \"10s\"\n-\n-[[profile.default.overrides]]\n-# Some of these tests have a non-determinstic snapshot\n-filter = 'binary(pip_install_scenarios)'\n-retries = 2\n-\n-[[profile.no-retry.overrides]]\n-# An optional profile to avoid retries\n-filter = 'binary(pip_install_scenarios)'\n-retries = 0"
    },
    {
      "filename": "crates/puffin-resolver/src/error.rs",
      "status": "modified",
      "patch": "@@ -2,6 +2,7 @@ use std::collections::BTreeSet;\n use std::convert::Infallible;\n use std::fmt::Formatter;\n \n+use dashmap::DashSet;\n use indexmap::IndexMap;\n use pubgrub::range::Range;\n use pubgrub::report::{DefaultStringReporter, DerivationTree, Reporter};\n@@ -167,6 +168,7 @@ impl NoSolutionError {\n     pub(crate) fn with_available_versions(\n         mut self,\n         python_requirement: &PythonRequirement,\n+        visited: &DashSet<PackageName>,\n         package_versions: &OnceMap<PackageName, VersionMap>,\n     ) -> Self {\n         let mut available_versions = IndexMap::default();\n@@ -186,15 +188,21 @@ impl NoSolutionError {\n                     );\n                 }\n                 PubGrubPackage::Package(name, ..) => {\n-                    if let Some(entry) = package_versions.get(name) {\n-                        let version_map = entry.value();\n-                        available_versions.insert(\n-                            package.clone(),\n-                            version_map\n-                                .iter()\n-                                .map(|(version, _)| version.clone())\n-                                .collect(),\n-                        );\n+                    // Avoid including available versions for packages that exist in the derivation\n+                    // tree, but were never visited during resolution. We _may_ have metadata for\n+                    // these packages, but it's non-deterministic, and omitting them ensures that\n+                    // we represent the state of the resolver at the time of failure.\n+                    if visited.contains(name) {\n+                        if let Some(entry) = package_versions.get(name) {\n+                            let version_map = entry.value();\n+                            available_versions.insert(\n+                                package.clone(),\n+                                version_map\n+                                    .iter()\n+                                    .map(|(version, _)| version.clone())\n+                                    .collect(),\n+                            );\n+                        }\n                     }\n                 }\n             }"
    },
    {
      "filename": "crates/puffin-resolver/src/resolver/mod.rs",
      "status": "modified",
      "patch": "@@ -3,7 +3,7 @@\n use std::sync::Arc;\n \n use anyhow::Result;\n-use dashmap::DashMap;\n+use dashmap::{DashMap, DashSet};\n use futures::channel::mpsc::UnboundedReceiver;\n use futures::{pin_mut, FutureExt, StreamExt};\n use itertools::Itertools;\n@@ -68,6 +68,8 @@ pub struct Resolver<'a, Provider: ResolverProvider> {\n     index: &'a InMemoryIndex,\n     /// A map from [`PackageId`] to the `Requires-Python` version specifiers for that package.\n     incompatibilities: DashMap<PackageId, VersionSpecifiers>,\n+    /// The set of all registry-based packages visited during resolution.\n+    visited: DashSet<PackageName>,\n     editables: FxHashMap<PackageName, (LocalEditable, Metadata21)>,\n     reporter: Option<Arc<dyn Reporter>>,\n     provider: Provider,\n@@ -167,6 +169,7 @@ impl<'a, Provider: ResolverProvider> Resolver<'a, Provider> {\n         Self {\n             index,\n             incompatibilities: DashMap::default(),\n+            visited: DashSet::default(),\n             selector,\n             allowed_urls,\n             project: manifest.project,\n@@ -223,7 +226,7 @@ impl<'a, Provider: ResolverProvider> Resolver<'a, Provider> {\n                     if let ResolveError::NoSolution(err) = err {\n                         ResolveError::NoSolution(\n                             err\n-                            .with_available_versions(&self.python_requirement, &self.index.packages)\n+                            .with_available_versions(&self.python_requirement, &self.visited, &self.index.packages)\n                             .with_selector(self.selector.clone())\n                             .with_python_requirement(&self.python_requirement)\n                         )\n@@ -504,6 +507,7 @@ impl<'a, Provider: ResolverProvider> Resolver<'a, Provider> {\n                 // Wait for the metadata to be available.\n                 let entry = self.index.packages.wait(package_name).await?;\n                 let version_map = entry.value();\n+                self.visited.insert(package_name.clone());\n \n                 if let Some(extra) = extra {\n                     debug!("
    },
    {
      "filename": "crates/puffin/tests/pip_install_scenarios.rs",
      "status": "modified",
      "patch": "@@ -566,8 +566,8 @@ fn dependency_excludes_range_of_compatible_versions() -> Result<()> {\n \n               Because only albatross<=3.0.0 is available and albatross==3.0.0 depends on bluebird==3.0.0, we can conclude that albatross>=3.0.0 depends on bluebird==3.0.0.\n               And because we know from (2) that all versions of crow, bluebird!=1.0.0, albatross<3.0.0 are incompatible, we can conclude that all versions of crow depend on one of:\n-                  bluebird<=1.0.0\n-                  bluebird>=3.0.0\n+                  bluebird==1.0.0\n+                  bluebird==3.0.0\n \n               And because you require crow and you require bluebird>=2.0.0,<3.0.0, we can conclude that the requirements are unsatisfiable.\n         \"###);\n@@ -697,8 +697,8 @@ fn dependency_excludes_non_contiguous_range_of_compatible_versions() -> Result<(\n \n               Because only albatross<=3.0.0 is available and albatross==3.0.0 depends on bluebird==3.0.0, we can conclude that albatross>=3.0.0 depends on bluebird==3.0.0.\n               And because we know from (2) that all versions of crow, bluebird!=1.0.0, albatross<3.0.0 are incompatible, we can conclude that all versions of crow depend on one of:\n-                  bluebird<=1.0.0\n-                  bluebird>=3.0.0\n+                  bluebird==1.0.0\n+                  bluebird==3.0.0\n \n               And because you require crow and you require bluebird>=2.0.0,<3.0.0, we can conclude that the requirements are unsatisfiable.\n         \"###);"
    }
  ],
  "fix_category": "Remove dependency",
  "root_cause_category": "Network",
  "root_cause_subcategory": NaN
}