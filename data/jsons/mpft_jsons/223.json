{
  "id": 223,
  "repo": "spark",
  "issue_url": "https://github.com/apache/spark/commit/11fff05032ecaec8024c9fb0c83e3e3229d2f9e7",
  "pr_url": "https://github.com/apache/spark/commit/11fff05032ecaec8024c9fb0c83e3e3229d2f9e7",
  "issue_description": "Thanks for Diana Carroll to report this issue (https://spark-project.atlassian.net/browse/SPARK-1100)\n\nthe current saveAsTextFile/SequenceFile will overwrite the output directory silently if the directory already exists, this behaviour is not desirable because\n\noverwriting the data silently is not user-friendly\n\nif the partition number of two writing operation changed, then the output directory will contain the results generated by two runnings\n\nMy fix includes:\n\nadd some new APIs with a flag for users to define whether he/she wants to overwrite the directory:\nif the flag is set to true, then the output directory is deleted first and then written into the new data to prevent the output directory contains results from multiple rounds of running;\n\nif the flag is set to false, Spark will throw an exception if the output directory already exists\n\nchanged JavaAPI part\n\ndefault behaviour is overwriting\n\nTwo questions\n\nshould we deprecate the old APIs without such a flag?\n\nI noticed that Spark Streaming also called these APIs, I thought we don't need to change the related part in streaming? @tdas\n",
  "files_changed": [
    {
      "filename": "core/src/main/scala/org/apache/spark/rdd/PairRDDFunctions.scala",
      "status": "modified",
      "patch": "@@ -30,18 +30,15 @@ import scala.reflect.ClassTag\n \n import com.clearspring.analytics.stream.cardinality.HyperLogLog\n import org.apache.hadoop.conf.{Configurable, Configuration}\n-import org.apache.hadoop.fs.Path\n+import org.apache.hadoop.fs.{FileSystem, Path}\n import org.apache.hadoop.io.SequenceFile.CompressionType\n import org.apache.hadoop.io.compress.CompressionCodec\n import org.apache.hadoop.mapred.{FileOutputCommitter, FileOutputFormat, JobConf, OutputFormat}\n-import org.apache.hadoop.mapreduce.{OutputFormat => NewOutputFormat}\n-import org.apache.hadoop.mapreduce.{Job => NewAPIHadoopJob}\n-import org.apache.hadoop.mapreduce.{RecordWriter => NewRecordWriter}\n+import org.apache.hadoop.mapreduce.{OutputFormat => NewOutputFormat, Job => NewAPIHadoopJob, RecordWriter => NewRecordWriter, JobContext, SparkHadoopMapReduceUtil}\n import org.apache.hadoop.mapreduce.lib.output.{FileOutputFormat => NewFileOutputFormat}\n \n // SparkHadoopWriter and SparkHadoopMapReduceUtil are actually source files defined in Spark.\n import org.apache.hadoop.mapred.SparkHadoopWriter\n-import org.apache.hadoop.mapreduce.SparkHadoopMapReduceUtil\n \n import org.apache.spark._\n import org.apache.spark.Partitioner.defaultPartitioner\n@@ -604,8 +601,12 @@ class PairRDDFunctions[K: ClassTag, V: ClassTag](self: RDD[(K, V)])\n     val job = new NewAPIHadoopJob(conf)\n     job.setOutputKeyClass(keyClass)\n     job.setOutputValueClass(valueClass)\n+\n     val wrappedConf = new SerializableWritable(job.getConfiguration)\n-    NewFileOutputFormat.setOutputPath(job, new Path(path))\n+    val outpath = new Path(path)\n+    NewFileOutputFormat.setOutputPath(job, outpath)\n+    val jobFormat = outputFormatClass.newInstance\n+    jobFormat.checkOutputSpecs(job)\n     val formatter = new SimpleDateFormat(\"yyyyMMddHHmm\")\n     val jobtrackerID = formatter.format(new Date())\n     val stageId = self.id\n@@ -633,7 +634,7 @@ class PairRDDFunctions[K: ClassTag, V: ClassTag](self: RDD[(K, V)])\n       committer.commitTask(hadoopContext)\n       return 1\n     }\n-    val jobFormat = outputFormatClass.newInstance\n+\n     /* apparently we need a TaskAttemptID to construct an OutputCommitter;\n      * however we're only going to use this local OutputCommitter for\n      * setupJob/commitJob, so we just use a dummy \"map\" task.\n@@ -642,7 +643,7 @@ class PairRDDFunctions[K: ClassTag, V: ClassTag](self: RDD[(K, V)])\n     val jobTaskContext = newTaskAttemptContext(wrappedConf.value, jobAttemptId)\n     val jobCommitter = jobFormat.getOutputCommitter(jobTaskContext)\n     jobCommitter.setupJob(jobTaskContext)\n-    val count = self.context.runJob(self, writeShard _).sum\n+    self.context.runJob(self, writeShard _)\n     jobCommitter.commitJob(jobTaskContext)\n   }\n \n@@ -696,10 +697,10 @@ class PairRDDFunctions[K: ClassTag, V: ClassTag](self: RDD[(K, V)])\n    * MapReduce job.\n    */\n   def saveAsHadoopDataset(conf: JobConf) {\n-    val outputFormatClass = conf.getOutputFormat\n+    val outputFormatInstance = conf.getOutputFormat\n     val keyClass = conf.getOutputKeyClass\n     val valueClass = conf.getOutputValueClass\n-    if (outputFormatClass == null) {\n+    if (outputFormatInstance == null) {\n       throw new SparkException(\"Output format class not set\")\n     }\n     if (keyClass == null) {\n@@ -712,6 +713,12 @@ class PairRDDFunctions[K: ClassTag, V: ClassTag](self: RDD[(K, V)])\n     logDebug(\"Saving as hadoop file of type (\" + keyClass.getSimpleName + \", \" +\n       valueClass.getSimpleName + \")\")\n \n+    if (outputFormatInstance.isInstanceOf[FileOutputFormat[_, _]]) {\n+      // FileOutputFormat ignores the filesystem parameter\n+      val ignoredFs = FileSystem.get(conf)\n+      conf.getOutputFormat.checkOutputSpecs(ignoredFs, conf)\n+    }\n+\n     val writer = new SparkHadoopWriter(conf)\n     writer.preSetup()\n "
    },
    {
      "filename": "core/src/test/scala/org/apache/spark/FileSuite.scala",
      "status": "modified",
      "patch": "@@ -24,9 +24,11 @@ import scala.io.Source\n import com.google.common.io.Files\n import org.apache.hadoop.io._\n import org.apache.hadoop.io.compress.DefaultCodec\n+import org.apache.hadoop.mapred.FileAlreadyExistsException\n import org.scalatest.FunSuite\n \n import org.apache.spark.SparkContext._\n+import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat\n \n class FileSuite extends FunSuite with LocalSparkContext {\n \n@@ -208,4 +210,44 @@ class FileSuite extends FunSuite with LocalSparkContext {\n     assert(rdd.count() === 3)\n     assert(rdd.count() === 3)\n   }\n+\n+  test (\"prevent user from overwriting the empty directory (old Hadoop API)\") {\n+    sc = new SparkContext(\"local\", \"test\")\n+    val tempdir = Files.createTempDir()\n+    val randomRDD = sc.parallelize(Array((1, \"a\"), (1, \"a\"), (2, \"b\"), (3, \"c\")), 1)\n+    intercept[FileAlreadyExistsException] {\n+      randomRDD.saveAsTextFile(tempdir.getPath)\n+    }\n+  }\n+\n+  test (\"prevent user from overwriting the non-empty directory (old Hadoop API)\") {\n+    sc = new SparkContext(\"local\", \"test\")\n+    val tempdir = Files.createTempDir()\n+    val randomRDD = sc.parallelize(Array((1, \"a\"), (1, \"a\"), (2, \"b\"), (3, \"c\")), 1)\n+    randomRDD.saveAsTextFile(tempdir.getPath + \"/output\")\n+    assert(new File(tempdir.getPath + \"/output/part-00000\").exists() === true)\n+    intercept[FileAlreadyExistsException] {\n+      randomRDD.saveAsTextFile(tempdir.getPath + \"/output\")\n+    }\n+  }\n+\n+  test (\"prevent user from overwriting the empty directory (new Hadoop API)\") {\n+    sc = new SparkContext(\"local\", \"test\")\n+    val tempdir = Files.createTempDir()\n+    val randomRDD = sc.parallelize(Array((\"key1\", \"a\"), (\"key2\", \"a\"), (\"key3\", \"b\"), (\"key4\", \"c\")), 1)\n+    intercept[FileAlreadyExistsException] {\n+      randomRDD.saveAsNewAPIHadoopFile[TextOutputFormat[String, String]](tempdir.getPath)\n+    }\n+  }\n+\n+  test (\"prevent user from overwriting the non-empty directory (new Hadoop API)\") {\n+    sc = new SparkContext(\"local\", \"test\")\n+    val tempdir = Files.createTempDir()\n+    val randomRDD = sc.parallelize(Array((\"key1\", \"a\"), (\"key2\", \"a\"), (\"key3\", \"b\"), (\"key4\", \"c\")), 1)\n+    randomRDD.saveAsTextFile(tempdir.getPath + \"/output\")\n+    assert(new File(tempdir.getPath + \"/output/part-00000\").exists() === true)\n+    intercept[FileAlreadyExistsException] {\n+      randomRDD.saveAsNewAPIHadoopFile[TextOutputFormat[String, String]](tempdir.getPath)\n+    }\n+  }\n }"
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}