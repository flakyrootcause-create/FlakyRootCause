{
  "id": 106,
  "repo": "arrow-rs",
  "issue_url": "https://github.com/apache/arrow-rs/pull/5645",
  "pr_url": "https://github.com/apache/arrow-rs/pull/5645",
  "issue_description": "# Which issue does this PR close?\r\n\r\n<!--\r\nWe generally require a GitHub issue to be filed for all bug fixes and enhancements and this helps us generate change logs for our releases. You can link an issue to this PR using the GitHub syntax. For example `Closes #123` indicates that this PR will close issue #123.\r\n-->\r\n\r\nCloses #.\r\n\r\n# Rationale for this change\r\n \r\n<!--\r\nWhy are you proposing this change? If this is already explained clearly in the issue then this section is not needed.\r\nExplaining clearly why changes are proposed helps reviewers understand your changes and offer better suggestions for fixes.\r\n-->\r\n\r\nWe occasionally see this test fail as it takes more than a millisecond on very contended CI runners for the asynchronous cleanup to be performed - https://github.com/apache/arrow-rs/actions/runs/8690327829/job/23830012773\r\n\r\n# What changes are included in this PR?\r\n\r\n<!--\r\nThere is no need to duplicate the description in the issue here but it is sometimes worth providing a summary of the individual changes in this PR.\r\n-->\r\n\r\n# Are there any user-facing changes?\r\n\r\n\r\n<!--\r\nIf there are user-facing changes then we may require documentation to be updated before approving the PR.\r\n-->\r\n\r\n<!---\r\nIf there are any breaking changes to public APIs, please add the `breaking change` label.\r\n-->\r\n",
  "files_changed": [
    {
      "filename": "object_store/src/local.rs",
      "status": "modified",
      "patch": "@@ -1450,10 +1450,14 @@ mod not_wasm_tests {\n         assert_eq!(file_count, 1);\n         drop(upload);\n \n-        tokio::time::sleep(Duration::from_millis(1)).await;\n-\n-        let file_count = std::fs::read_dir(root.path()).unwrap().count();\n-        assert_eq!(file_count, 0);\n+        for _ in 0..100 {\n+            tokio::time::sleep(Duration::from_millis(1)).await;\n+            let file_count = std::fs::read_dir(root.path()).unwrap().count();\n+            if file_count == 0 {\n+                return;\n+            }\n+        }\n+        panic!(\"Failed to cleanup file in 100ms\")\n     }\n }\n "
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}