{
  "id": 206,
  "repo": "prout",
  "issue_url": "https://github.com/guardian/prout/pull/146",
  "pr_url": "https://github.com/guardian/prout/pull/146",
  "issue_description": "Fixes #145 -  the issue was caused by the slightly variable results returned by the GitHub API.\r\n\r\nIn all the tests in `FunctionalSpec`, we create several test fixtures with the GitHub API, each created to be used once and thrown away:\r\n\r\n* A brand-new GitHub repository, populated with whatever Git history we require\r\n* A brand new PR in the repository, which we also merge\r\n\r\nBefore continuing on to the next step, which would be having Prout scan the repo for recently-merged PRs, we perform several checks to ensure that the GitHub API confirms the status of the merged PR:\r\n\r\nhttps://github.com/guardian/prout/blob/a710e347afb94ca719e11b9c5b6b3312f1245e98/test/lib/Helpers.scala#L180-L195\r\n\r\nHowever, looking a the differing logs produced by the failure & success cases in #145, it became apparent that even though we've checked the GitHub API.",
  "files_changed": [
    {
      "filename": ".github/workflows/ci.yml",
      "status": "modified",
      "patch": "@@ -14,7 +14,7 @@ jobs:\n     runs-on: ubuntu-latest\n     steps:\n       - name: Checkout\n-        uses: actions/checkout@v3\n+        uses: actions/checkout@v5\n       - uses: guardian/setup-scala@v1\n       - name: Build and Test\n         env:"
    },
    {
      "filename": "app/controllers/Api.scala",
      "status": "modified",
      "patch": "@@ -16,12 +16,16 @@\n \n package controllers\n \n+import cats._\n+import cats.data._\n+import cats.syntax.all._\n+import cats.effect.IO\n import com.github.blemale.scaffeine.{LoadingCache, Scaffeine}\n import com.madgag.scalagithub.model.RepoId\n-import lib._\n+import lib.*\n import lib.actions.Parsers.parseGitHubHookJson\n import play.api.libs.json.{JsArray, JsNumber}\n-import play.api.mvc._\n+import play.api.mvc.*\n \n import scala.concurrent.Future\n \n@@ -50,7 +54,7 @@ class Api(\n \n   def xRequestId(implicit request: RequestHeader): Option[String] = request.headers.get(\"X-Request-ID\")\n \n-  def updateForRepo(repoId: RepoId): Future[Result] = {\n+  def updateForRepo(repoId: RepoId): IO[Result] = {\n     logger.debug(s\"update requested for $repoId\")\n     for {\n       acceptList <- repoAcceptListService.acceptList()\n@@ -63,8 +67,8 @@ class Api(\n     .maximumSize(500)\n     .build(scanSchedulerFactory.createFor)\n \n-  def updateFor(repoId: RepoId, acceptList: RepoAcceptList): Future[Result] = {\n-    val scanGuardF = Future { // wrapped in a future to avoid timing attacks\n+  def updateFor(repoId: RepoId, acceptList: RepoAcceptList): IO[Result] = {\n+    val scanGuardF: IO[Seq[PullRequestCheckpointsStateChangeSummary]] = IO.delay { // wrapped in a future to avoid timing attacks\n       val knownRepo = acceptList.allKnownRepos(repoId)\n       logger.info(s\"$repoId known=$knownRepo\")\n       require(knownRepo, s\"${repoId.fullName} not on known-repo whitelist\")\n@@ -88,12 +92,11 @@ class Api(\n     val mightBePrivate = !acceptList.publicRepos(repoId)\n     if (mightBePrivate) {\n       // Response must be immediate, with no private information (e.g. even acknowledging that repo exists)\n-      Future.successful(NoContent)\n+      IO.pure(NoContent)\n     } else {\n       // we can delay the response to return information about the repo config, and the updates generated\n       for {\n-        scanGuard <- scanGuardF\n-        scan <- scanGuard\n+        scan <- scanGuardF\n       } yield Ok(JsArray(scan.map(summary => JsNumber(summary.prCheckpointDetails.pr.number))))\n     }\n   }"
    },
    {
      "filename": "app/controllers/Application.scala",
      "status": "modified",
      "patch": "@@ -20,8 +20,10 @@ import org.apache.pekko.actor.ActorSystem\n import com.madgag.scalagithub.model.RepoId\n import lib.{Bot, RepoSnapshot}\n import play.api.Logging\n+import play.api.mvc.{Action, AnyContent}\n \n import scala.concurrent.ExecutionContext\n+import cats.effect.unsafe.implicits.global\n \n class Application(\n   repoAcceptListService: RepoAcceptListService,\n@@ -33,19 +35,20 @@ class Application(\n   bot: Bot\n ) extends AbstractAppController(cc) with Logging {\n \n-  def index = Action { implicit req =>\n+  def index: Action[AnyContent] = Action { implicit req =>\n     Ok(views.html.userPages.index())\n   }\n \n   def configDiagnostic(repoId: RepoId) = repoAuthenticated(repoId).async { implicit req =>\n-    for {\n+    (for {\n       repoFetchedByProut <- bot.github.getRepo(repoId)\n-      proutPresenceQuickCheck <- repoAcceptListService.hasProutConfigFile(repoFetchedByProut)\n-      repoSnapshot <- repoSnapshotFactory.snapshot(repoFetchedByProut.repoId)\n+      repo = repoFetchedByProut.result\n+      proutPresenceQuickCheck <- repoAcceptListService.hasProutConfigFile(repo)\n+      repoSnapshot <- repoSnapshotFactory.snapshot(repo)\n       diagnostic <- repoSnapshot.diagnostic()\n     } yield {\n       Ok(views.html.userPages.repo(proutPresenceQuickCheck, repoSnapshot, diagnostic, sentryApiClientOpt))\n-    }\n+    }).unsafeToFuture()\n   }\n \n }"
    },
    {
      "filename": "app/controllers/RepoAcceptListService.scala",
      "status": "modified",
      "patch": "@@ -1,16 +1,21 @@\n package controllers\n \n+import cats._\n+import cats.data._\n+import cats.syntax.all._\n+import cats.effect.IO\n import org.apache.pekko.actor.ActorSystem\n-import com.madgag.github.Implicits._\n+import com.madgag.github.Implicits.*\n import com.madgag.scalagithub.GitHub\n import com.madgag.scalagithub.model.{Repo, RepoId}\n import com.typesafe.scalalogging.LazyLogging\n+import fs2.Chunk\n import lib.ConfigFinder.ProutConfigFileName\n \n import java.util.concurrent.atomic.AtomicReference\n import scala.concurrent.ExecutionContext.Implicits.global\n import scala.concurrent.Future\n-import scala.concurrent.duration._\n+import scala.concurrent.duration.*\n \n case class RepoAcceptList(allKnownRepos: Set[RepoId], publicRepos: Set[RepoId])\n \n@@ -19,19 +24,19 @@ class RepoAcceptListService()(implicit\n   actorSystem: ActorSystem\n ) extends LazyLogging {\n \n-  lazy val repoAcceptList = new AtomicReference[Future[RepoAcceptList]](getAllKnownRepos)\n+  lazy val repoAcceptList = new AtomicReference[IO[RepoAcceptList]](getAllKnownRepos)\n \n-  def acceptList(): Future[RepoAcceptList] = repoAcceptList.get()\n+  def acceptList(): IO[RepoAcceptList] = repoAcceptList.get()\n \n-  def hasProutConfigFile(repo: Repo): Future[Boolean] = for {\n+  def hasProutConfigFile(repo: Repo): IO[Boolean] = for {\n     treeT <- repo.trees2.getRecursively(s\"heads/${repo.default_branch}\").trying\n   } yield treeT.map(_.tree.exists(_.path.endsWith(ProutConfigFileName))).getOrElse(false)\n \n-  private def getAllKnownRepos: Future[RepoAcceptList] = for { // check this to see if it always expends quota...\n-    allRepos <- github.listReposAccessibleToTheApp.allItems()\n-    proutRepos <- Future.traverse(allRepos.flatMap(repos => repos.repositories)){ repo =>\n-      hasProutConfigFile(repo).map(hasConfig => Option.when(hasConfig)(repo))\n-    }.map(_.flatten.toSet)\n+  private def getAllKnownRepos: IO[RepoAcceptList] = for { // check this to see if it always expends quota...\n+    proutRepos <- github.listReposAccessibleToTheApp()\n+      .mapChunks(_.flatMap(repos => Chunk.from(repos.repositories)))\n+      .evalFilterAsync(4)(hasProutConfigFile)\n+      .compile.to(Set)\n   } yield RepoAcceptList(proutRepos.map(_.repoId), proutRepos.filterNot(_.`private`).map(_.repoId))\n \n "
    },
    {
      "filename": "app/lib/Bot.scala",
      "status": "modified",
      "patch": "@@ -2,7 +2,7 @@ package lib\n \n import com.madgag.github.apps.GitHubAppAuth\n import com.madgag.scalagithub.model.Account\n-import com.madgag.scalagithub.{GitHub, GitHubCredentials}\n+import com.madgag.scalagithub.{AccountAccess, GitHub, GitHubCredentials}\n import play.api.Logging\n \n import java.nio.file.Path\n@@ -14,10 +14,10 @@ case class Identity(login: String, html_url: String) {\n \n case class Bot(\n   workingDir: Path,\n-  gitHubCredsProvider: GitHubCredentials.Provider,\n+  accountAccess: AccountAccess,\n   identity: Identity\n ) {\n-  val github = new GitHub(gitHubCredsProvider)\n+  val github = accountAccess.gitHub\n }\n \n object Bot extends Logging {\n@@ -32,7 +32,7 @@ object Bot extends Logging {\n       installationAccess <- githubAppAuth.accessSoleInstallation()\n     } yield Bot(\n       workingDir,\n-      installationAccess.credentials,\n+      installationAccess.accountAccess(),\n       Identity(app.slug, app.html_url)\n     )\n     ).recover { case ex =>"
    },
    {
      "filename": "app/lib/CheckpointSnapshot.scala",
      "status": "modified",
      "patch": "@@ -32,7 +32,7 @@ import scala.util.Try\n import scala.util.matching.Regex\n \n trait CheckpointSnapshoter {\n-  def snapshot(checkpoint: Checkpoint): Future[Iterator[AbbreviatedObjectId]]\n+  def snapshot(checkpoint: Checkpoint): IO[Iterator[AbbreviatedObjectId]]\n }\n \n object CheckpointSnapshoter extends CheckpointSnapshoter {\n@@ -44,7 +44,7 @@ object CheckpointSnapshoter extends CheckpointSnapshoter {\n \n   val hexRegex: Regex = \"\"\"\\b\\p{XDigit}{40}\\b\"\"\".r\n \n-  def snapshot(checkpoint: Checkpoint): Future[Iterator[AbbreviatedObjectId]] = {\n+  def snapshot(checkpoint: Checkpoint): IO[Iterator[AbbreviatedObjectId]] = {\n \n     val clientForCheckpoint = if (checkpoint.sslVerification) client else insecureClient\n "
    },
    {
      "filename": "app/lib/Droid.scala",
      "status": "modified",
      "patch": "@@ -1,11 +1,15 @@\n package lib\n \n-import org.apache.pekko.stream.Materializer\n-import com.madgag.git._\n+import cats.*\n+import cats.data.*\n+import cats.effect.IO\n+import cats.syntax.all.*\n+import com.madgag.git.*\n import com.madgag.scalagithub.GitHub\n import com.madgag.scalagithub.model.RepoId\n import lib.sentry.SentryApiClient\n import org.apache.pekko.actor.ActorSystem\n+import org.apache.pekko.stream.Materializer\n import play.api.Logger\n \n import scala.concurrent.ExecutionContext.Implicits.global\n@@ -36,9 +40,10 @@ class Droid(\n     }\n   }\n \n-  def processMergedPullRequestsOn(repoSnapshot: RepoSnapshot): Future[Seq[PullRequestCheckpointsStateChangeSummary]] = for {\n+  def processMergedPullRequestsOn(repoSnapshot: RepoSnapshot): IO[Seq[PullRequestCheckpointsStateChangeSummary]] = for {\n     _ <- repoUpdater.attemptToCreateMissingLabels(repoSnapshot.repoLevelDetails)\n-    summaryOpts <- Future.traverse(repoSnapshot.mergedPullRequestSnapshots)(prSnapshot => prUpdater.process(prSnapshot, repoSnapshot))\n+    summaryOpts <-\n+      repoSnapshot.mergedPullRequestSnapshots.parUnorderedTraverse(prSnapshot => prUpdater.process(prSnapshot, repoSnapshot))\n   } yield summaryOpts.flatten\n \n "
    },
    {
      "filename": "app/lib/EverythingYouWantToKnowAboutACheckpoint.scala",
      "status": "modified",
      "patch": "@@ -12,7 +12,8 @@ object EverythingYouWantToKnowAboutACheckpoint extends Logging {\n     val timeBetweenMergeAndSnapshot = java.time.Duration.between(pr.merged_at.get.toInstant, snapshot.time)\n \n     def prCommitsSeenAndNotSeen(siteCommitId: ObjectId): PRCommitVisibility = {\n-      implicit val repoThreadLocal = gitRepo.getObjectDatabase.threadLocalResources\n+      implicit val repoThreadLocal: ThreadLocalObjectDatabaseResources =\n+        gitRepo.getObjectDatabase.threadLocalResources\n       implicit val w: RevWalk = new RevWalk(repoThreadLocal.reader())\n       val siteCommit = siteCommitId.asRevCommit\n "
    },
    {
      "filename": "app/lib/PRUpdater.scala",
      "status": "modified",
      "patch": "@@ -1,15 +1,13 @@\n package lib\n \n-import org.apache.pekko.stream.Materializer\n import com.madgag.scalagithub.GitHub\n import com.madgag.scalagithub.commands.CreateComment\n-import com.madgag.scalagithub.model.{PullRequest, Repo}\n+import com.madgag.scalagithub.model.PullRequest\n import com.madgag.time.Implicits._\n import com.typesafe.scalalogging.LazyLogging\n import lib.Config.CheckpointMessages\n import lib.RepoSnapshot.WorthyOfCommentWindow\n import lib.Responsibility.responsibilityAndRecencyFor\n-import lib.gitgithub.LabelMapping\n import lib.labels.{Overdue, PullRequestCheckpointStatus, Seen}\n import lib.sentry.{PRSentryRelease, SentryApiClient}\n \n@@ -21,19 +19,18 @@ class PRUpdater(delayer: Delayer) extends LazyLogging {\n \n   def process(prSnapshot: PRSnapshot, repoSnapshot: RepoSnapshot)(implicit\n     g: GitHub,\n-    m: Materializer,\n     sentryApiClientOpt: Option[SentryApiClient]\n-  ): Future[Option[PullRequestCheckpointsStateChangeSummary]] = {\n+  ): IO[Option[PullRequestCheckpointsStateChangeSummary]] = {\n     logger.trace(s\"handling ${prSnapshot.pr.prId.slug}\")\n     for {\n       snapshot <- getSummaryOfCheckpointChangesGiven(prSnapshot, repoSnapshot)\n     } yield snapshot\n   }\n \n-  private def getSummaryOfCheckpointChangesGiven(prSnapshot: PRSnapshot, repoSnapshot: RepoSnapshot)(implicit\n+  private def getSummaryOfCheckpointChangesGiven(prSnapshot: PRSnapshot, repoSnapshot: RepoSnapshot)(using\n     gitHub: GitHub,\n     sentryApiClientOpt: Option[SentryApiClient]\n-  ): Future[Option[PullRequestCheckpointsStateChangeSummary]] = {\n+  ): IO[Option[PullRequestCheckpointsStateChangeSummary]] = {\n     val pr = prSnapshot.pr\n     val (oldStateLabelsSeq, userLabels) = prSnapshot.labels.map(_.name).partition(repoSnapshot.allPossibleCheckpointPRLabels)\n     val oldLabels = oldStateLabelsSeq.toSet"
    },
    {
      "filename": "app/lib/PullRequestCheckpointsStateChangeSummary.scala",
      "status": "modified",
      "patch": "@@ -63,7 +63,7 @@ case class PRCheckpointDetails(\n     everythingByCheckpoint.values.groupBy(_.checkpointStatus).mapV(_.map(_.snapshot.checkpoint).toSet)\n \n   val soonestPendingCheckpointOverdueTime: Option[java.time.Instant] = {\n-    implicit val periodOrdering = Ordering.by[Period, Duration](_.toStandardDuration)\n+    implicit val periodOrdering: Ordering[Period] = Ordering.by[Period, Duration](_.toStandardDuration)\n \n     checkpointsByState.get(Pending).map(_.flatMap(_.details.overdueInstantFor(pr)).min)\n   }"
    },
    {
      "filename": "app/lib/RepoSnapshot.scala",
      "status": "modified",
      "patch": "@@ -16,26 +16,30 @@\n \n package lib\n \n-import com.madgag.git._\n-import com.madgag.github.Implicits._\n-import com.madgag.scala.collection.decorators._\n+import cats.*\n+import cats.data.*\n+import cats.effect.IO\n+import cats.syntax.all.*\n+import com.madgag.git.*\n+import com.madgag.github.Implicits.*\n+import com.madgag.scala.collection.decorators.*\n import com.madgag.scalagithub.GitHub\n-import com.madgag.scalagithub.GitHub._\n+import com.madgag.scalagithub.GitHub.*\n import com.madgag.scalagithub.model.{PullRequest, Repo, RepoId}\n-import com.madgag.time.Implicits._\n+import com.madgag.time.Implicits.*\n import io.lemonlabs.uri.Url\n import lib.Config.Checkpoint\n import lib.gitgithub.LabelMapping\n-import lib.labels._\n+import lib.labels.*\n import org.apache.pekko.actor.ActorSystem\n import org.eclipse.jgit.lib.{ObjectId, Repository}\n import org.eclipse.jgit.revwalk.{RevCommit, RevWalk}\n import play.api.Logging\n \n import java.time.ZonedDateTime\n+import scala.concurrent.*\n import scala.concurrent.ExecutionContext.Implicits.global\n-import scala.concurrent._\n-import scala.concurrent.duration._\n+import scala.concurrent.duration.*\n import scala.util.Success\n \n object RepoSnapshot {\n@@ -67,14 +71,14 @@ object RepoSnapshot {\n     }\n \n     def isMergedToMain(pr: PullRequest)(implicit repo: Repo): Boolean =\n-      pr.merged_at.isDefined && pr.base.ref == repo.default_branch\n+      pr.merged_at.isDefined\n \n     def snapshot(repoId: RepoId): Future[RepoSnapshot] = for {\n       githubRepo <- github.getRepo(repoId)\n       repoSnapshot <- snapshot(githubRepo)\n     } yield repoSnapshot\n \n-    def snapshot(implicit githubRepo: Repo): Future[RepoSnapshot] = {\n+    def snapshot(implicit githubRepo: Repo): IO[RepoSnapshot] = {\n       val mergedPullRequestsF = logAround(\"fetch PRs\")(fetchMergedPullRequests())\n       val hooksF = logAround(\"fetch repo hooks\")(fetchRepoHooks())\n       val gitRepoF = logAround(\"fetch git repo\")(fetchLatestCopyOfGitRepo())\n@@ -89,31 +93,38 @@ object RepoSnapshot {\n       )\n     }\n \n-    def prSnapshot(prNumber: Int)(implicit repo: Repo): Future[PRSnapshot] = for {\n+    def prSnapshot(prNumber: Int)(implicit repo: Repo): IO[PRSnapshot] = for {\n       prResponse <- repo.pullRequests.get(prNumber)\n       pr = prResponse.result\n-      labelsResponse <- pr.labels.list().all()\n+      labelsResponse <- pr.labels.list().compile.toList\n     } yield PRSnapshot(pr, labelsResponse)\n \n     def fetchMergedPullRequests()(implicit repo: Repo): Future[Seq[PRSnapshot]] = {\n       val now = ZonedDateTime.now()\n       val timeThresholdForScan = now.minus(WorthyOfScanWindow)\n+      val criteriaForClosedPrsBasedOnTheDefaultBranch: Map[String, String] =\n+        ClosedPRsMostlyRecentlyUpdated + (\"base\" -> repo.default_branch)\n \n-      def isNewEnoughToBeWorthScanning(pr: PullRequest) = pr.merged_at.exists(_.isAfter(timeThresholdForScan))\n+      def isMergedRecentlyEnoughToBeWorthScanning(pr: PullRequest) =\n+        pr.merged_at.exists(_.isAfter(timeThresholdForScan))\n \n       (for {\n-        litePullRequests: Seq[PullRequest] <-\n-          repo.pullRequests.list(ClosedPRsMostlyRecentlyUpdated).take(2).all(): Future[Seq[PullRequest]]\n-        pullRequests <-\n-          Future.traverse(litePullRequests.filter(isMergedToMain).filter(isNewEnoughToBeWorthScanning).take(MaxPRsToScanPerRepo))(pr => prSnapshot(pr.number))\n+        pullRequests: Seq[PullRequest] <-\n+          repo.pullRequests.list(criteriaForClosedPrsBasedOnTheDefaultBranch)\n+            .takeWhile(_.updated_at >= timeThresholdForScan)\n+            .filter(isMergedRecentlyEnoughToBeWorthScanning)\n+            .take(MaxPRsToScanPerRepo)\n+            .parEvalMapUnordered(4) {\n+              pr => prSnapshot(pr.number)\n+            }.compile.toList\n       } yield {\n         log(s\"PRs merged to master size=${pullRequests.size}\")\n         pullRequests\n       }) andThen { case cprs => log(s\"Merged Pull Requests fetched: ${cprs.map(_.map(_.pr.number).sorted.reverse)}\") }\n     }\n \n     private def fetchLatestCopyOfGitRepo()(implicit githubRepo: Repo): Future[Repository] = (for {\n-      creds <- bot.gitHubCredsProvider()\n+      creds <- bot.accountAccess.credentials()\n     } yield {\n         val repoId = githubRepo.repoId\n         RepoUtil.getGitRepo(\n@@ -122,10 +133,11 @@ object RepoSnapshot {\n           Some(creds.git))\n     }) andThen { case r => log(s\"Git Repo ref count: ${r.map(_.getRefDatabase.getRefs.size)}\") }\n \n-    private def fetchRepoHooks()(implicit githubRepo: Repo) = if (githubRepo.permissions.exists(_.admin)) githubRepo.hooks.list().map(_.flatMap(_.config.get(\"url\").map(Url.parse))).all() else {\n-      log(s\"No admin rights to check hooks\")\n-      Future.successful(Seq.empty)\n-    }\n+    private def fetchRepoHooks()(using githubRepo: Repo) = \n+      if (githubRepo.permissions.exists(_.admin)) githubRepo.hooks.list().flatMap(_.config.get(\"url\").map(Url.parse)).compile.toList else {\n+        log(s\"No admin rights to check hooks\")\n+        IO.pure(Seq.empty)\n+      }\n   }\n }\n \n@@ -197,21 +209,21 @@ case class RepoSnapshot(\n     checkpoint <- allAvailableCheckpoints\n   } yield prLabel.labelFor(checkpoint.name)\n \n-  def diagnostic(): Future[Diagnostic] = for {\n+  def diagnostic(): IO[Diagnostic] = for {\n     snapshots <- snapshotOfAllAvailableCheckpoints()\n   } yield Diagnostic(snapshots, mergedPRs.map { pr =>\n     PRCheckpointDetails(pr, snapshots.filter(s => activeCheckpointsByPullRequest(pr).contains(s.checkpoint)), repoLevelDetails.gitRepo)\n   })\n \n-  def snapshotOfAllAvailableCheckpoints(): Future[Set[CheckpointSnapshot]] =\n-    Future.sequence(allAvailableCheckpoints.map(takeCheckpointSnapshot))\n+  def snapshotOfAllAvailableCheckpoints(): IO[Set[CheckpointSnapshot]] =\n+    allAvailableCheckpoints.parUnorderedTraverse(takeCheckpointSnapshot)\n \n   val activeCheckpoints: Set[Checkpoint] = activeCheckpointsByPullRequest.values.flatten.toSet\n \n-  lazy val snapshotsOfActiveCheckpointsF: Map[Checkpoint, Future[CheckpointSnapshot]] =\n+  lazy val snapshotsOfActiveCheckpointsF: Map[Checkpoint, IO[CheckpointSnapshot]] =\n     activeCheckpoints.map { c => c -> takeCheckpointSnapshot(c) }.toMap\n \n-  def takeCheckpointSnapshot(checkpoint: Checkpoint): Future[CheckpointSnapshot] = for (\n+  def takeCheckpointSnapshot(checkpoint: Checkpoint): IO[CheckpointSnapshot] = for (\n     possibleIdsTry <- checkpointSnapshoter.snapshot(checkpoint).trying\n   ) yield {\n     val objectIdTry = for (possibleIds <- possibleIdsTry) yield {\n@@ -222,7 +234,8 @@ case class RepoSnapshot(\n     CheckpointSnapshot(checkpoint, objectIdTry)\n   }\n \n-  lazy val activeSnapshotsF: Future[Set[CheckpointSnapshot]] =\n+  lazy val activeSnapshotsF: IO[Set[CheckpointSnapshot]] =\n+    \n     Future.sequence(activeCheckpoints.map(snapshotsOfActiveCheckpointsF))\n \n   def checkpointSnapshotsFor(pr: PullRequest, oldState: PRCheckpointState): Future[Set[CheckpointSnapshot]] ="
    },
    {
      "filename": "app/lib/RepoUpdater.scala",
      "status": "modified",
      "patch": "@@ -1,6 +1,7 @@\n package lib\n \n-import com.madgag.github.Implicits._\n+import cats.effect.IO\n+import com.madgag.github.Implicits.*\n import com.madgag.scalagithub.GitHub\n import com.madgag.scalagithub.commands.CreateLabel\n import lib.labels.{CheckpointTestStatus, PullRequestCheckpointStatus}\n@@ -14,10 +15,10 @@ class RepoUpdater(implicit\n   ec: ExecutionContext\n ) {\n \n-  def attemptToCreateMissingLabels(repoLevelDetails: RepoLevelDetails): Future[_] = {\n+  def attemptToCreateMissingLabels(repoLevelDetails: RepoLevelDetails): IO[_] = {\n     for {\n-      existingLabels <- repoLevelDetails.repo.labels.list().all()\n-      createdLabels <- Future.traverse(missingLabelsGiven(repoLevelDetails, existingLabels.map(_.name).toSet)) {\n+      existingLabels <- repoLevelDetails.repo.labels.list().compile.toList\n+      createdLabels <- IO.parTraverse(missingLabelsGiven(repoLevelDetails, existingLabels.map(_.name).toSet).toList) {\n         missingLabel => repoLevelDetails.repo.labels.create(missingLabel)\n       }\n     } yield createdLabels"
    },
    {
      "filename": "app/lib/slack/DeployReporter.scala",
      "status": "modified",
      "patch": "@@ -3,10 +3,11 @@ package lib.slack\n import cats.data.NonEmptySeq\n import com.madgag.scalagithub.model.{PullRequest, User}\n import io.lemonlabs.uri.Url\n+import lib.*\n import lib.labels.Seen\n-import lib._\n import play.api.Logging\n import play.api.libs.json.{JsValue, Json}\n+import play.api.libs.ws.WSBodyWritables.*\n import play.api.libs.ws.WSClient\n \n import scala.concurrent.{ExecutionContext, Future}"
    },
    {
      "filename": "build.sbt",
      "status": "modified",
      "patch": "@@ -2,7 +2,7 @@ name := \"prout\"\n \n version := \"1.0-SNAPSHOT\"\n \n-scalaVersion := \"2.13.16\"\n+scalaVersion := \"3.3.6\"\n \n updateOptions := updateOptions.value.withCachedResolution(true)\n \n@@ -18,7 +18,7 @@ lazy val root = (project in file(\".\")).enablePlugins(PlayScala, BuildInfoPlugin)\n Test / testOptions +=\n   Tests.Argument(TestFrameworks.ScalaTest, \"-u\", s\"test-results/scala-${scalaVersion.value}\")\n \n-val playGitHubVersion = \"9.0.0\"\n+val playGitHubVersion = \"9.0.2-SNAPSHOT\"\n \n val jacksonVersion         = \"2.19.2\"\n val jacksonDatabindVersion = \"2.19.2\"\n@@ -45,7 +45,7 @@ libraryDependencies ++= jacksonDatabindOverrides ++ jacksonOverrides ++ akkaSeri\n libraryDependencies ++= Seq(\n   filters,\n   ws,\n-  \"com.softwaremill.macwire\" %% \"macros\" % \"2.6.6\" % Provided, // slight finesse: 'provided' as only used for compile\n+  \"com.softwaremill.macwire\" %% \"macros\" % \"2.6.7\" % Provided, // slight finesse: 'provided' as only used for compile\n   \"com.madgag\" %% \"scala-collection-plus\" % \"1.0.0\",\n   \"org.typelevel\" %% \"cats-core\" % \"2.13.0\",\n   \"com.github.blemale\" %% \"scaffeine\" % \"5.3.0\",\n@@ -55,10 +55,10 @@ libraryDependencies ++= Seq(\n   \"ch.qos.logback\" % \"logback-classic\" % \"1.5.18\",\n   \"com.github.nscala-time\" %% \"nscala-time\" % \"3.0.0\",\n   \"com.indoorvivants\" %% \"scala-uri\" % \"4.2.0\",\n-  \"com.typesafe.scala-logging\" %% \"scala-logging\" % \"3.9.5\",\n+  \"com.typesafe.scala-logging\" %% \"scala-logging\" % \"3.9.6\",\n   \"com.madgag.play-git-hub\" %% \"core\" % playGitHubVersion,\n   \"com.madgag.play-git-hub\" %% \"testkit\" % playGitHubVersion % Test,\n-  \"com.madgag.scala-git\" %% \"scala-git-test\" % \"6.0.0\" % Test,\n+  \"com.madgag.scala-git\" %% \"scala-git-test\" % \"7.0.3\" % Test,\n   \"org.scalatestplus.play\" %% \"scalatestplus-play\" % \"7.0.2\" % Test\n )\n "
    },
    {
      "filename": "test/FunctionalSpec.scala",
      "status": "modified",
      "patch": "@@ -61,7 +61,7 @@ class FunctionalSpec extends Helpers with Inside with BeforeAndAfterAll {\n     }\n \n     \"not act on a pull request if it does not touch a .prout.json configured folder\" in {\n-      implicit val repoPR = mergePullRequestIn(createTestRepo(\"/multi-project.master-updated-before-feature-merged.git.zip\"), \"bard-feature\")\n+      implicit val repoPR: RepoPR = mergePullRequestIn(createTestRepo(\"/multi-project.master-updated-before-feature-merged.git.zip\"), \"bard-feature\")\n \n       repoPR setCheckpointTo zeroId\n \n@@ -73,7 +73,7 @@ class FunctionalSpec extends Helpers with Inside with BeforeAndAfterAll {\n     }\n \n     \"act on a pull request if it touches a .prout.json configured folder\" in {\n-      implicit val repoPR = mergePullRequestIn(createTestRepo(\"/multi-project.master-updated-before-feature-merged.git.zip\"), \"food-feature\")\n+      implicit val repoPR: RepoPR = mergePullRequestIn(createTestRepo(\"/multi-project.master-updated-before-feature-merged.git.zip\"), \"food-feature\")\n \n       repoPR setCheckpointTo zeroId\n \n@@ -91,7 +91,7 @@ class FunctionalSpec extends Helpers with Inside with BeforeAndAfterAll {\n     }\n \n     \"report an overdue merge without being called\" in {\n-      implicit val repoPR = mergePullRequestIn(createTestRepo(\"/impatient-top-level-config.git.zip\"), \"feature-1\")\n+      implicit val repoPR: RepoPR = mergePullRequestIn(createTestRepo(\"/impatient-top-level-config.git.zip\"), \"feature-1\")\n \n       repoPR setCheckpointTo zeroId\n \n@@ -114,7 +114,7 @@ class FunctionalSpec extends Helpers with Inside with BeforeAndAfterAll {\n     }\n \n     \"report a broken site as overdue\" in {\n-      implicit val repoPR = mergePullRequestIn(createTestRepo(\"/impatient-top-level-config.git.zip\"), \"feature-1\")\n+      implicit val repoPR: RepoPR = mergePullRequestIn(createTestRepo(\"/impatient-top-level-config.git.zip\"), \"feature-1\")\n \n       repoPR setCheckpointFailureTo new Exception(\"This website went Boom!\")\n \n@@ -136,7 +136,7 @@ class FunctionalSpec extends Helpers with Inside with BeforeAndAfterAll {\n     }\n \n     \"use custom messages in comments when set in the config\" in {\n-      implicit val repoPR = mergePullRequestIn(createTestRepo(\"/simple-with-messages.git.zip\"), \"feature-elephant\")\n+      implicit val repoPR: RepoPR = mergePullRequestIn(createTestRepo(\"/simple-with-messages.git.zip\"), \"feature-elephant\")\n \n       repoPR setCheckpointTo zeroId\n "
    },
    {
      "filename": "test/lib/ConfigFinderSpec.scala",
      "status": "modified",
      "patch": "@@ -11,7 +11,8 @@ class ConfigFinderSpec extends PlaySpec {\n   def configFilesIn(repoPath: String): Set[String] = {\n     val localGitRepo: Repository = test.unpackRepo(repoPath)\n \n-    implicit val repoThreadLocal = localGitRepo.getObjectDatabase.threadLocalResources\n+    implicit val repoThreadLocal: ThreadLocalObjectDatabaseResources = \n+      localGitRepo.getObjectDatabase.threadLocalResources\n \n     val master = localGitRepo.resolve(\"master\").asRevCommit(new RevWalk(repoThreadLocal.reader()))\n "
    },
    {
      "filename": "test/lib/ConfigSpec.scala",
      "status": "modified",
      "patch": "@@ -10,42 +10,42 @@ import play.api.libs.json._\n \n class ConfigSpec extends PlaySpec with OptionValues with Inside {\n \n-   \"Config json parsing\" must {\n-     \"parse normal Checkpoint config\" in {\n-       val details = checkpointDetailsFrom(\"/sample.checkpoint.json\")\n-\n-       details mustEqual JsSuccess(CheckpointDetails(Uri.parse(\"https://membership.theguardian.com/\"), minutes(14)))\n-       details.get.sslVerification mustBe true\n-      }\n-\n-     \"parse Checkpoint config with custom messages\" in {\n-       val details = checkpointDetailsFrom(\"/sample.messages.checkpoint.json\")\n-\n-       details mustEqual JsSuccess(\n-         CheckpointDetails(\n-           url = Uri.parse(\"https://www.theguardian.com\"),\n-           overdue = minutes(20),\n-           messages = Some(CheckpointMessages(Seen -> \"prout/seen.md\", Overdue -> \"prout/overdue.md\"))\n-         )\n-       )\n-     }\n-\n-     \"parse Checkpoint config with one custom message\" in {\n-       val details = checkpointDetailsFrom(\"/sample.one.message.checkpoint.json\")\n+  \"Config json parsing\" must {\n+    \"parse normal Checkpoint config\" in {\n+      val details = checkpointDetailsFrom(\"/sample.checkpoint.json\")\n \n-       details mustEqual JsSuccess(\n-         CheckpointDetails(\n-           url = Uri.parse(\"https://www.theguardian.com\"),\n-           overdue = minutes(15),\n-           messages = Some(CheckpointMessages(Seen -> \"prout/seen.md\"))\n-         )\n-       )\n+      details mustEqual JsSuccess(CheckpointDetails(Uri.parse(\"https://membership.theguardian.com/\"), minutes(14)))\n+      details.get.sslVerification mustBe true\n      }\n \n-     \"parse insecure config\" in {\n-       checkpointDetailsFrom(\"/sample.insecure.checkpoint.json\").get.sslVerification mustBe false\n-     }\n-   }\n+    \"parse Checkpoint config with custom messages\" in {\n+      val details = checkpointDetailsFrom(\"/sample.messages.checkpoint.json\")\n+\n+      details mustEqual JsSuccess(\n+        CheckpointDetails(\n+          url = Uri.parse(\"https://www.theguardian.com\"),\n+          overdue = minutes(20),\n+          messages = Some(CheckpointMessages(Seen -> \"prout/seen.md\", Overdue -> \"prout/overdue.md\"))\n+        )\n+      )\n+    }\n+\n+    \"parse Checkpoint config with one custom message\" in {\n+      val details = checkpointDetailsFrom(\"/sample.one.message.checkpoint.json\")\n+\n+      details mustEqual JsSuccess(\n+        CheckpointDetails(\n+          url = Uri.parse(\"https://www.theguardian.com\"),\n+          overdue = minutes(15),\n+          messages = Some(CheckpointMessages(Seen -> \"prout/seen.md\"))\n+        )\n+      )\n+    }\n+\n+    \"parse insecure config\" in {\n+      checkpointDetailsFrom(\"/sample.insecure.checkpoint.json\").get.sslVerification mustBe false\n+    }\n+  }\n \n   def checkpointDetailsFrom(resourcePath: String): JsResult[CheckpointDetails] = {\n     Json.parse(getClass.getResourceAsStream(resourcePath)).validate[CheckpointDetails]"
    },
    {
      "filename": "test/lib/GitChangesSpec.scala",
      "status": "modified",
      "patch": "@@ -1,18 +1,18 @@\n package lib\n \n-import com.madgag.git._\n+import com.madgag.git.*\n import lib.GitChanges.affectedFolders\n-import org.eclipse.jgit.lib.Repository\n-import org.eclipse.jgit.revwalk.RevCommit\n-import org.scalatestplus.play._\n+import org.eclipse.jgit.lib.{ObjectReader, Repository}\n+import org.eclipse.jgit.revwalk.{RevCommit, RevWalk}\n+import org.scalatestplus.play.*\n \n class GitChangesSpec extends PlaySpec {\n \n   \"Multi folder config\" must {\n \n     \"detect changes in top-level folder\" in {\n       implicit val localGitRepo: Repository = test.unpackRepo(\"/simple.git.zip\")\n-      implicit val (revWalk, reader) = localGitRepo.singleThreadedReaderTuple\n+      implicit val (revWalk: RevWalk, reader: ObjectReader) = localGitRepo.singleThreadedReaderTuple\n \n       def commitAt(revstr: String) = localGitRepo.resolve(revstr).asRevCommit\n \n@@ -25,7 +25,7 @@ class GitChangesSpec extends PlaySpec {\n \n     \"detect changes in affected folders\" in {\n       implicit val localGitRepo: Repository = test.unpackRepo(\"/multi-folder.git.zip\")\n-      implicit val (revWalk, reader) = localGitRepo.singleThreadedReaderTuple\n+      implicit val (revWalk: RevWalk, reader: ObjectReader) = localGitRepo.singleThreadedReaderTuple\n \n       def commitAt(revstr: String) = localGitRepo.resolve(revstr).asRevCommit\n \n@@ -41,7 +41,7 @@ class GitChangesSpec extends PlaySpec {\n \n     \"not confuse changes on master with changes on the feature branch\" in {\n       implicit val localGitRepo: Repository = test.unpackRepo(\"/multi-project.master-updated-before-feature-merged.git.zip\")\n-      implicit val (revWalk, reader) = localGitRepo.singleThreadedReaderTuple\n+      implicit val (revWalk: RevWalk, reader: ObjectReader) = localGitRepo.singleThreadedReaderTuple\n \n       def commitAt(revstr: String) = localGitRepo.resolve(revstr).asRevCommit\n "
    },
    {
      "filename": "test/lib/Helpers.scala",
      "status": "modified",
      "patch": "@@ -3,7 +3,7 @@ package lib\n import com.madgag.github.Implicits._\n import com.madgag.github.apps.GitHubAppAuth\n import com.madgag.playgithub.testkit.TestRepoCreation\n-import com.madgag.scalagithub.GitHubCredentials\n+import com.madgag.scalagithub.{AccountCredentials, GitHubCredentials}\n import com.madgag.scalagithub.commands.{CreatePullRequest, MergePullRequest}\n import com.madgag.scalagithub.model._\n import lib.sentry.SentryApiClient\n@@ -41,8 +41,8 @@ trait Helpers extends PlaySpec with OneAppPerSuiteWithComponents with Inspectors\n   val testFixturesInstallationAccess: com.madgag.github.apps.InstallationAccess =\n     gitHubAppAuth.accessSoleInstallation().futureValue\n \n-  val testFixturesAccount: Account = testFixturesInstallationAccess.installedOnAccount\n-  val testFixturesCredentials: GitHubCredentials.Provider = testFixturesInstallationAccess.credentials\n+  val testFixtureAccountCredentials: AccountCredentials =\n+    AccountCredentials(testFixturesInstallationAccess.installedOnAccount, testFixturesInstallationAccess.credentials)\n \n   def labelsOnPR()(implicit repoPR: RepoPR): Set[String] = labelsOn(repoPR.pr)\n \n@@ -61,16 +61,7 @@ trait Helpers extends PlaySpec with OneAppPerSuiteWithComponents with Inspectors\n   case class RepoPR(pr: PullRequest) {\n     val githubRepo = pr.baseRepo\n \n-    def currentPR(): PullRequest = {\n-      def fetchPR(): PullRequest = githubRepo.pullRequests.get(pr.number).futureValue\n-\n-      eventually {\n-        val pr = fetchPR()\n-        Thread.sleep(1000)\n-        fetchPR() mustEqual pr\n-        pr\n-      }\n-    }\n+    def currentPR(): PullRequest = eventuallyConsistent { githubRepo.pullRequests.get(pr.number) }\n \n     def listComments(): Seq[Comment] = pr.comments2.list().all().futureValue\n \n@@ -116,19 +107,28 @@ trait Helpers extends PlaySpec with OneAppPerSuiteWithComponents with Inspectors\n     override val toString: String = pr.html_url\n   }\n \n+\n   def scan[T](shouldAddComment: Boolean)(issueFun: PullRequest => T)(implicit repoPR: RepoPR): Unit = {\n     val commentsBeforeScan = repoPR.listComments()\n-    whenReady(repoPR.scheduler.scan()) { s =>\n-      eventually {\n-        inside(repoPR) { case _ =>\n-          val commentsAfterScan = repoPR.listComments()\n-          commentsAfterScan must have size (commentsBeforeScan.size+(if (shouldAddComment) 1 else 0))\n-          issueFun(repoPR.currentPR())\n-        }\n+    scanOnce(requireScanFindsAPr = commentsBeforeScan.isEmpty) // if we're starting out, scan enough times that we actually find the PR\n+\n+    eventually {\n+      inside(repoPR) { case _ =>\n+        val commentsAfterScan = repoPR.listComments()\n+        commentsAfterScan must have size (commentsBeforeScan.size+(if (shouldAddComment) 1 else 0))\n+        issueFun(repoPR.currentPR())\n       }\n     }\n   }\n \n+  private def scanOnce(requireScanFindsAPr: Boolean)(implicit repoPR: RepoPR): Unit = if (requireScanFindsAPr) {\n+    eventually {\n+      whenReady(repoPR.scheduler.scan()) { _ must not be empty } // ensure that scan found a PR\n+    }\n+  } else {\n+    repoPR.scheduler.scan().futureValue // just ensure that a scan has taken place - note that once fully deployed, scan will not return a PR\n+  }\n+\n   def waitUntil[T](shouldAddComment: Boolean)(issueFun: PullRequest => T)(implicit repoPR: RepoPR): Unit = {\n     val commentsBeforeScan = repoPR.listComments()\n     eventually {\n@@ -157,7 +157,7 @@ trait Helpers extends PlaySpec with OneAppPerSuiteWithComponents with Inspectors\n     merging: String,\n     prText: PRText = PRText(\"title\", \"desc\"),\n     userLabels: Set[String] = Set.empty\n-  ) = {\n+  ): RepoPR = {\n     eventually {\n       whenReady(repo.refs.get(s\"heads/$merging\")) { _.ref must endWith(merging) }\n     }"
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Time",
  "root_cause_subcategory": NaN
}