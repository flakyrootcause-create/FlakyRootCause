{
  "id": 154,
  "repo": "kubernetes",
  "issue_url": "https://github.com/kubernetes/kubernetes/commit/76ab726",
  "pr_url": "https://github.com/kubernetes/kubernetes/commit/76ab726",
  "issue_description": "- Added default blurb for help text to show the 3 kinds of requests possible\n- Generate request-type specific help text (e.g., trying 'cloudcfg run' will provide usage helptext on the run command.)\n\n```\n$ ./output/go/cloudcfg\nusage: cloudcfg -h <host> [-c config/file.json] [-p <hostPort>:<containerPort>,..., <hostPort-n>:<containerPort-n>] <method> <methodArgs>\n\n  Kubernetes REST API:\n  cloudcfg [OPTIONS] get|list|create|delete|update <url>\n\n  Run an image:\n  cloudcfg [OPTIONS] run <image> <replicas> <name>\n\n  Manage replication controllers:\n  cloudcfg [OPTIONS] stop|rm|rollingupdate <controller>\n\n  Options:\n  -auth=\"/Users/tlow/.kubernetes_auth\": Path to the auth info file.  If missing, prompt the user\n  -c=\"\": Path to the config file.\n  -h=\"\": The host to connect to.\n  -json=false: If true, print raw JSON for responses\n  -l=\"\": Label query to use for listing\n  -p=\"\": The port spec, comma-separated list of <external>:<internal>,...\n  -s=-1: If positive, create and run a corresponding service on this port, only used with 'run'\n  -u=1m0s: Update interarrival period\n  -v=false: Print the version number.\n  -yaml=false: If true, print raw YAML for responses\n\n$ ./output/go/cloudcfg rollingupdate\n2014/06/12 11:13:18 usage: cloudcfg [OPTIONS] stop|rm|rollingupdate <controller>\n$ ./output/go/cloudcfg get\n2014/06/12 11:13:22 usage: cloudcfg [OPTIONS] get|list|create|update|delete <url>\n$ ./output/go/cloudcfg run\n2014/06/12 11:13:25 usage: cloudcfg [OPTIONS] run <image> <replicas> <name>\n```\n",
  "files_changed": [
    {
      "filename": "cmd/cloudcfg/cloudcfg.go",
      "status": "modified",
      "patch": "@@ -49,7 +49,19 @@ var (\n )\n \n func usage() {\n-\tlog.Fatal(\"Usage: cloudcfg -h <host> [-c config/file.json] [-p <hostPort>:<containerPort>,..., <hostPort-n>:<containerPort-n> <method> <path>\")\n+\tfmt.Fprint(os.Stderr, `usage: cloudcfg -h [-c config/file.json] [-p :,..., :] <method>\n+\n+  Kubernetes REST API:\n+  cloudcfg [OPTIONS] get|list|create|delete|update <url>\n+\n+  Manage replication controllers:\n+  cloudcfg [OPTIONS] stop|rm|rollingupdate <controller>\n+  cloudcfg [OPTIONS] run <image> <replicas> <controller>\n+  cloudcfg [OPTIONS] resize <controller> <replicas>\n+\n+  Options:\n+`)\n+\tflag.PrintDefaults()\n }\n \n // Reads & parses config file. On error, calls log.Fatal().\n@@ -71,15 +83,20 @@ func readConfig(storage string) []byte {\n \n // CloudCfg command line tool.\n func main() {\n+\tflag.Usage = func() {\n+\t\tusage()\n+\t}\n+\n \tflag.Parse() // Scan the arguments list\n \n \tif *versionFlag {\n \t\tfmt.Println(\"Version:\", APP_VERSION)\n \t\tos.Exit(0)\n \t}\n \n-\tif len(flag.Args()) < 2 {\n+\tif len(flag.Args()) < 1 {\n \t\tusage()\n+\t\tos.Exit(1)\n \t}\n \tmethod := flag.Arg(0)\n \tsecure := true\n@@ -90,18 +107,6 @@ func main() {\n \tif parsedUrl.Scheme != \"\" && parsedUrl.Scheme != \"https\" {\n \t\tsecure = false\n \t}\n-\tstorage := strings.Trim(flag.Arg(1), \"/\")\n-\turl := *httpServer + path.Join(\"/api/v1beta1\", storage)\n-\tvar request *http.Request\n-\n-\tvar printer cloudcfg.ResourcePrinter\n-\tif *json {\n-\t\tprinter = &cloudcfg.IdentityPrinter{}\n-\t} else if *yaml {\n-\t\tprinter = &cloudcfg.YAMLPrinter{}\n-\t} else {\n-\t\tprinter = &cloudcfg.HumanReadablePrinter{}\n-\t}\n \n \tvar auth *kube_client.AuthInfo\n \tif secure {\n@@ -111,80 +116,116 @@ func main() {\n \t\t}\n \t}\n \n+\tmatchFound := executeAPIRequest(method, auth) || executeControllerRequest(method, auth)\n+\tif matchFound == false {\n+\t\tlog.Fatalf(\"Unknown command %s\", method)\n+\t}\n+}\n+\n+// Attempts to execute an API request\n+func executeAPIRequest(method string, auth *kube_client.AuthInfo) bool {\n+\tparseStorage := func() string {\n+\t\tif len(flag.Args()) != 2 {\n+\t\t\tlog.Fatal(\"usage: cloudcfg [OPTIONS] get|list|create|update|delete <url>\")\n+\t\t}\n+\t\treturn strings.Trim(flag.Arg(1), \"/\")\n+\t}\n+\n+\treadUrl := func(storage string) string {\n+\t\treturn *httpServer + path.Join(\"/api/v1beta1\", storage)\n+\t}\n+\n+\tvar request *http.Request\n+\tvar err error\n \tswitch method {\n \tcase \"get\", \"list\":\n+\t\turl := readUrl(parseStorage())\n \t\tif len(*labelQuery) > 0 && method == \"list\" {\n \t\t\turl = url + \"?labels=\" + *labelQuery\n \t\t}\n \t\trequest, err = http.NewRequest(\"GET\", url, nil)\n \tcase \"delete\":\n-\t\trequest, err = http.NewRequest(\"DELETE\", url, nil)\n+\t\trequest, err = http.NewRequest(\"DELETE\", readUrl(parseStorage()), nil)\n \tcase \"create\":\n-\t\trequest, err = cloudcfg.RequestWithBodyData(readConfig(storage), url, \"POST\")\n+\t\tstorage := parseStorage()\n+\t\trequest, err = cloudcfg.RequestWithBodyData(readConfig(storage), readUrl(storage), \"POST\")\n \tcase \"update\":\n-\t\trequest, err = cloudcfg.RequestWithBodyData(readConfig(storage), url, \"PUT\")\n+\t\tstorage := parseStorage()\n+\t\trequest, err = cloudcfg.RequestWithBodyData(readConfig(storage), readUrl(storage), \"PUT\")\n+\tdefault:\n+\t\treturn false\n+\t}\n+\n+\tvar printer cloudcfg.ResourcePrinter\n+\tif *json {\n+\t\tprinter = &cloudcfg.IdentityPrinter{}\n+\t} else if *yaml {\n+\t\tprinter = &cloudcfg.YAMLPrinter{}\n+\t} else {\n+\t\tprinter = &cloudcfg.HumanReadablePrinter{}\n+\t}\n+\n+\tvar body string\n+\tif body, err = cloudcfg.DoRequest(request, auth); err == nil {\n+\t\tif err = printer.Print(body, os.Stdout); err != nil {\n+\t\t\tlog.Fatalf(\"Failed to print: %#v\\nRaw received text:\\n%v\\n\", err, string(body))\n+\t\t}\n+\t\tfmt.Print(\"\\n\")\n+\t} else {\n+\t\tlog.Fatalf(\"Error: %#v %s\", err, body)\n+\t}\n+\n+\treturn true\n+}\n+\n+// Attempts to execute a replicationController request\n+func executeControllerRequest(method string, auth *kube_client.AuthInfo) bool {\n+\tparseController := func() string {\n+\t\tif len(flag.Args()) != 2 {\n+\t\t\tlog.Fatal(\"usage: cloudcfg [OPTIONS] stop|rm|rollingupdate <controller>\")\n+\t\t}\n+\t\treturn flag.Arg(1)\n+\t}\n+\n+\tvar err error\n+\tswitch method {\n+\tcase \"stop\":\n+\t\terr = cloudcfg.StopController(parseController(), kube_client.Client{Host: *httpServer, Auth: auth})\n+\tcase \"rm\":\n+\t\terr = cloudcfg.DeleteController(parseController(), kube_client.Client{Host: *httpServer, Auth: auth})\n \tcase \"rollingupdate\":\n \t\tclient := &kube_client.Client{\n \t\t\tHost: *httpServer,\n \t\t\tAuth: auth,\n \t\t}\n-\t\tcloudcfg.Update(flag.Arg(1), client, *updatePeriod)\n+\t\terr = cloudcfg.Update(parseController(), client, *updatePeriod)\n \tcase \"run\":\n-\t\targs := flag.Args()\n-\t\tif len(args) < 4 {\n-\t\t\tlog.Fatal(\"usage: cloudcfg -h <host> run <image> <replicas> <name>\")\n+\t\tif len(flag.Args()) != 4 {\n+\t\t\tlog.Fatal(\"usage: cloudcfg [OPTIONS] run <image> <replicas> <controller>\")\n \t\t}\n-\t\timage := args[1]\n-\t\treplicas, err := strconv.Atoi(args[2])\n-\t\tname := args[3]\n+\t\timage := flag.Arg(1)\n+\t\treplicas, err := strconv.Atoi(flag.Arg(2))\n+\t\tname := flag.Arg(3)\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"Error parsing replicas: %#v\", err)\n \t\t}\n \t\terr = cloudcfg.RunController(image, name, replicas, kube_client.Client{Host: *httpServer, Auth: auth}, *portSpec, *servicePort)\n-\t\tif err != nil {\n-\t\t\tlog.Fatalf(\"Error: %#v\", err)\n-\t\t}\n-\t\treturn\n-\tcase \"stop\":\n-\t\terr = cloudcfg.StopController(flag.Arg(1), kube_client.Client{Host: *httpServer, Auth: auth})\n-\t\tif err != nil {\n-\t\t\tlog.Fatalf(\"Error: %#v\", err)\n-\t\t}\n-\t\treturn\n \tcase \"resize\":\n \t\targs := flag.Args()\n \t\tif len(args) < 3 {\n-\t\t\tlog.Fatal(\"usage: cloudcfg resize <name> <replicas>\")\n+\t\t\tlog.Fatal(\"usage: cloudcfg resize <controller> <replicas>\")\n \t\t}\n \t\tname := args[1]\n \t\treplicas, err := strconv.Atoi(args[2])\n \t\tif err != nil {\n \t\t\tlog.Fatalf(\"Error parsing replicas: %#v\", err)\n \t\t}\n \t\terr = cloudcfg.ResizeController(name, replicas, kube_client.Client{Host: *httpServer, Auth: auth})\n-\t\tif err != nil {\n-\t\t\tlog.Fatalf(\"Error: %#v\", err)\n-\t\t}\n-\t\treturn\n-\tcase \"rm\":\n-\t\terr = cloudcfg.DeleteController(flag.Arg(1), kube_client.Client{Host: *httpServer, Auth: auth})\n-\t\tif err != nil {\n-\t\t\tlog.Fatalf(\"Error: %#v\", err)\n-\t\t}\n-\t\treturn\n \tdefault:\n-\t\tlog.Fatalf(\"Unknown command: %s\", method)\n+\t\treturn false\n \t}\n \tif err != nil {\n \t\tlog.Fatalf(\"Error: %#v\", err)\n \t}\n-\tbody, err := cloudcfg.DoRequest(request, auth)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"Error: %#v %s\", err, body)\n-\t}\n-\terr = printer.Print(body, os.Stdout)\n-\tif err != nil {\n-\t\tlog.Fatalf(\"Failed to print: %#v\\nRaw received text:\\n%v\\n\", err, string(body))\n-\t}\n-\tfmt.Print(\"\\n\")\n+\treturn true\n }"
    }
  ],
  "fix_category": "Make deterministic",
  "root_cause_category": "Unordered collections",
  "root_cause_subcategory": NaN
}