{
  "id": 413,
  "repo": "omes",
  "issue_url": "https://github.com/temporalio/omes/pull/190",
  "pr_url": "https://github.com/temporalio/omes/pull/190",
  "issue_description": "<!--- Note to EXTERNAL Contributors -->\r\n<!-- Thanks for opening a PR! \r\nIf it is a significant code change, please **make sure there is an open issue** for this. \r\nWe work best with you when we have accepted the idea first before you code. -->\r\n\r\n<!--- For ALL Contributors \ud83d\udc47 -->\r\n\r\n## What was changed\r\n<!-- Describe what has changed in this PR -->\r\n\r\nBumped to Go 1.25 to use the new `synctest.Test` primitive to run deterministic timing tests.\r\n\r\nTip: use `Hide Whitespace` option for reviewing.\r\n\r\n## Why?\r\n<!-- Tell your future self why have you made these changes -->\r\n\r\n`TestRunDurationWithoutTimeout` is flaky - example:\r\nhttps://github.com/temporalio/omes/actions/runs/17052148233/job/48342124492?pr=179#step:4:125\r\n\r\n## Checklist\r\n<!--- add/delete as needed --->\r\n\r\n1. Closes <!-- add issue number here -->\r\n\r\n2. How was this tested:\r\n<!--- Please describe how you tested your changes/how we can test them -->\r\n\r\n3. Any docs updates needed?\r\n<!--- update README if applicable\r\n      or point out where to update docs.temporal.io -->\r\n",
  "files_changed": [
    {
      "filename": "README.md",
      "status": "modified",
      "patch": "@@ -9,7 +9,7 @@ Omes (pronounced oh-mess) is the Hebrew word for \"load\" (\u05e2\u05d5\u05de\u05e1).\n \n ## Prerequisites\n \n-- [Go](https://golang.org/) 1.24+\n+- [Go](https://golang.org/) 1.25+\n   - `protoc` + `protoc-gen-go` or [mise](https://mise.jdx.dev/) for [Kitchen Sink Workflow](#kitchen-sink-workflow)\n - [Java](https://openjdk.org/) 8+\n - TypeScript: [Node](https://nodejs.org) 16+\n@@ -134,7 +134,7 @@ go run ./cmd cleanup-scenario --scenario workflow_with_single_noop_activity --ru\n ### Running a specific version of the SDK\n \n The `--version` flag can be used to specify a version of the SDK to use, it accepts either\n-a version number lik `v1.24.0` or you can also pass a local path to use a local SDK version.\n+a version number like `v1.24.0` or you can also pass a local path to use a local SDK version.\n This is useful while testing unreleased or in-development versions of the SDK.\n \n ```sh"
    },
    {
      "filename": "dockerfiles/go.Dockerfile",
      "status": "modified",
      "patch": "@@ -1,6 +1,6 @@\n # Build in a full featured container\n ARG TARGETARCH\n-FROM --platform=linux/$TARGETARCH golang:1.24 AS build\n+FROM --platform=linux/$TARGETARCH golang:1.25 AS build\n \n WORKDIR /app\n "
    },
    {
      "filename": "go.mod",
      "status": "modified",
      "patch": "@@ -1,6 +1,6 @@\n module github.com/temporalio/omes\n \n-go 1.24.5\n+go 1.25.0\n \n require (\n \tgithub.com/gogo/protobuf v1.3.2"
    },
    {
      "filename": "loadgen/generic_executor_test.go",
      "status": "modified",
      "patch": "@@ -5,6 +5,7 @@ import (\n \t\"errors\"\n \t\"sync\"\n \t\"testing\"\n+\t\"testing/synctest\"\n \t\"time\"\n \n \t\"github.com/stretchr/testify/require\"\n@@ -109,143 +110,166 @@ func execute(executor *GenericExecutor) error {\n }\n \n func TestRunHappyPathIterations(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{Iterations: 5},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{Iterations: 5},\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\ttracker.assertSeen(t, 5)\n \t})\n-\trequire.NoError(t, err)\n-\ttracker.assertSeen(t, 5)\n }\n \n func TestRunFailIterations(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\tconcurrency := 3\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\t// Start this short timer to allow all concurrent routines to be spawned\n-\t\t\t<-time.After(time.Millisecond)\n-\t\t\tif run.Iteration == 2 {\n-\t\t\t\treturn errors.New(\"deliberate fail from test\")\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{MaxConcurrent: concurrency, Iterations: 50},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\tconcurrency := 3\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\tif run.Iteration == 2 {\n+\t\t\t\t\treturn errors.New(\"deliberate fail from test\")\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{MaxConcurrent: concurrency, Iterations: 50},\n+\t\t})\n+\t\trequire.ErrorContains(t, err, \"run finished with error\")\n+\t\ttracker.assertSeen(t, 2)\n \t})\n-\trequire.ErrorContains(t, err, \"run finished with error\")\n-\ttracker.assertSeen(t, 2)\n }\n \n func TestRunHappyPathDuration(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\ttime.Sleep(time.Millisecond * 20)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{Duration: 100 * time.Millisecond},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\ttime.Sleep(time.Millisecond * 20)\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{Duration: 100 * time.Millisecond},\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\ttracker.assertSeen(t, DefaultMaxConcurrent*2)\n \t})\n-\trequire.NoError(t, err)\n-\ttracker.assertSeen(t, DefaultMaxConcurrent*2)\n }\n \n func TestRunFailDuration(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\tif run.Iteration == 2 {\n-\t\t\t\treturn errors.New(\"deliberate fail from test\")\n-\t\t\t}\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{Duration: 200 * time.Millisecond},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\tif run.Iteration == 2 {\n+\t\t\t\t\treturn errors.New(\"deliberate fail from test\")\n+\t\t\t\t}\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{Duration: 200 * time.Millisecond},\n+\t\t})\n+\t\trequire.ErrorContains(t, err, \"run finished with error\")\n+\t\ttracker.assertSeen(t, 2)\n \t})\n-\trequire.ErrorContains(t, err, \"run finished with error\")\n-\ttracker.assertSeen(t, 2)\n }\n \n func TestRunDurationWithTimeout(t *testing.T) {\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttime.Sleep(time.Millisecond * 20)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{\n-\t\t\tDuration: 100 * time.Millisecond,\n-\t\t\tTimeout:  10 * time.Millisecond},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\t<-ctx.Done()\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{\n+\t\t\t\tDuration: 100 * time.Millisecond,\n+\t\t\t\tTimeout:  10 * time.Millisecond,\n+\t\t\t},\n+\t\t})\n+\t\trequire.Error(t, err)\n+\t\trequire.ErrorContains(t, err, \"timed out\")\n+\t\ttracker.assertSeen(t, 5)\n \t})\n-\trequire.Error(t, err)\n-\trequire.ErrorContains(t, err, \"timed out\")\n }\n \n func TestRunIterationsWithTimeout(t *testing.T) {\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttime.Sleep(time.Millisecond * 20)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{\n-\t\t\tIterations: 5,\n-\t\t\tTimeout:    10 * time.Millisecond,\n-\t\t},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\t<-ctx.Done()\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{\n+\t\t\t\tIterations: 5,\n+\t\t\t\tTimeout:    10 * time.Millisecond,\n+\t\t\t},\n+\t\t})\n+\t\trequire.Error(t, err)\n+\t\trequire.ErrorContains(t, err, \"timed out\")\n+\t\ttracker.assertSeen(t, 2)\n \t})\n-\trequire.Error(t, err)\n-\trequire.ErrorContains(t, err, \"timed out\")\n }\n \n func TestRunDurationWithoutTimeout(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\tstartTime := time.Now()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\ttime.Sleep(time.Millisecond * 20)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{Duration: 1 * time.Millisecond},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\tstartTime := time.Now()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\ttime.Sleep(time.Millisecond * 20)\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{Duration: 1 * time.Millisecond},\n+\t\t})\n+\t\trequire.Equal(t, time.Millisecond*20, time.Since(startTime))\n+\t\trequire.NoError(t, err)\n+\t\ttracker.assertSeen(t, DefaultMaxConcurrent)\n \t})\n-\trequire.GreaterOrEqual(t, time.Since(startTime), time.Millisecond*20)\n-\trequire.NoError(t, err)\n-\ttracker.assertSeen(t, DefaultMaxConcurrent)\n }\n \n func TestRunIterationsWithoutTimeout(t *testing.T) {\n-\ttracker := newIterationTracker()\n-\tstartTime := time.Now()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\ttime.Sleep(time.Millisecond * 20)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{Iterations: 5},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\ttracker := newIterationTracker()\n+\t\tstartTime := time.Now()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\ttime.Sleep(time.Millisecond * 20)\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{Iterations: 5},\n+\t\t})\n+\t\trequire.Equal(t, time.Millisecond*20, time.Since(startTime))\n+\t\trequire.NoError(t, err)\n+\t\ttracker.assertSeen(t, 5)\n \t})\n-\trequire.GreaterOrEqual(t, time.Since(startTime), time.Millisecond*20)\n-\trequire.NoError(t, err)\n-\ttracker.assertSeen(t, 5)\n }\n \n func TestRunIterationsWithRateLimit(t *testing.T) {\n-\tstartTime := time.Now()\n-\ttracker := newIterationTracker()\n-\terr := execute(&GenericExecutor{\n-\t\tExecute: func(ctx context.Context, run *Run) error {\n-\t\t\ttracker.track(run.Iteration)\n-\t\t\treturn nil\n-\t\t},\n-\t\tDefaultConfiguration: RunConfiguration{\n-\t\t\tIterations:             4,\n-\t\t\tMaxConcurrent:          1,\n-\t\t\tMaxIterationsPerSecond: 4.0,\n-\t\t},\n+\tsynctest.Test(t, func(t *testing.T) {\n+\t\tstartTime := time.Now()\n+\t\ttracker := newIterationTracker()\n+\t\terr := execute(&GenericExecutor{\n+\t\t\tExecute: func(ctx context.Context, run *Run) error {\n+\t\t\t\ttracker.track(run.Iteration)\n+\t\t\t\treturn nil\n+\t\t\t},\n+\t\t\tDefaultConfiguration: RunConfiguration{\n+\t\t\t\tIterations:             4,\n+\t\t\t\tMaxConcurrent:          1,\n+\t\t\t\tMaxIterationsPerSecond: 4.0,\n+\t\t\t},\n+\t\t})\n+\t\trequire.NoError(t, err)\n+\t\trequire.Equal(t, time.Second, time.Since(startTime))\n+\t\ttracker.assertSeen(t, 4)\n \t})\n-\trequire.NoError(t, err)\n-\trequire.GreaterOrEqual(t, time.Since(startTime), time.Second)\n-\ttracker.assertSeen(t, 4)\n }"
    },
    {
      "filename": "versions.env",
      "status": "modified",
      "patch": "@@ -1,6 +1,6 @@\n # Tool versions\n DOTNET_VERSION=8.0.100\n-GO_VERSION=1.24.5\n+GO_VERSION=1.25.0\n GRADLE_VERSION=8.5\n JAVA_VERSION=11\n NODE_VERSION=22"
    },
    {
      "filename": "workers/go/go.mod",
      "status": "modified",
      "patch": "@@ -1,6 +1,6 @@\n module github.com/temporalio/omes/workers/go\n \n-go 1.24.5\n+go 1.25.0\n \n require github.com/temporalio/omes v1.0.0\n "
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}