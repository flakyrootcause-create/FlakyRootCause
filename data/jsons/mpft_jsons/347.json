{
  "id": 347,
  "repo": "elasticsearch",
  "issue_url": "https://github.com/elastic/elasticsearch/pull/114892",
  "pr_url": "https://github.com/elastic/elasticsearch/pull/114892",
  "issue_description": "Even with Kahan summation, we were occasionally getting floating point differences at the 14th decimal point, well beyond anything a GIS use case would care about.\r\n\r\nFixes #112461\r\nFixes #112463",
  "files_changed": [
    {
      "filename": "muted-tests.yml",
      "status": "modified",
      "patch": "@@ -94,12 +94,6 @@ tests:\n - class: org.elasticsearch.smoketest.DocsClientYamlTestSuiteIT\n   method: test {yaml=reference/rest-api/watcher/put-watch/line_120}\n   issue: https://github.com/elastic/elasticsearch/issues/99517\n-- class: org.elasticsearch.xpack.esql.expression.function.aggregate.SpatialCentroidTests\n-  method: \"testAggregateIntermediate {TestCase=<geo_point> #2}\"\n-  issue: https://github.com/elastic/elasticsearch/issues/112461\n-- class: org.elasticsearch.xpack.esql.expression.function.aggregate.SpatialCentroidTests\n-  method: testAggregateIntermediate {TestCase=<geo_point>}\n-  issue: https://github.com/elastic/elasticsearch/issues/112463\n - class: org.elasticsearch.xpack.esql.action.ManyShardsIT\n   method: testRejection\n   issue: https://github.com/elastic/elasticsearch/issues/112406"
    },
    {
      "filename": "x-pack/plugin/esql/src/test/java/org/elasticsearch/xpack/esql/expression/function/aggregate/SpatialCentroidTests.java",
      "status": "modified",
      "patch": "@@ -22,13 +22,15 @@\n import org.elasticsearch.xpack.esql.expression.function.FunctionName;\n import org.elasticsearch.xpack.esql.expression.function.MultiRowTestCaseSupplier;\n import org.elasticsearch.xpack.esql.expression.function.TestCaseSupplier;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n \n-import java.nio.ByteOrder;\n import java.util.List;\n import java.util.function.Supplier;\n import java.util.stream.Stream;\n \n-import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.closeTo;\n \n @FunctionName(\"st_centroid_agg\")\n public class SpatialCentroidTests extends AbstractAggregationTestCase {\n@@ -74,16 +76,58 @@ private static TestCaseSupplier makeSupplier(TestCaseSupplier.TypedDataSupplier\n                 count++;\n             }\n \n-            var expected = new BytesRef(\n-                WellKnownBinary.toWKB(new Point(xSum.value() / count, ySum.value() / count), ByteOrder.LITTLE_ENDIAN)\n-            );\n+            var expectedX = xSum.value() / count;\n+            var expectedY = ySum.value() / count;\n \n             return new TestCaseSupplier.TestCase(\n                 List.of(fieldTypedData),\n                 \"SpatialCentroid[field=Attribute[channel=0]]\",\n                 fieldTypedData.type(),\n-                equalTo(expected)\n+                centroidMatches(expectedX, expectedY, 1e-14)\n             );\n         });\n     }\n+\n+    @SuppressWarnings(\"SameParameterValue\")\n+    private static Matcher<BytesRef> centroidMatches(double x, double y, double error) {\n+        return new TestCentroidMatcher(x, y, error);\n+    }\n+\n+    private static class TestCentroidMatcher extends BaseMatcher<BytesRef> {\n+        private final double x;\n+        private final double y;\n+        private final Matcher<Double> mx;\n+        private final Matcher<Double> my;\n+\n+        private TestCentroidMatcher(double x, double y, double error) {\n+            this.x = x;\n+            this.y = y;\n+            this.mx = closeTo(x, error);\n+            this.my = closeTo(y, error);\n+        }\n+\n+        @Override\n+        public boolean matches(Object item) {\n+            if (item instanceof BytesRef wkb) {\n+                var point = (Point) WellKnownBinary.fromWKB(GeometryValidator.NOOP, false, wkb.bytes, wkb.offset, wkb.length);\n+                return mx.matches(point.getX()) && my.matches(point.getY());\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public void describeMismatch(Object item, Description description) {\n+            if (item instanceof BytesRef wkb) {\n+                var point = (Point) WellKnownBinary.fromWKB(GeometryValidator.NOOP, false, wkb.bytes, wkb.offset, wkb.length);\n+                description.appendText(\"was \").appendValue(point);\n+            } else {\n+                description.appendText(\"was \").appendValue(item);\n+            }\n+        }\n+\n+        @Override\n+        public void describeTo(Description description) {\n+            description.appendValue(\"    POINT (\" + x + \" \" + y + \")\");\n+        }\n+    }\n }"
    }
  ],
  "fix_category": "Make deterministic",
  "root_cause_category": "Floating point operations",
  "root_cause_subcategory": NaN
}