{
  "id": 204,
  "repo": "opennextjs-aws",
  "issue_url": "https://github.com/opennextjs/opennextjs-aws/pull/974",
  "pr_url": "https://github.com/opennextjs/opennextjs-aws/pull/974",
  "issue_description": "When you have a rewrite in middleware like this:\r\n```ts\r\nreturn NextResponse.rewrite(u, {\r\n  status: 403,\r\n});\r\n```\r\nThe rewrite status code is not propogated to the cache interceptor's responses when you have an external middleware. \r\n\r\nWe can also safely remove the `x-next-cache-tags` header on the response.\r\n\r\nI did update some tests that were flakey aswell. We need to register the event listener before the navigation.",
  "files_changed": [
    {
      "filename": ".changeset/angry-ways-approve.md",
      "status": "added",
      "patch": "@@ -0,0 +1,5 @@\n+---\n+\"@opennextjs/aws\": patch\n+---\n+\n+fix: Ensure middleware rewrite status code is properly propagated to cache interceptor"
    },
    {
      "filename": "packages/open-next/src/adapters/middleware.ts",
      "status": "modified",
      "patch": "@@ -125,7 +125,10 @@ const defaultHandler = async (\n         }\n       }\n \n-      result.headers[INTERNAL_EVENT_REQUEST_ID] = requestId;\n+      if (process.env.OPEN_NEXT_REQUEST_ID_HEADER || globalThis.openNextDebug) {\n+        result.headers[INTERNAL_EVENT_REQUEST_ID] = requestId;\n+      }\n+\n       debug(\"Middleware response\", result);\n       return result;\n     },"
    },
    {
      "filename": "packages/open-next/src/core/requestHandler.ts",
      "status": "modified",
      "patch": "@@ -63,7 +63,7 @@ export async function openNextHandler(\n       }\n       debug(\"internalEvent\", internalEvent);\n \n-      // These 2 will get overwritten by the routing handler if not using an external middleware\n+      // These 3 will get overwritten by the routing handler if not using an external middleware\n       const internalHeaders = {\n         initialPath:\n           initialHeaders[INTERNAL_HEADER_INITIAL_URL] ?? internalEvent.rawPath,"
    },
    {
      "filename": "packages/open-next/src/core/routing/cacheInterceptor.ts",
      "status": "modified",
      "patch": "@@ -1,7 +1,11 @@\n import { createHash } from \"node:crypto\";\n \n import { NextConfig, PrerenderManifest } from \"config/index\";\n-import type { InternalEvent, InternalResult } from \"types/open-next\";\n+import type {\n+  InternalEvent,\n+  InternalResult,\n+  MiddlewareEvent,\n+} from \"types/open-next\";\n import type { CacheValue } from \"types/overrides\";\n import { emptyReadableStream, toReadableStream } from \"utils/stream\";\n \n@@ -100,7 +104,7 @@ async function computeCacheControl(\n }\n \n async function generateResult(\n-  event: InternalEvent,\n+  event: MiddlewareEvent,\n   localizedPath: string,\n   cachedValue: CacheValue<\"cache\">,\n   lastModified?: number,\n@@ -132,8 +136,12 @@ async function generateResult(\n   );\n   return {\n     type: \"core\",\n-    // sometimes other status codes can be cached, like 404. For these cases, we should return the correct status code\n-    statusCode: cachedValue.meta?.status ?? 200,\n+    // Sometimes other status codes can be cached, like 404. For these cases, we should return the correct status code\n+    // Also set the status code to the rewriteStatusCode if defined\n+    // This can happen in handleMiddleware in routingHandler.\n+    // `NextResponse.rewrite(url, { status: xxx})\n+    // The rewrite status code should take precedence over the cached one\n+    statusCode: event.rewriteStatusCode ?? cachedValue.meta?.status ?? 200,\n     body: toReadableStream(body, false),\n     isBase64Encoded: false,\n     headers: {\n@@ -179,7 +187,7 @@ function decodePathParams(pathname: string): string {\n }\n \n export async function cacheInterceptor(\n-  event: InternalEvent,\n+  event: MiddlewareEvent,\n ): Promise<InternalEvent | InternalResult> {\n   if (\n     Boolean(event.headers[\"next-action\"]) ||\n@@ -287,7 +295,8 @@ export async function cacheInterceptor(\n \n           return {\n             type: \"core\",\n-            statusCode: cachedData.value.meta?.status ?? 200,\n+            statusCode:\n+              event.rewriteStatusCode ?? cachedData.value.meta?.status ?? 200,\n             body: toReadableStream(cachedData.value.body, isBinary),\n             headers: {\n               ...cacheControl,"
    },
    {
      "filename": "packages/open-next/src/core/routing/middleware.ts",
      "status": "modified",
      "patch": "@@ -6,7 +6,11 @@ import {\n   NextConfig,\n   PrerenderManifest,\n } from \"config/index.js\";\n-import type { InternalEvent, InternalResult } from \"types/open-next.js\";\n+import type {\n+  InternalEvent,\n+  InternalResult,\n+  MiddlewareEvent,\n+} from \"types/open-next.js\";\n import { emptyReadableStream } from \"utils/stream.js\";\n \n import { getQueryFromSearchParams } from \"../../overrides/converters/utils.js\";\n@@ -28,12 +32,6 @@ const middleMatch = getMiddlewareMatch(\n \n const REDIRECTS = new Set([301, 302, 303, 307, 308]);\n \n-type MiddlewareEvent = InternalEvent & {\n-  responseHeaders?: Record<string, string | string[]>;\n-  isExternalRewrite?: boolean;\n-  rewriteStatusCode?: number;\n-};\n-\n type Middleware = (request: Request) => Response | Promise<Response>;\n type MiddlewareLoader = () => Promise<{ default: Middleware }>;\n \n@@ -198,6 +196,7 @@ export async function handleMiddleware(\n     cookies: internalEvent.cookies,\n     remoteAddress: internalEvent.remoteAddress,\n     isExternalRewrite,\n-    rewriteStatusCode: statusCode,\n+    rewriteStatusCode:\n+      rewriteUrl && !isExternalRewrite ? statusCode : undefined,\n   } satisfies MiddlewareEvent;\n }"
    },
    {
      "filename": "packages/open-next/src/types/open-next.ts",
      "status": "modified",
      "patch": "@@ -32,6 +32,12 @@ export type InternalEvent = {\n   readonly remoteAddress: string;\n } & BaseEventOrResult<\"core\">;\n \n+export type MiddlewareEvent = InternalEvent & {\n+  responseHeaders?: Record<string, string | string[]>;\n+  isExternalRewrite?: boolean;\n+  rewriteStatusCode?: number;\n+};\n+\n export type InternalResult = {\n   statusCode: number;\n   headers: Record<string, string | string[]>;"
    },
    {
      "filename": "packages/open-next/src/utils/cache.ts",
      "status": "modified",
      "patch": "@@ -39,7 +39,10 @@ export function getTagsFromValue(value?: CacheValue<\"cache\">) {\n   }\n   // The try catch is necessary for older version of next.js that may fail on this\n   try {\n-    return value.meta?.headers?.[\"x-next-cache-tags\"]?.split(\",\") ?? [];\n+    const cacheTags =\n+      value.meta?.headers?.[\"x-next-cache-tags\"]?.split(\",\") ?? [];\n+    delete value.meta?.headers?.[\"x-next-cache-tags\"];\n+    return cacheTags;\n   } catch (e) {\n     return [];\n   }"
    },
    {
      "filename": "packages/tests-e2e/tests/appRouter/middleware.rewrite.test.ts",
      "status": "modified",
      "patch": "@@ -23,21 +23,25 @@ test(\"Middleware Rewrite\", async ({ page }) => {\n });\n \n test(\"Middleware Rewrite External Image\", async ({ page }) => {\n-  await page.goto(\"/rewrite-external\");\n   page.on(\"response\", async (response) => {\n     expect(response.status()).toBe(200);\n     expect(response.headers()[\"content-type\"]).toBe(\"image/png\");\n     expect(response.headers()[\"cache-control\"]).toBe(\"max-age=600\");\n     const bodyBuffer = await response.body();\n     expect(validateMd5(bodyBuffer, OPENNEXT_PNG_MD5)).toBe(true);\n   });\n+  await page.goto(\"/rewrite-external\");\n });\n \n test(\"Middleware Rewrite Status Code\", async ({ page }) => {\n+  page.on(\"response\", async (response) => {\n+    // Need to set up the event before navigating to the page to avoid missing it\n+    // We need to check the URL here also cause there will be multiple responses (i.e the fonts, css, js, etc)\n+    if (response.url() === \"/rewrite-status-code\") {\n+      expect(response.status()).toBe(403);\n+    }\n+  });\n   await page.goto(\"/rewrite-status-code\");\n   const el = page.getByText(\"Rewritten Destination\", { exact: true });\n   await expect(el).toBeVisible();\n-  page.on(\"response\", async (response) => {\n-    expect(response.status()).toBe(403);\n-  });\n });"
    },
    {
      "filename": "packages/tests-unit/tests/core/routing/cacheInterceptor.test.ts",
      "status": "modified",
      "patch": "@@ -1,7 +1,7 @@\n /* eslint-disable sonarjs/no-duplicate-string */\n import { cacheInterceptor } from \"@opennextjs/aws/core/routing/cacheInterceptor.js\";\n import { convertFromQueryString } from \"@opennextjs/aws/core/routing/util.js\";\n-import type { InternalEvent } from \"@opennextjs/aws/types/open-next.js\";\n+import type { MiddlewareEvent } from \"@opennextjs/aws/types/open-next.js\";\n import type { Queue } from \"@opennextjs/aws/types/overrides.js\";\n import { fromReadableStream } from \"@opennextjs/aws/utils/stream.js\";\n import { vi } from \"vitest\";\n@@ -26,14 +26,14 @@ vi.mock(\"@opennextjs/aws/adapters/config/index.js\", () => ({\n }));\n \n vi.mock(\"@opennextjs/aws/core/routing/i18n/index.js\", () => ({\n-  localizePath: (event: InternalEvent) => event.rawPath,\n+  localizePath: (event: MiddlewareEvent) => event.rawPath,\n }));\n \n type PartialEvent = Partial<\n-  Omit<InternalEvent, \"body\" | \"rawPath\" | \"query\">\n+  Omit<MiddlewareEvent, \"body\" | \"rawPath\" | \"query\">\n > & { body?: string };\n \n-function createEvent(event: PartialEvent): InternalEvent {\n+function createEvent(event: PartialEvent): MiddlewareEvent {\n   const [rawPath, qs] = (event.url ?? \"/\").split(\"?\", 2);\n   return {\n     type: \"core\",\n@@ -45,6 +45,7 @@ function createEvent(event: PartialEvent): InternalEvent {\n     query: convertFromQueryString(qs ?? \"\"),\n     cookies: event.cookies ?? {},\n     remoteAddress: event.remoteAddress ?? \"::1\",\n+    rewriteStatusCode: event.rewriteStatusCode,\n   };\n }\n \n@@ -452,4 +453,72 @@ describe(\"cacheInterceptor\", () => {\n       }),\n     );\n   });\n+\n+  it(\"should return the rewrite status code when there is active cache\", async () => {\n+    const event = createEvent({\n+      url: \"/albums\",\n+      rewriteStatusCode: 403,\n+    });\n+    incrementalCache.get.mockResolvedValueOnce({\n+      value: {\n+        type: \"app\",\n+        html: \"Hello, world!\",\n+      },\n+    });\n+\n+    const result = await cacheInterceptor(event);\n+    expect(result.statusCode).toBe(403);\n+  });\n+\n+  it(\"should return the rewriteStatusCode if there is a cached status code\", async () => {\n+    const event = createEvent({\n+      url: \"/albums\",\n+      rewriteStatusCode: 203,\n+    });\n+    incrementalCache.get.mockResolvedValueOnce({\n+      value: {\n+        type: \"app\",\n+        html: \"Hello, world!\",\n+        meta: {\n+          status: 404,\n+        },\n+      },\n+    });\n+\n+    const result = await cacheInterceptor(event);\n+    expect(result.statusCode).toBe(203);\n+  });\n+\n+  it(\"should return the cached status code if there is one\", async () => {\n+    const event = createEvent({\n+      url: \"/albums\",\n+    });\n+    incrementalCache.get.mockResolvedValueOnce({\n+      value: {\n+        type: \"app\",\n+        html: \"Hello, world!\",\n+        meta: {\n+          status: 405,\n+        },\n+      },\n+    });\n+\n+    const result = await cacheInterceptor(event);\n+    expect(result.statusCode).toBe(405);\n+  });\n+\n+  it(\"should return 200 if there is no cached status code, nor a rewriteStatusCode\", async () => {\n+    const event = createEvent({\n+      url: \"/albums\",\n+    });\n+    incrementalCache.get.mockResolvedValueOnce({\n+      value: {\n+        type: \"app\",\n+        html: \"Hello, world!\",\n+      },\n+    });\n+\n+    const result = await cacheInterceptor(event);\n+    expect(result.statusCode).toBe(200);\n+  });\n });"
    }
  ],
  "fix_category": "Reorder execution",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}