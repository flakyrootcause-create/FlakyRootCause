{
  "id": 107,
  "repo": "kafka",
  "issue_url": "https://github.com/apache/kafka/pull/20225",
  "pr_url": "https://github.com/apache/kafka/pull/20225",
  "issue_description": "### Problem\nThe\n`ShareGroupCommandTest.testDeleteShareGroupOffsetsArgsWithoutTopic()`,\n`ShareGroupCommandTest.testDeleteShareGroupOffsetsArgsWithoutGroup()`,\n`ResetStreamsGroupOffsetTest.testResetOffsetsWithoutGroupOption()`,\n`DeleteStreamsGroupTest.testDeleteWithoutGroupOption()`,\n`DescribeStreamsGroupTest.testDescribeWithoutGroupOption()` tests were\nflaky due to a dependency on Set iteration order in error message\ngeneration.\n\n### Root Cause\nThe cleanup [commit](https://github.com/apache/kafka/pull/20091) that\nreplaced `new HashSet<>(Arrays.asList(...))` with `Set.of(...)` in\nShareGroupCommandOptions and StreamsGroupCommandOptions changed the\niteration characteristics of collections used for error message\ngeneration:\n\nThis produces different orders like `[topic], [group]` vs `[group],\n[topic]`, but the tests expected a specific order, causing intermittent\nfailures.\n\n### Solution\nFix the root cause by ensuring deterministic error message generation\nthrough alphabetical sorting of option names.\n\nReviewers: ShivsundarR <shr@confluent.io>, Ken Huang\n <s7133700@gmail.com>, TengYao Chi <frankvicky@apache.org>\n",
  "files_changed": [
    {
      "filename": "tools/src/main/java/org/apache/kafka/tools/consumer/group/ShareGroupCommandOptions.java",
      "status": "modified",
      "patch": "@@ -159,11 +159,11 @@ public void checkArgs() {\n         if (options.has(describeOpt)) {\n             if (!options.has(groupOpt) && !options.has(allGroupsOpt))\n                 CommandLineUtils.printUsageAndExit(parser,\n-                    \"Option \" + describeOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                    \"Option \" + describeOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n             List<OptionSpec<?>> mutuallyExclusiveOpts = List.of(membersOpt, offsetsOpt, stateOpt);\n             if (mutuallyExclusiveOpts.stream().mapToInt(o -> options.has(o) ? 1 : 0).sum() > 1) {\n                 CommandLineUtils.printUsageAndExit(parser,\n-                    \"Option \" + describeOpt + \" takes at most one of these options: \" + mutuallyExclusiveOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                    \"Option \" + describeOpt + \" takes at most one of these options: \" + mutuallyExclusiveOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n             }\n             if (options.has(stateOpt) && options.valueOf(stateOpt) != null)\n                 CommandLineUtils.printUsageAndExit(parser,\n@@ -185,7 +185,7 @@ public void checkArgs() {\n         if (options.has(deleteOffsetsOpt)) {\n             if (!options.has(groupOpt) || !options.has(topicOpt))\n                 CommandLineUtils.printUsageAndExit(parser,\n-                    \"Option \" + deleteOffsetsOpt + \" takes the following options: \" + allDeleteOffsetsOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                    \"Option \" + deleteOffsetsOpt + \" takes the following options: \" + allDeleteOffsetsOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n         }\n \n         if (options.has(resetOffsetsOpt)) {"
    },
    {
      "filename": "tools/src/main/java/org/apache/kafka/tools/streams/StreamsGroupCommandOptions.java",
      "status": "modified",
      "patch": "@@ -222,7 +222,7 @@ void checkArgs() {\n         if (options.has(deleteOpt)) {\n             if (!options.has(groupOpt) && !options.has(allGroupsOpt))\n                 CommandLineUtils.printUsageAndExit(parser,\n-                    \"Option \" + deleteOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                    \"Option \" + deleteOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n             if (options.has(inputTopicOpt) || options.has(allInputTopicsOpt))\n                 CommandLineUtils.printUsageAndExit(parser, \"Kafka Streams does not support topic-specific offset \" +\n                     \"deletion from a streams group.\");\n@@ -253,11 +253,11 @@ private void checkDescribeArgs() {\n \n         if (!options.has(groupOpt) && !options.has(allGroupsOpt))\n             CommandLineUtils.printUsageAndExit(parser,\n-                \"Option \" + describeOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                \"Option \" + describeOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n         List<OptionSpec<?>> mutuallyExclusiveOpts = List.of(membersOpt, offsetsOpt, stateOpt);\n         if (mutuallyExclusiveOpts.stream().mapToInt(o -> options.has(o) ? 1 : 0).sum() > 1) {\n             CommandLineUtils.printUsageAndExit(parser,\n-                \"Option \" + describeOpt + \" takes at most one of these options: \" + mutuallyExclusiveOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                \"Option \" + describeOpt + \" takes at most one of these options: \" + mutuallyExclusiveOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n         }\n         if (options.has(stateOpt) && options.valueOf(stateOpt) != null)\n             CommandLineUtils.printUsageAndExit(parser,\n@@ -267,7 +267,7 @@ private void checkDescribeArgs() {\n     private void checkDeleteOffsetsArgs() {\n         if ((!options.has(inputTopicOpt) && !options.has(allInputTopicsOpt)) || !options.has(groupOpt))\n             CommandLineUtils.printUsageAndExit(parser,\n-                \"Option \" + deleteOffsetsOpt + \" takes the \" + groupOpt + \" and one of these options: \" + allDeleteOffsetsOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                \"Option \" + deleteOffsetsOpt + \" takes the \" + groupOpt + \" and one of these options: \" + allDeleteOffsetsOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n         if (options.valuesOf(groupOpt).size() > 1)\n             CommandLineUtils.printUsageAndExit(parser,\n                 \"Option \" + deleteOffsetsOpt + \" supports only one \" + groupOpt + \" at a time, but found: \" + options.valuesOf(groupOpt));\n@@ -286,7 +286,7 @@ private void checkOffsetResetArgs() {\n \n         if (!options.has(groupOpt) && !options.has(allGroupsOpt))\n             CommandLineUtils.printUsageAndExit(parser,\n-                \"Option \" + resetOffsetsOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                \"Option \" + resetOffsetsOpt + \" takes one of these options: \" + allGroupSelectionScopeOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n \n         CommandLineUtils.checkInvalidArgs(parser, options, resetToOffsetOpt, minus(allResetOffsetScenarioOpts, resetToOffsetOpt));\n         CommandLineUtils.checkInvalidArgs(parser, options, resetToDatetimeOpt, minus(allResetOffsetScenarioOpts, resetToDatetimeOpt));\n@@ -301,7 +301,7 @@ private void checkOffsetResetArgs() {\n     private void checkDeleteAllInternalTopicsArgs() {\n         if (!options.has(resetOffsetsOpt) && !options.has(deleteOpt)) {\n             CommandLineUtils.printUsageAndExit(parser,\n-                \"Option \" + deleteAllInternalTopicsOpt + \" takes one of these options: \" + allDeleteInternalGroupsOpts.stream().map(Object::toString).collect(Collectors.joining(\", \")));\n+                \"Option \" + deleteAllInternalTopicsOpt + \" takes one of these options: \" + allDeleteInternalGroupsOpts.stream().map(Object::toString).sorted().collect(Collectors.joining(\", \")));\n         } else if (options.has(resetOffsetsOpt) && !options.has(executeOpt)) {\n             CommandLineUtils.printUsageAndExit(parser,\n                 \"Option \" + deleteAllInternalTopicsOpt + \" takes \" + executeOpt + \" when \" + resetOffsetsOpt + \" is used.\");"
    },
    {
      "filename": "tools/src/test/java/org/apache/kafka/tools/consumer/group/ShareGroupCommandTest.java",
      "status": "modified",
      "patch": "@@ -626,7 +626,7 @@ public void testDeleteShareGroupOffsetsArgsWithoutTopic() {\n         AtomicBoolean exited = new AtomicBoolean(false);\n         Exit.setExitProcedure(((statusCode, message) -> {\n             assertNotEquals(0, statusCode);\n-            assertTrue(message.contains(\"Option [delete-offsets] takes the following options: [topic], [group]\"));\n+            assertTrue(message.contains(\"Option [delete-offsets] takes the following options: [group], [topic]\"));\n             exited.set(true);\n         }));\n         try {\n@@ -646,7 +646,7 @@ public void testDeleteShareGroupOffsetsArgsWithoutGroup() {\n         AtomicBoolean exited = new AtomicBoolean(false);\n         Exit.setExitProcedure(((statusCode, message) -> {\n             assertNotEquals(0, statusCode);\n-            assertTrue(message.contains(\"Option [delete-offsets] takes the following options: [topic], [group]\"));\n+            assertTrue(message.contains(\"Option [delete-offsets] takes the following options: [group], [topic]\"));\n             exited.set(true);\n         }));\n         try {"
    }
  ],
  "fix_category": "Other",
  "root_cause_category": "Unordered collections",
  "root_cause_subcategory": NaN
}