{
  "id": 313,
  "repo": "kafka",
  "issue_url": "https://github.com/apache/kafka/pull/20509",
  "pr_url": "https://github.com/apache/kafka/pull/20509",
  "issue_description": "This improves the SmokeTestDriverIntegrationTest in three ways:\n\n1) If a SmokeTestClient fails (enters a terminal ERROR state), the\nSmokeTestDriverIntegrationTest currently times out, because it keeps\nwaiting for state NOT_RUNNING. This makes debugging quite difficult.\nThis minor  change makes sure to just fail the test immediately, if a\nSmokeTestClient enters the ERROR state.\n\n2) If a test times out or fails prematurely, because a SmokeTestClient\ncrashed, the SmokeTestClients aren't shut down correctly, which will\naffect the following test runs. Therefore, I am adding clean-up logic\nthat running SmokeTestClients in `@AfterAll`.\n\n3) Finally, I found that the processingThread variation of this thread\ntriggers a subtle race condition. Since this features is currently not\nactively developed, I disabled those variations and created a ticket to\nreactivate the test.\n\nReviewers: Matthias J. Sax <matthias@confluent.io>, Chia-Ping Tsai\n <chia7712@gmail.com>, Bill Bejeck <bill@confluent.io>\n",
  "files_changed": [
    {
      "filename": "streams/integration-tests/src/test/java/org/apache/kafka/streams/integration/SmokeTestDriverIntegrationTest.java",
      "status": "modified",
      "patch": "@@ -27,6 +27,7 @@\n import org.apache.kafka.streams.tests.SmokeTestDriver;\n \n import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Tag;\n@@ -46,29 +47,43 @@\n import static org.apache.kafka.streams.tests.SmokeTestDriver.generate;\n import static org.apache.kafka.streams.tests.SmokeTestDriver.verify;\n import static org.apache.kafka.streams.utils.TestUtils.safeUniqueTestName;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n @Timeout(600)\n @Tag(\"integration\")\n public class SmokeTestDriverIntegrationTest {\n-    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+    private static EmbeddedKafkaCluster cluster = null;\n     public TestInfo testInfo;\n+    private ArrayList<SmokeTestClient> clients = new ArrayList<>();\n \n     @BeforeAll\n     public static void startCluster() throws IOException {\n-        CLUSTER.start();\n+        cluster = new EmbeddedKafkaCluster(3);\n+        cluster.start();\n     }\n \n     @AfterAll\n     public static void closeCluster() {\n-        CLUSTER.stop();\n+        cluster.stop();\n+        cluster = null;\n     }\n \n     @BeforeEach\n     public void setUp(final TestInfo testInfo) {\n         this.testInfo = testInfo;\n     }\n \n+    @AfterEach\n+    public void shutDown(final TestInfo testInfo) {\n+        // Clean up clients in case the test failed or timed out\n+        for (final SmokeTestClient client : clients) {\n+            if (!client.closed() && !client.error()) {\n+                client.close();\n+            }\n+        }\n+    }\n+\n     private static class Driver extends Thread {\n         private final String bootstrapServers;\n         private final int numKeys;\n@@ -108,12 +123,11 @@ SmokeTestDriver.VerificationResult result() {\n     // During the new stream added and old stream left, the stream process should still complete without issue.\n     // We set 2 timeout condition to fail the test before passing the verification:\n     // (1) 10 min timeout, (2) 30 tries of polling without getting any data\n+    // The processing thread variations where disabled since they triggered a race condition, see KAFKA-19696\n     @ParameterizedTest\n     @CsvSource({\n         \"false, true\",\n-        \"false, false\",\n-        \"true, true\",\n-        \"true, false\"\n+        \"false, false\"\n     })\n     public void shouldWorkWithRebalance(\n         final boolean processingThreadsEnabled,\n@@ -126,11 +140,10 @@ public void shouldWorkWithRebalance(\n             throw new AssertionError(\"Test called halt(). code:\" + statusCode + \" message:\" + message);\n         });\n         int numClientsCreated = 0;\n-        final ArrayList<SmokeTestClient> clients = new ArrayList<>();\n \n-        IntegrationTestUtils.cleanStateBeforeTest(CLUSTER, SmokeTestDriver.topics());\n+        IntegrationTestUtils.cleanStateBeforeTest(cluster, SmokeTestDriver.topics());\n \n-        final String bootstrapServers = CLUSTER.bootstrapServers();\n+        final String bootstrapServers = cluster.bootstrapServers();\n         final Driver driver = new Driver(bootstrapServers, 10, 1000);\n         driver.start();\n         System.out.println(\"started driver\");\n@@ -144,8 +157,8 @@ public void shouldWorkWithRebalance(\n         if (streamsProtocolEnabled) {\n             props.put(StreamsConfig.GROUP_PROTOCOL_CONFIG, GroupProtocol.STREAMS.name().toLowerCase(Locale.getDefault()));\n             // decrease the session timeout so that we can trigger the rebalance soon after old client left closed\n-            CLUSTER.setGroupSessionTimeout(appId, 10000);\n-            CLUSTER.setGroupHeartbeatTimeout(appId, 1000);\n+            cluster.setGroupSessionTimeout(appId, 10000);\n+            cluster.setGroupHeartbeatTimeout(appId, 1000);\n         } else {\n             // decrease the session timeout so that we can trigger the rebalance soon after old client left closed\n             props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 10000);\n@@ -167,6 +180,7 @@ public void shouldWorkWithRebalance(\n \n                 client.closeAsync();\n                 while (!client.closed()) {\n+                    assertFalse(client.error(), \"The streams application seems to have crashed.\");\n                     Thread.sleep(100);\n                 }\n             }\n@@ -184,6 +198,7 @@ public void shouldWorkWithRebalance(\n             // then, wait for them to stop\n             for (final SmokeTestClient client : clients) {\n                 while (!client.closed()) {\n+                    assertFalse(client.error(), \"The streams application seems to have crashed.\");\n                     Thread.sleep(100);\n                 }\n             }"
    },
    {
      "filename": "streams/src/test/java/org/apache/kafka/streams/tests/SmokeTestClient.java",
      "status": "modified",
      "patch": "@@ -54,6 +54,7 @@ public class SmokeTestClient extends SmokeTestUtil {\n     private KafkaStreams streams;\n     private boolean uncaughtException = false;\n     private volatile boolean closed;\n+    private volatile boolean error;\n \n     private static void addShutdownHook(final String name, final Runnable runnable) {\n         if (name != null) {\n@@ -71,6 +72,10 @@ public boolean closed() {\n         return closed;\n     }\n \n+    public boolean error() {\n+        return error;\n+    }\n+\n     public void start(final Properties streamsProperties) {\n         final Topology build = getTopology();\n         streams = new KafkaStreams(build, getStreamsConfig(streamsProperties));\n@@ -85,6 +90,10 @@ public void start(final Properties streamsProperties) {\n             if (newState == KafkaStreams.State.NOT_RUNNING) {\n                 closed = true;\n             }\n+\n+            if (newState == KafkaStreams.State.ERROR) {\n+                error = true;\n+            }\n         });\n \n         streams.setUncaughtExceptionHandler(e -> {"
    }
  ],
  "fix_category": "Make structure thread local",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": NaN
}