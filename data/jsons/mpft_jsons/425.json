{
  "id": 425,
  "repo": "kubernetes",
  "issue_url": "https://github.com/kubernetes/kubernetes/pull/133267",
  "pr_url": "https://github.com/kubernetes/kubernetes/pull/133267",
  "issue_description": "#### What type of PR is this?\r\n/kind bug\r\n/kind flake\r\n\r\n#### What this PR does / why we need it:\r\nFixes flakiness in `[sig-network] Proxy version v1 should proxy through a service and a pod [Conformance]` caused by the changes in #129837.\r\n\r\nThe test is kind of badly written. (It's old.) It required that as soon as it became aware that the Service and its Endpoints/EndpointSlice had been updated, that the apiserver proxying codepath must _also_ be aware of them, and must _immediately_ be able to proxy connections to the service, and if not, then the test fails. Apparently it was flaky even before the changes. But #129837 made things much worse because [now the proxying codepath uses an informer and a lister rather than using a client directly](https://github.com/kubernetes/kubernetes/pull/129837#discussion_r2001237237), so it's much more possible for the apiserver proxy code to have not noticed the Service/EndpointSlice yet at the point when e2e.test has noticed it.\r\n\r\nAnyway, fix is just to poll for the apiserver to be ready before we start.\r\n\r\nOh, also, the conformance description of the test was _completely_ wrong. It looks like when the conformance comments were added, someone copied the description of the wrong test? So I fixed that too.\r\n\r\n(Also, update to use the new `e2eendpointslice.WaitForEndpointCount`.)\r\n\r\n#### Which issue(s) this PR is related to:\r\nFixes #133257\r\n\r\n#### Does this PR introduce a user-facing change?\r\n```release-note\r\nNONE\r\n```\r\n\r\n/sig network\r\n/priority important-soon\r\n/triage accepted\r\n/milestone v1.34",
  "files_changed": [
    {
      "filename": "test/conformance/testdata/conformance.yaml",
      "status": "modified",
      "patch": "@@ -1867,11 +1867,10 @@\n     MUST be returned for each endpoint.\n   release: v1.21\n   file: test/e2e/network/proxy.go\n-- testname: Proxy, logs service endpoint\n+- testname: Proxy through apiserver to a Service\n   codename: '[sig-network] Proxy version v1 should proxy through a service and a pod\n     [Conformance]'\n-  description: Select any node in the cluster to invoke  /logs endpoint  using the\n-    /nodes/proxy subresource from the kubelet port. This endpoint MUST be reachable.\n+  description: The apiserver will proxy a connection to a Service.\n   release: v1.9\n   file: test/e2e/network/proxy.go\n - testname: Service endpoint latency, thresholds"
    },
    {
      "filename": "test/e2e/network/proxy.go",
      "status": "modified",
      "patch": "@@ -39,6 +39,7 @@ import (\n \t\"k8s.io/client-go/transport\"\n \t\"k8s.io/kubernetes/test/e2e/framework\"\n \te2edeployment \"k8s.io/kubernetes/test/e2e/framework/deployment\"\n+\te2eendpointslice \"k8s.io/kubernetes/test/e2e/framework/endpointslice\"\n \te2enode \"k8s.io/kubernetes/test/e2e/framework/node\"\n \te2epod \"k8s.io/kubernetes/test/e2e/framework/pod\"\n \te2eservice \"k8s.io/kubernetes/test/e2e/framework/service\"\n@@ -91,12 +92,10 @@ var _ = common.SIGDescribe(\"Proxy\", func() {\n \t\t*/\n \t\tginkgo.It(\"should proxy logs on node using proxy subresource \", func(ctx context.Context) { nodeProxyTest(ctx, f, prefix+\"/nodes/\", \"/proxy/logs/\") })\n \n-\t\t// using the porter image to serve content, access the content\n-\t\t// (of multiple pods?) from multiple (endpoints/services?)\n \t\t/*\n \t\t\tRelease: v1.9\n-\t\t\tTestname: Proxy, logs service endpoint\n-\t\t\tDescription: Select any node in the cluster to invoke  /logs endpoint  using the /nodes/proxy subresource from the kubelet port. This endpoint MUST be reachable.\n+\t\t\tTestname: Proxy through apiserver to a Service\n+\t\t\tDescription: The apiserver will proxy a connection to a Service.\n \t\t*/\n \t\tframework.ConformanceIt(\"should proxy through a service and a pod\", func(ctx context.Context) {\n \t\t\tstart := time.Now()\n@@ -133,7 +132,7 @@ var _ = common.SIGDescribe(\"Proxy\", func() {\n \t\t\t}, metav1.CreateOptions{})\n \t\t\tframework.ExpectNoError(err)\n \n-\t\t\t// Make a deployment with a single pod. The 'porter' image is\n+\t\t\t// Make a deployment with a single pod. 'agnhost porter' is\n \t\t\t// a simple server which serves the values of the\n \t\t\t// environmental variables below.\n \t\t\tginkgo.By(\"starting an echo server on multiple ports\")\n@@ -223,7 +222,7 @@ var _ = common.SIGDescribe(\"Proxy\", func() {\n \t\t\tframework.ExpectNoError(err)\n \t\t\tpods := podList.Items\n \n-\t\t\terr = framework.WaitForServiceEndpointsNum(ctx, f.ClientSet, f.Namespace.Name, service.Name, 1, time.Second, e2eservice.ServiceEndpointsTimeout)\n+\t\t\terr = e2eendpointslice.WaitForEndpointCount(ctx, f.ClientSet, f.Namespace.Name, service.Name, 1)\n \t\t\tframework.ExpectNoError(err)\n \n \t\t\t// table constructors\n@@ -261,6 +260,16 @@ var _ = common.SIGDescribe(\"Proxy\", func() {\n \t\t\t\t// podPrefix + \":dest2\": \"bar\",\n \t\t\t}\n \n+\t\t\t// Poll until the apiserver is aware of the service and its endpoints,\n+\t\t\t// before starting the main part of the test.\n+\t\t\tpollTestPath := subresourceServiceProxyURL(\"\", \"portname1\") + \"/\"\n+\t\t\tpollTestBody := \"foo\"\n+\t\t\terr = wait.PollUntilContextTimeout(ctx, time.Second, e2eservice.ServiceEndpointsTimeout, true, func(ctx context.Context) (bool, error) {\n+\t\t\t\tbody, _, _, _ := doProxy(ctx, f, pollTestPath, 0)\n+\t\t\t\treturn string(body) == pollTestBody, nil\n+\t\t\t})\n+\t\t\tframework.ExpectNoError(err, \"Unable to reach service through proxy\")\n+\n \t\t\twg := sync.WaitGroup{}\n \t\t\terrs := []string{}\n \t\t\terrLock := sync.Mutex{}"
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}