{
  "id": 94,
  "repo": "ravendb",
  "issue_url": "https://github.com/ravendb/ravendb/commit/4223f2492229b0dfb1b5ac4b334ce72834308f4e",
  "pr_url": "https://github.com/ravendb/ravendb/commit/4223f2492229b0dfb1b5ac4b334ce72834308f4e",
  "issue_description": "",
  "files_changed": [
    {
      "filename": "src/Raven.Server/Commercial/SetupInfo.cs",
      "status": "modified",
      "patch": "@@ -1,18 +1,25 @@\n-\ufeffusing System.Collections.Generic;\n+\ufeffusing System;\n+using System.Collections.Concurrent;\n+using System.Collections.Generic;\n using System.Linq;\n using Raven.Client.Documents.Operations;\n using Raven.Client.Util;\n+using Sparrow.Json;\n using Sparrow.Json.Parsing;\n+using Sparrow.Logging;\n \n namespace Raven.Server.Commercial\n {\n-    public class SecuredSetupInfo\n+    public class SetupInfo\n     {\n         public License License { get; set; }\n         public string Email { get; set; }\n         public string Domain { get; set; }\n-        public string Challenge { get; set; }\n-        public List<NodeInfo> NodeSetupInfos { get; set; }\n+        public bool ModifyLocalServer { get; set; }\n+        public string Certificate { get; set; }\n+        public string Password { get; set; }\n+\n+        public Dictionary<string, NodeInfo> NodeSetupInfos { get; set; }\n         \n         public DynamicJsonValue ToJson()\n         {\n@@ -21,33 +28,26 @@ public DynamicJsonValue ToJson()\n                 [nameof(License)] = License.ToJson(),\n                 [nameof(Email)] = Email,\n                 [nameof(Domain)] = Domain,\n-                [nameof(Challenge)] = Challenge,\n-                [nameof(NodeSetupInfos)] = NodeSetupInfos.Select(node => node.ToJson()).ToArray()\n+                [nameof(ModifyLocalServer)] = ModifyLocalServer,\n+                [nameof(Certificate)] = Certificate,\n+                [nameof(Password)] = Password,\n+                [nameof(NodeSetupInfos)] = DynamicJsonValue.Convert(NodeSetupInfos)\n             };\n         }\n \n         public class NodeInfo\n         {\n-            public string NodeTag { get; set; }\n             public string ServerUrl { get; set; }\n-            public string PublicServerUrl { get; set; }\n             public int Port { get; set; }\n-            public string Hostname { get; set; }\n-            public string Certificate { get; set; }\n             public List<string> Ips { get; set; }\n \n-\n             public DynamicJsonValue ToJson()\n             {\n                 return new DynamicJsonValue\n                 {\n-                    [nameof(NodeTag)] = NodeTag,\n                     [nameof(ServerUrl)] = ServerUrl,\n-                    [nameof(PublicServerUrl)] = PublicServerUrl,\n                     [nameof(Port)] = Port,\n-                    [nameof(Hostname)] = Hostname,\n-                    [nameof(Certificate)] = Certificate,\n-                    [nameof(Ips)] = Ips.ToArray(),\n+                    [nameof(Ips)] = Ips.ToArray()\n                 };\n             }\n         }\n@@ -68,6 +68,19 @@ public DynamicJsonValue ToJson()\n         }\n     }\n     \n+    public class ListDomainsInfo\n+    {\n+        public License License { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [nameof(License)] = License.ToJson(),\n+            };\n+        }\n+    }\n+    \n     public class ClaimDomainInfo\n     {\n         public License License { get; set; }\n@@ -83,55 +96,147 @@ public DynamicJsonValue ToJson()\n         }\n     }\n \n-    public class RegistrationResult\n+    public class RegistrationInfo\n+    {\n+        public License License { get; set; }\n+        public string Domain { get; set; }\n+        public List<RegistrationNodeInfo> SubDomains { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [nameof(License)] = License.ToJson(),\n+                [nameof(Domain)] = Domain,\n+                [nameof(SubDomains)] = SubDomains.Select(o => o.ToJson()).ToArray()\n+            };\n+        }\n+    }\n+\n+    public class RegistrationNodeInfo\n+    {\n+        public List<string> Ips { get; set; }\n+        public string SubDomain { get; set; }\n+        public string Challenge { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [nameof(Ips)] = Ips.ToArray(),\n+                [nameof(SubDomain)] = SubDomain,\n+                [nameof(Challenge)] = Challenge\n+            };\n+        }\n+    }\n+\n+    public class SubDomainAndIps\n+    {\n+        public string SubDomain { get; set; }\n+        public List<string> Ips { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [SubDomain] = Ips.ToArray()\n+            };\n+        }\n+    }\n+\n+    public class UserDomainsWithIps\n+    {\n+        public string Email { get; set; }\n+        public Dictionary<string, List<SubDomainAndIps>> Domains { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [nameof(Email)] = Email,\n+                [nameof(Domains)] = DynamicJsonValue.Convert(Domains)\n+            };\n+        }\n+    }\n+\n+    public class UserDomainsResult\n     {\n-        public RegistrationStatus Status { get; set; }\n+        public string Email { get; set; }\n+        public Dictionary<string, List<string>> Domains { get; set; }\n \n         public DynamicJsonValue ToJson()\n         {\n             return new DynamicJsonValue\n             {\n-                [nameof(Status)] = Status.ToString()\n+                [nameof(Email)] = Email,\n+                [nameof(Domains)] = DynamicJsonValue.Convert(Domains)\n             };\n         }\n     }\n \n-    public enum RegistrationStatus\n+    public class RegistrationResult\n     {\n-        Pending,\n-        Done,\n-        Error\n+        public string Status { get; set; }\n+\n+        public DynamicJsonValue ToJson()\n+        {\n+            return new DynamicJsonValue\n+            {\n+                [nameof(Status)] = Status\n+            };\n+        }\n     }\n \n     public enum SetupMode\n     {\n+        None,\n         Initial,\n         LetsEncrypt,\n         Secured,\n         Unsecured\n     }\n \n+    public enum SetupStage\n+    {\n+        Initial = 0,\n+        Agreement,\n+        Setup,\n+        Validation,\n+        GenarateCertificate,\n+        Finish\n+    }\n+\n     public class SetupProgressAndResult : IOperationResult, IOperationProgress\n     {\n         public long Processed { get; set; }\n         public long Total { get; set; }\n-        public readonly List<string> Messages;\n+        public string Certificate { get; set; }\n+        public readonly ConcurrentQueue<string> Messages;\n+        public byte[] SettingsZipFile; // not sent as part of the result\n \n+        private static readonly Logger Logger = LoggingSource.Instance.GetLogger<LicenseManager>(\"Server\");\n+        \n         public SetupProgressAndResult()\n         {\n-            Messages = new List<string>();\n+            Messages = new ConcurrentQueue<string>();\n+            Certificate = null;\n         }\n \n         public string Message { get; private set; }\n \n         public DynamicJsonValue ToJson()\n         {\n-            return new DynamicJsonValue(GetType())\n+            var json = new DynamicJsonValue(GetType())\n             {\n                 [nameof(Processed)] = Processed,\n                 [nameof(Total)] = Total,\n-                [nameof(Messages)] = Messages\n-        };\n+                [nameof(Messages)] = Messages.ToArray()\n+            };\n+\n+            if (Certificate != null)\n+                json[nameof(Certificate)] = Certificate;\n+\n+            return json;\n         }\n \n         public void AddWarning(string message)\n@@ -144,15 +249,17 @@ public void AddInfo(string message)\n             AddMessage(\"INFO\", message);\n         }\n \n-        public void AddError(string message)\n+        public void AddError(string message, Exception ex = null)\n         {\n-            AddMessage(\"ERROR\", message);\n+            AddMessage(\"ERROR\", message, ex);\n         }\n \n-        private void AddMessage(string type, string message)\n+        private void AddMessage(string type, string message, Exception ex = null) //<-- remember last message here\n         {\n             Message = $\"[{SystemTime.UtcNow:T} {type}] {message}\";\n-            Messages.Add(Message);\n+            Messages.Enqueue(Message);\n+            if (Logger.IsInfoEnabled)\n+                Logger.Info(Message, ex);\n         }\n \n         public bool ShouldPersist => false;"
    },
    {
      "filename": "src/Raven.Server/Commercial/SetupManager.cs",
      "status": "modified",
      "patch": "@@ -1,6 +1,7 @@\n \ufeffusing System;\n using System.Collections.Generic;\n using System.IO;\n+using System.IO.Compression;\n using System.Linq;\n using System.Net;\n using System.Net.Http;\n@@ -16,261 +17,647 @@\n using Microsoft.AspNetCore.Http;\n using Microsoft.Extensions.DependencyInjection;\n using Newtonsoft.Json;\n+using Raven.Client;\n using Raven.Client.Documents.Operations;\n+using Raven.Client.ServerWide.Operations.Certificates;\n using Raven.Server.Config;\n using Raven.Server.ServerWide;\n+using Raven.Server.ServerWide.Commands;\n+using Raven.Server.Utils;\n using Raven.Server.Web.Authentication;\n+using Sparrow.Logging;\n using Sparrow.Platform;\n using Sparrow.Platform.Posix;\n \n namespace Raven.Server.Commercial\n {\n-    public class SetupManager : IDisposable\n+    public static class SetupManager\n     {\n-        public const string SettingsFileName = \"settings.json\";\n+        private static readonly Logger Logger = LoggingSource.Instance.GetLogger<LicenseManager>(\"Server\");\n+        public static string SettingsPath = Path.Combine(AppContext.BaseDirectory, \"settings.json\");\n+        public const string LocalNodeTag = \"A\";\n         public const string RavenDbDomain = \"dbs.local.ravendb.net\";\n+        public static readonly Uri LetsEncryptServer = WellKnownServers.LetsEncryptStaging;\n \n-        private readonly ServerStore _serverStore;\n-        public Timer CertificateRenewalTimer { get; set; }\n-\n-        public SetupManager(ServerStore serverStore)\n-        {\n-            _serverStore = serverStore;\n-            \n-            // TODO If we are the leader (and in lets encrypt setup mode), start the timer with the renew task\n-        }\n+        /*  TODO\n+            call token ThrowIfCancellationRequested() in proper places\n+         */\n         \n-        public async Task<Uri> LetsEncryptAgreement(string email)\n+        public static async Task<Uri> LetsEncryptAgreement(string email)\n         {\n-            using (var acmeClient = new AcmeClient(WellKnownServers.LetsEncryptStaging))\n+            if (IsValidEmail(email) == false)\n+                throw new ArgumentException(\"Invalid e-mail format\" + email);\n+\n+            using (var acmeClient = new AcmeClient(LetsEncryptServer))\n             {\n                 var account = await acmeClient.NewRegistraton(\"mailto:\" + email);\n                 return account.GetTermsOfServiceUri();\n             }\n         }\n \n-        public async Task<IOperationResult> FetchCertificateTask(Action<IOperationProgress> onProgress, CancellationToken token, SecuredSetupInfo setupInfo)\n+        public static async Task<IOperationResult> SetupSecuredTask(Action<IOperationProgress> onProgress, CancellationToken token, SetupInfo setupInfo, ServerStore serverStore)\n         {\n-            // Total of 3 stages in this operation\n             var progress = new SetupProgressAndResult\n             {\n                 Processed = 0,\n-                Total = 3\n+                Total = 1\n             };\n-            progress.AddInfo(\"Setting up RavenDB with a Let's Encrypt certificate.\");\n-            progress.AddInfo($\"Stage1: Getting challenge from Let's Encrypt. Using e-mail: {setupInfo.Email}.\");\n+            progress.AddInfo(\"Setting up RavenDB in secured mode.\");\n+            progress.AddInfo(\"Creating new RavenDB configuration settings.\");\n             onProgress(progress);\n \n+            ValidateSetupInfo(SetupMode.Secured, setupInfo);\n+\n             try\n             {\n-                using (var acmeClient = new AcmeClient(WellKnownServers.LetsEncryptStaging))\n-                {\n-                    var account = await acmeClient.NewRegistraton(\"mailto:\" + setupInfo.Email);\n-                    account.Data.Agreement = account.GetTermsOfServiceUri();\n-                    await acmeClient.UpdateRegistration(account);\n-\n-                    var authz = await acmeClient.NewAuthorization(new AuthorizationIdentifier\n-                    {\n-                        Type = AuthorizationIdentifierTypes.Dns,\n-                        Value = setupInfo.Domain + RavenDbDomain\n-                    }); \n-\n-                    var challenge = authz.Data.Challenges.First(c => c.Type == ChallengeTypes.Dns01);\n+                progress.SettingsZipFile = await CreateSettingsZipAndOptionallyWriteToLocalServer(onProgress, progress, token, SetupMode.Secured, setupInfo, serverStore);\n+            }\n+            catch (Exception e)\n+            {\n+                LogErrorAndThrow(onProgress, progress, \"Setup failed. Could not create configuration file(s).\", e);\n+            }\n \n-                    setupInfo.Challenge = acmeClient.ComputeDnsValue(challenge);\n+            // return this to the studio so it can send it back on the validate stage\n+            progress.Certificate = setupInfo.Certificate;\n \n-                    progress.Processed++;\n-                    progress.AddInfo(\"Stage1: Finished.\");\n-                    progress.AddInfo($\"Stage2: Claiming {setupInfo.Domain} from {RavenDbDomain}. This may take a long time, 30-90 seconds.\");\n-                    onProgress(progress);\n+            progress.Processed++;\n+            progress.AddInfo(\"Successfully created new configuration settings.\");\n+            onProgress(progress);\n+            return progress;\n+        }\n \n+        public static async Task<IOperationResult> SetupLetsEncryptTask(Action<IOperationProgress> onProgress,  CancellationToken token, SetupInfo setupInfo, ServerStore serverStore)\n+        {\n+            var progress = new SetupProgressAndResult\n+            {\n+                Processed = 0,\n+                Total = 4\n+            };\n+            progress.AddInfo(\"Setting up RavenDB in Let's Encrypt security mode.\");\n+            onProgress(progress);\n \n-                    // Update DNS record in dbs.local.ravendb.net and set the let's encrypt challenge\n-                    var response = await ApiHttpClient.Instance.PostAsync(\"/api/v4/dns-n-cert/register\",\n-                            new StringContent(JsonConvert.SerializeObject(setupInfo), Encoding.UTF8, \"application/json\"), token).ConfigureAwait(false);\n+            ValidateSetupInfo(SetupMode.LetsEncrypt, setupInfo);\n \n-                    if (response.IsSuccessStatusCode == false)\n-                    {\n-                        var responseString = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n-                        progress.AddError($\"Stage2: Failed. Cannot complete setup: {response.StatusCode}.\\r\\n{responseString}\");\n-                        onProgress(progress);\n-                        return null;\n-                    }\n+            progress.AddInfo($\"Getting challenge(s) from Let's Encrypt. Using e-mail: {setupInfo.Email}.\");\n+            onProgress(progress);\n \n-                    var i = 0;\n-                    while (true)\n+            try\n+            {\n+                using (var acmeClient = new AcmeClient(LetsEncryptServer))\n+                {\n+                    var dictionary = new Dictionary<string, Task<Challenge>>();\n+                    Dictionary<string, string> map = null;\n+                    try\n                     {\n-                        await Task.Delay(1000, token);\n-                        response = await ApiHttpClient.Instance.PostAsync(\"/api/v4/dns-n-cert/registration-result\",\n-                                new StringContent(JsonConvert.SerializeObject(setupInfo), Encoding.UTF8, \"application/json\"), token)\n-                            .ConfigureAwait(false);\n-\n-                        var registrationResult = JsonConvert.DeserializeObject<RegistrationResult>(await response.Content.ReadAsStringAsync().ConfigureAwait(false));\n-                        \n-                        if (registrationResult.Status == RegistrationStatus.Error)\n+                        var account = await acmeClient.NewRegistraton(\"mailto:\" + setupInfo.Email);\n+                        account.Data.Agreement = account.GetTermsOfServiceUri();\n+                        await acmeClient.UpdateRegistration(account);\n+\n+                        /*var tags = setupInfo.IsWildcard \n+                            ? \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \n+                            : setupInfo.NodeSetupInfos.Select(node => node.Key[0]);*/\n+                      \n+                        foreach (var tag in setupInfo.NodeSetupInfos.Select(node => node.Key[0]))\n                         {\n-                            var responseString = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n-                            progress.AddError(\"Stage2: Failed. Cannot complete setup. \" + responseString);\n-                            onProgress(progress);\n-                            return null;\n-                        }\n-                        if (registrationResult.Status == RegistrationStatus.Pending)\n-                        {\n-                            switch (i)\n+                            var host = $\"{tag.ToString().ToLower()}.{setupInfo.Domain.ToLower()}\";\n+                            var fullHost = host + \".dbs.local.ravendb.net\";\n+                            var authz = acmeClient.NewAuthorization(new AuthorizationIdentifier\n                             {\n-                                case 30:\n-                                    progress.AddInfo(\"Stage2: Still Waiting...\");\n-                                    break;\n-                                case 60:\n-                                    progress.AddInfo(\"Stage2: Still Waiting... hang in there, just a few more seconds.\");\n-                                    break;\n-                                case 120:\n-                                    progress.AddInfo(\"Stage2: Something is wrong. You may wait a little longer but you might as well abort and try again.\");\n-                                    break;\n-                                default:\n-                                    progress.AddInfo(\"Stage2: Waiting...\");\n-                                    break;\n-                            }\n-                            onProgress(progress);\n+                                Type = AuthorizationIdentifierTypes.Dns,\n+                                Value = fullHost\n+                            }).ContinueWith(t =>\n+                            {\n+                                return t.Result.Data.Challenges.First(c => c.Type == ChallengeTypes.Dns01);\n+                            }, token);\n+                            dictionary[tag.ToString()] = authz;\n                         }\n-                        else if (registrationResult.Status == RegistrationStatus.Done)\n-                            break;\n-                        i++;\n+\n+                        await Task.WhenAll(dictionary.Values.ToArray());\n+                        map = dictionary.ToDictionary(x => x.Key, x => acmeClient.ComputeDnsValue(x.Value.Result));\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        LogErrorAndThrow(onProgress, progress, \"Failed to receive challenge(s) information from Let's Encrypt.\", e);\n                     }\n \n                     progress.Processed++;\n-                    progress.AddInfo(\"Stage2: Finished.\");\n-                    progress.AddInfo($\"Stage3: Completing Let's Encrypt challenge for domain {setupInfo.Domain}.\");\n+                    progress.AddInfo(\"Successfully received challenge(s) information from Let's Encrypt.\");\n+                    progress.AddInfo(\"updating DNS record(s) and challenge(s) in dbs.local.ravendb.net.\");\n                     onProgress(progress);\n-                    \n-                    var challengeResult = await acmeClient.CompleteChallenge(challenge);\n \n-                    for (i = 0; i < 15; i++)\n+                    try\n                     {\n-                        authz = await acmeClient.GetAuthorization(challengeResult.Location);\n-                        if (authz?.Data.Status != EntityStatus.Pending)\n-                            break;\n-\n-                        await Task.Delay(250, token);\n+                        await UpdateDnsRecordsTask(onProgress, progress, token, map, setupInfo);\n                     }\n-\n-                    if (authz != null && authz.Data.Status != EntityStatus.Valid)\n+                    catch (Exception e)\n                     {\n-                        progress.AddError($\"Stage3: Failed to authorize with Let\\'s Encrypt: {authz.Data.Status}\\r\\n{authz.Json}\"); \n-                        onProgress(progress);\n-                        return null;\n+                        LogErrorAndThrow(onProgress, progress, \"Failed to update DNS record(s) and challenge(s) in dbs.local.ravendb.net.\", e);\n                     }\n \n+                    progress.Processed++;\n+                    progress.AddInfo(\"Successfully updated DNS record(s) and challenge(s) in dbs.local.ravendb.net.\");\n+                    progress.AddInfo($\"Completing Let's Encrypt challenge(s) for {setupInfo.Domain.ToLower()}.dbs.local.ravendb.net.\");\n+                    onProgress(progress);\n+\n+                    AcmeCertificate cert = null;\n                     try\n                     {\n-                        var csr = new CertificationRequestBuilder();\n-                        csr.AddName($\"CN={setupInfo.Domain}\");\n-                        csr.SubjectAlternativeNames.Add(setupInfo.Domain);\n-                        \n-                        // TODO make sure this is allowed, otherwise we need a challenge for every single node seperately\n-                        foreach (var node in setupInfo.NodeSetupInfos)\n+                        var tasks = new List<Task>();\n+                        foreach (var kvp in dictionary)\n                         {\n-                            csr.SubjectAlternativeNames.Add($\"{node.NodeTag}.{setupInfo.Domain}\");\n+                            tasks.Add(CompleteAuthorizationFor(acmeClient, kvp.Value.Result, token));\n                         }\n-                        var cert = await acmeClient.NewCertificate(csr);\n-\n-                        var pfxBuilder = cert.ToPfx();\n-                        var certBytes = pfxBuilder.Build(setupInfo.Domain + \" cert\", \"\");\n-                        var base64Cert = Convert.ToBase64String(certBytes);\n-\n-                        if (PlatformDetails.RunningOnPosix)\n-                            AdminCertificatesHandler.ValidateCaExistsInOsStores(base64Cert, \"Let's Encrypt certificate\", _serverStore);\n-                        \n+                        await Task.WhenAll(tasks);\n \n-                        // Prepare settings.json files, and write the local one to disk\n-                        var settingsPath = SettingsFileName;\n-                        var jsons = new Dictionary<string, string>();\n-                        SecuredSetupInfo.NodeInfo localNode = null;\n+                        var csr = new CertificationRequestBuilder();\n+                        var lowerDomain = setupInfo.Domain.ToLower();\n+                        csr.AddName($\"CN=a.{lowerDomain}.dbs.local.ravendb.net\");\n \n-                        foreach (var node in setupInfo.NodeSetupInfos)\n-                        {\n-                            try\n+                        /*if (setupInfo.IsWildcard)\n+                            foreach (var lowerTag in \"abcdefghijklmnopqrstuvwxyz\")\n                             {\n-                                if (node.NodeTag == \"A\")\n-                                {\n-                                    jsons.Add(node.NodeTag, WriteSettingsJsonFile(node.Certificate, node.PublicServerUrl, node.ServerUrl, settingsPath, SetupMode.LetsEncrypt, modifyLocalServer: true));\n-                                    localNode = node;\n-                                }\n-                                else\n-                                    jsons.Add(node.NodeTag, WriteSettingsJsonFile(node.Certificate, node.PublicServerUrl, node.ServerUrl, settingsPath, SetupMode.Secured, modifyLocalServer: false));\n+                                csr.SubjectAlternativeNames.Add($\"{lowerTag}.{lowerDomain}.dbs.local.ravendb.net\");\n                             }\n-                            catch (Exception e)\n+                        else*/\n+                            foreach (var node in setupInfo.NodeSetupInfos)\n                             {\n-                                throw new InvalidOperationException($\"Failed to update {settingsPath} with new configuration.\", e);\n+                                csr.SubjectAlternativeNames.Add($\"{node.Key.ToLower()}.{lowerDomain}.dbs.local.ravendb.net\");\n                             }\n-                        }\n \n-                        // Need to return the jsons to the caller, so they can zip and send them to the studio\n+                        cert = await acmeClient.NewCertificate(csr);\n+                    }\n+                    catch (Exception e)\n+                    {\n+                        LogErrorAndThrow(onProgress, progress, \"Failed to aquire certificate from Let's Encrypt.\", e);\n+                    }\n \n-                        try\n-                        {\n-                            var ips = localNode?.Ips.Select(ip => new IPEndPoint(IPAddress.Parse(ip), localNode.Port)).ToArray();\n-                            var x509Certificate2 = new X509Certificate2(certBytes);\n-                            AssertServerCanStartSecured(x509Certificate2, localNode?.ServerUrl, ips, settingsPath);\n+                    try\n+                    {\n+                        var pfxBuilder = cert.ToPfx();\n+                        var certBytes = pfxBuilder.Build(setupInfo.Domain.ToLower() + \" cert\", \"\");\n+                        setupInfo.Certificate = Convert.ToBase64String(certBytes);\n+                        // return this to the studio so it can send it back on the validate stage\n+                        progress.Certificate = setupInfo.Certificate; \n+                    }\n+                    catch (Exception e)\n+                    {\n+                        LogErrorAndThrow(onProgress, progress, \"Failed to build certificate from Let's Encrypt.\", e);\n+                    }\n \n-                            // Load the certificate in the local server, so we can generate client certs later\n-                            _serverStore.Server.ClusterCertificateHolder = SecretProtection.ValidateCertificateAndCreateCertificateHolder(localNode?.Certificate, \"Setup\", x509Certificate2, certBytes);\n-                        }\n-                        catch (Exception e)\n-                        {\n-                            throw new InvalidOperationException($\"Failed to start server with the new configuration {settingsPath}.\", e);\n-                        }\n+                    progress.Processed++;\n+                    progress.AddInfo(\"Successfully acquired certificate from Let's Encrypt.\");\n+                    progress.AddInfo(\"Creating new RavenDB configuration settings.\");\n+                    onProgress(progress);\n \n+                    try\n+                    {\n+                        progress.SettingsZipFile = await CreateSettingsZipAndOptionallyWriteToLocalServer(onProgress, progress, token, SetupMode.LetsEncrypt, setupInfo, serverStore);\n                     }\n                     catch (Exception e)\n                     {\n-                        progress.AddError(\"Stage3: Failed to save certificate from Let's Encrypt. \" + e);\n-                        onProgress(progress);\n-                        return null;\n+                        LogErrorAndThrow(onProgress, progress, \"Failed to create configuration settings.\", e);\n                     }\n-                        \n+\n                     progress.Processed++;\n-                    progress.AddInfo(\"Stage3: Finished.\");\n-                    progress.AddInfo(\"Finished setting up RavenDB with a Let's Encrypt certificate. Server will now restart with the new settings.\");\n+                    progress.AddInfo(\"Successfully created new configuration settings.\");\n                     onProgress(progress);\n                 }\n             }\n             catch (Exception e)\n             {\n-                throw new InvalidOperationException(\"Failed to complete dns challenge from Let's Encrypt.\", e);\n+                throw new InvalidOperationException(\"Setting up RavenDB in Let's Encrypt security mode failed.\", e);\n             }\n             return progress;\n         }\n \n-        public static string WriteSettingsJsonFile(string base64Cert, string publicUrl, string serverUrl, string settingsPath, SetupMode setupMode, bool modifyLocalServer)\n+        private static void LogErrorAndThrow(Action<IOperationProgress> onProgress, SetupProgressAndResult progress, string msg, Exception e)\n+        {\n+            progress.AddError(msg, e);\n+            onProgress.Invoke(progress);\n+            throw new InvalidOperationException(msg, e);\n+        }\n+\n+        private static async Task UpdateDnsRecordsTask(Action<IOperationProgress> onProgress, SetupProgressAndResult progress, CancellationToken token, Dictionary<string, string> map, SetupInfo setupInfo)\n+        {\n+            using (var cts = CancellationTokenSource.CreateLinkedTokenSource(token, new CancellationTokenSource(TimeSpan.FromMinutes(15)).Token))\n+            {\n+                var registrationInfo = new RegistrationInfo\n+                {\n+                    License = setupInfo.License,\n+                    Domain = setupInfo.Domain,\n+                    SubDomains = new List<RegistrationNodeInfo>()\n+                };\n+\n+                foreach (var domainAndChallenge in map)\n+                {\n+                    progress.AddInfo($\"Creating Dns record/challenge for node {domainAndChallenge.Key}.\");\n+                    onProgress(progress);\n+                    var regNodeInfo = new RegistrationNodeInfo()\n+                    {\n+                        SubDomain = domainAndChallenge.Key,\n+                        Challenge = domainAndChallenge.Value,\n+                        Ips = setupInfo.NodeSetupInfos[domainAndChallenge.Key].Ips\n+                    };\n+                    registrationInfo.SubDomains.Add(regNodeInfo);\n+                }\n+                \n+                var serializeObject = JsonConvert.SerializeObject(registrationInfo);\n+                HttpResponseMessage response;\n+                try\n+                {\n+                    progress.AddInfo(\"Registering DNS record(s)/challenge(s) in api.ravendb.net.\");\n+                    progress.AddInfo(\"Please wait between 30 seconds and a few minutes, depending on the number of domains(nodes).\");\n+                    progress.AddInfo(\"Waiting for DNS records to update...\");\n+                    onProgress(progress);\n+                    response = await ApiHttpClient.Instance.PostAsync(\"api/v1/dns-n-cert/register\",\n+                        new StringContent(serializeObject, Encoding.UTF8, \"application/json\"), token).ConfigureAwait(false);\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new InvalidOperationException(\"Registration request to api.ravendb.net failed for: \" + serializeObject, e);\n+                }\n+\n+                var responseString = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n+\n+                if (response.IsSuccessStatusCode == false)\n+                {\n+                    throw new InvalidOperationException(\n+                        $\"Got unsuccessful response from registration request: {response.StatusCode}.{Environment.NewLine}{responseString}\");\n+                }\n+\n+                var id = JsonConvert.DeserializeObject<Dictionary<string,string>>(responseString).First().Value;\n+\n+                try\n+                {\n+                    RegistrationResult registrationResult;\n+                    do\n+                    {\n+                        try\n+                        {\n+                            await Task.Delay(1000, cts.Token);\n+                            response = await ApiHttpClient.Instance.PostAsync(\"/v4/dns-n-cert/registration-result?id=\" + id,\n+                                    new StringContent(serializeObject, Encoding.UTF8, \"application/json\"), cts.Token)\n+                                .ConfigureAwait(false);\n+                        }\n+                        catch (Exception e)\n+                        {\n+                            throw new InvalidOperationException(\"Registration-result request to api.ravendb.net failed.\", e); //add the object we tried to send to error\n+                        }\n+\n+                        responseString = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n+\n+                        if (response.IsSuccessStatusCode == false)\n+                        {\n+                            throw new InvalidOperationException(\n+                                $\"Got unsuccessful response from registration-result request: {response.StatusCode}.{Environment.NewLine}{responseString}\");\n+                        }\n+\n+                        registrationResult = JsonConvert.DeserializeObject<RegistrationResult>(responseString);\n+\n+                    } while (registrationResult.Status == \"PENDING\");\n+                    progress.AddInfo(\"Got successful response from api.ravendb.net.\");\n+                    onProgress(progress);\n+                }\n+                catch (Exception e)\n+                {\n+                    if (cts.IsCancellationRequested == false)\n+                        throw;\n+                    throw new TimeoutException(\"Request failed due to a timeout error\", e);\n+                }\n+            }\n+        }\n+\n+        private static async Task CompleteAuthorizationFor(AcmeClient client, Challenge dnsChallenge, CancellationToken token)\n+        {\n+            var challenge = await client.CompleteChallenge(dnsChallenge);\n+\n+            using (var cts = CancellationTokenSource.CreateLinkedTokenSource(token, new CancellationTokenSource(TimeSpan.FromMinutes(1)).Token))\n+            {\n+                while (true)\n+                {\n+                    if(cts.IsCancellationRequested)\n+                        throw new System.TimeoutException(\"Timeout expired on completion of ACME authorization\");\n+\n+                    var authz = await client.GetAuthorization(challenge.Location);\n+                    if (authz.Data.Status == EntityStatus.Pending)\n+                    {\n+                        await Task.Delay(250, cts.Token);\n+                        continue;\n+                    }\n+\n+                    if (authz.Data.Status == EntityStatus.Valid)\n+                        return;\n+\n+                    throw new InvalidOperationException(\"Failed to authorize certificate: \" + authz.Data.Status + Environment.NewLine + authz.Json);\n+                }\n+            }\n+        }\n+\n+        public static async Task<IOperationResult> SetupValidateTask(Action<IOperationProgress> onProgress, CancellationToken token, SetupInfo setupInfo, ServerStore serverStore, SetupMode setupMode)\n         {\n-            var json = File.ReadAllText(settingsPath);\n-            dynamic jsonObj = JsonConvert.DeserializeObject(json);\n+            var progress = new SetupProgressAndResult\n+            {\n+                Processed = 0,\n+                Total = 1\n+            };\n+\n+            progress.AddInfo(\"Validating that RavenDB can start with the new configuration settings.\");\n+            onProgress(progress);\n+\n+            try\n+            {\n+                var localNode = setupInfo.NodeSetupInfos[LocalNodeTag];\n+\n+                var ips = localNode.Ips.Select(ip => new IPEndPoint(IPAddress.Parse(ip), localNode.Port)).ToArray();\n+\n+                X509Certificate2 serverCert;\n+                try\n+                {\n+                    var localCertBytes = Convert.FromBase64String(setupInfo.Certificate);\n+                    serverCert = string.IsNullOrEmpty(setupInfo.Password)\n+                        ? new X509Certificate2(localCertBytes)\n+                        : new X509Certificate2(localCertBytes, setupInfo.Password);\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new InvalidOperationException(\"Validation failed. Could not load the provided certificate.\", e);\n+                }\n+\n+                if (setupMode == SetupMode.Secured)\n+                    setupInfo.Domain = serverCert.GetNameInfo(X509NameType.DnsName, false);\n+\n+                var localServerUrl = (setupMode == SetupMode.LetsEncrypt)\n+                    ? $\"https://{LocalNodeTag.ToLower()}.{setupInfo.Domain.ToLower()}.dbs.local.ravendb.net:{localNode.Port}\"\n+                    : GetServerUrlFromCertificate(serverCert, setupInfo, LocalNodeTag, localNode.Port, out var _);\n+                \n+                await AssertServerCanStartSecured(serverCert, localServerUrl, ips, token, setupInfo);\n+            }\n+            catch (Exception e)\n+            {\n+                LogErrorAndThrow(onProgress, progress, \"Validation failed.\", e);\n+            }\n \n-            jsonObj[\"ServerUrl\"] = serverUrl;\n-            jsonObj[\"PublicServerUrl\"] = publicUrl;\n-            jsonObj[\"Security.Certificate.Base64\"] = base64Cert;\n-            jsonObj[\"Setup.Mode\"] = setupMode.ToString();\n+            progress.Processed++;\n+            progress.AddInfo(\"Validations successful.\");\n+            onProgress(progress);\n \n-            string output = JsonConvert.SerializeObject(jsonObj, Formatting.Indented);\n+            return progress;\n+        }\n \n-            if (modifyLocalServer)\n+        public static void ValidateSetupInfo(SetupMode setupMode, SetupInfo setupInfo)\n+        {\n+            try\n             {\n-                var tmpPath = settingsPath + \".tmp\";\n-                using (var file = new FileStream(tmpPath, FileMode.Create))\n-                using (var writer = new StreamWriter(file))\n+                if (setupMode == SetupMode.LetsEncrypt)\n                 {\n-                    writer.Write(output);\n-                    writer.Flush();\n-                    file.Flush(true);\n+                    if (setupInfo.NodeSetupInfos.ContainsKey(LocalNodeTag) == false)\n+                        throw new ArgumentException($\"At least one of the nodes must have the node tag '{LocalNodeTag}'.\");\n+                    if (IsValidEmail(setupInfo.Email) == false)\n+                        throw new ArgumentException(\"Invalid email address.\");\n+                    if (IsValidDomain(setupInfo.Domain) == false)\n+                        throw new ArgumentException(\"Invalid domain name.\");\n+                }\n+\n+                if (setupMode == SetupMode.Secured && string.IsNullOrWhiteSpace(setupInfo.Certificate))\n+                    throw new ArgumentException($\"{nameof(setupInfo.Certificate)} is a mandatory property for a secured setup\");\n+\n+                foreach (var node in setupInfo.NodeSetupInfos)\n+                {\n+                    if (string.IsNullOrWhiteSpace(node.Key) || node.Key.Length != 1 || !char.IsLetter(node.Key[0]) || !char.IsUpper(node.Key[0]))\n+                        throw new ArgumentException(\"Node Tag [A-Z] (capital) is a mandatory property for a secured setup\");\n+                    \n+                    foreach (var ip in node.Value.Ips)\n+                    {\n+                        if (IsValidIp(ip) == false)\n+                            throw new ArgumentException($\"Invalid IP: '{ip}' in node '{node.Key}'\");\n+                    }\n                 }\n+            }\n+            catch (Exception e)\n+            {\n+                throw new FormatException(\"Validation of setup information failed. \", e);\n+            }\n+        }\n+\n+        public static bool IsValidEmail(string email)\n+        {\n+            if (string.IsNullOrWhiteSpace(email))\n+                return false;\n+            try\n+            {\n+                var addr = new System.Net.Mail.MailAddress(email);\n+                return addr.Address == email;\n+            }\n+            catch\n+            {\n+                return false;\n+            }\n+        }\n+\n+        private static bool IsValidIp(string ip)\n+        {\n+            if (string.IsNullOrWhiteSpace(ip))\n+                return false;\n+\n+            var octets = ip.Split('.');\n+            return octets.Length == 4 && octets.All(o => byte.TryParse(o, out _));\n+        }\n+\n+        private static bool IsValidDomain(string domain)\n+        {\n+            if (string.IsNullOrWhiteSpace(domain))\n+                return false;\n+\n+            return Uri.CheckHostName(domain) != UriHostNameType.Unknown;\n+        }\n+\n+        public static void WriteSettingsJsonLocally(string settingsPath, string json)\n+        {\n+            var tmpPath = settingsPath + \".tmp\";\n+            using (var file = new FileStream(tmpPath, FileMode.Create))\n+            using (var writer = new StreamWriter(file))\n+            {\n+                writer.Write(json);\n+                writer.Flush();\n+                file.Flush(true);\n+            }\n \n-                File.Replace(tmpPath, settingsPath, settingsPath + \".bak\");\n-                if (PlatformDetails.RunningOnPosix)\n-                    Syscall.FsyncDirectoryFor(settingsPath);\n+            File.Replace(tmpPath, settingsPath, settingsPath + \".bak\");\n+            if (PlatformDetails.RunningOnPosix)\n+                Syscall.FsyncDirectoryFor(settingsPath);\n+        }\n+\n+        private static string GetServerUrlFromCertificate(X509Certificate2 cert, SetupInfo setupInfo, string nodeTag, int port, out string domain)\n+        {\n+            var cn = cert.GetNameInfo(X509NameType.DnsName, false);\n+            if (cn[0] == '*')\n+            {\n+                var parts = cn.Split(\"*.\");\n+                domain = parts.Length > 1 ? parts[1] : parts[0];\n+                return $\"https://{nodeTag.ToLower()}.{domain}:{port}\";\n             }\n \n-            return output;\n+            domain = cn;\n+            return setupInfo.NodeSetupInfos[nodeTag].ServerUrl = $\"https://{domain}:{port}\";\n+        }\n+\n+        private static async Task<byte[]> CreateSettingsZipAndOptionallyWriteToLocalServer(Action<IOperationProgress> onProgress, SetupProgressAndResult progress, CancellationToken token, SetupMode setupMode, SetupInfo setupInfo, ServerStore serverStore)\n+        {\n+            try\n+            {\n+                using (var ms = new MemoryStream())\n+                {\n+                    using (var archive = new ZipArchive(ms, ZipArchiveMode.Create, true))\n+                    {\n+                        var originalSettings = File.ReadAllText(SettingsPath);\n+                        dynamic jsonObj = JsonConvert.DeserializeObject(originalSettings);\n+\n+                        progress.AddInfo(\"Loading and validating server certificate.\");\n+                        onProgress(progress);\n+                        X509Certificate2 serverCert;\n+                        byte[] serverCertBytes;\n+\n+                        try\n+                        {\n+                            var base64 = setupInfo.Certificate;\n+                            serverCertBytes = Convert.FromBase64String(base64);\n+                            serverCert = string.IsNullOrEmpty(setupInfo.Password)\n+                                ? new X509Certificate2(serverCertBytes)\n+                                : new X509Certificate2(serverCertBytes, setupInfo.Password);\n+\n+                            if (setupMode == SetupMode.Secured)\n+                            {\n+                                GetServerUrlFromCertificate(serverCert, setupInfo, LocalNodeTag, setupInfo.NodeSetupInfos[LocalNodeTag].Port, out var domain);\n+                                setupInfo.Domain = domain;\n+\n+                            }\n+\n+                            serverStore.EnsureNotPassive();\n+\n+                            serverStore.Server.ClusterCertificateHolder = SecretProtection.ValidateCertificateAndCreateCertificateHolder(base64, \"Setup\", serverCert, serverCertBytes, setupInfo.Password);\n+\n+                            if (PlatformDetails.RunningOnPosix)\n+                                AdminCertificatesHandler.ValidateCaExistsInOsStores(base64, \"setup certificate\", serverStore);\n+                        }\n+                        catch (Exception e)\n+                        {\n+                            throw new InvalidOperationException(\"Could not load the certificate in the local server.\", e);\n+                        }\n+\n+                        progress.AddInfo(\"Generating the client certificate.\");\n+                        onProgress(progress);\n+                        X509Certificate2 clientCert;\n+\n+                        try\n+                        {\n+                            // requires server certificate to be loaded\n+                            clientCert = await GenerateCertificateTask($\"{setupInfo.Domain.ToLower()}.client.certificate\", serverStore);\n+                        }\n+                        catch (Exception e)\n+                        {\n+                            throw new InvalidOperationException($\"Could not generate a client certificate for '{setupInfo.Domain.ToLower()}'.\", e);\n+                        }\n+\n+                        progress.AddInfo(\"Writing certificates to zip archive.\");\n+                        onProgress(progress);\n+                        try\n+                        {\n+                            var entry = archive.CreateEntry($\"{setupInfo.Domain.ToLower()}.server.certificate.pfx\");\n+                            using (var entryStream = entry.Open())\n+                            using (var writer = new BinaryWriter(entryStream))\n+                            {\n+                                writer.Write(serverCertBytes);\n+                                writer.Flush();\n+                                await entryStream.FlushAsync(token);\n+                            }\n+\n+                            entry = archive.CreateEntry($\"{setupInfo.Domain.ToLower()}.client.certificate.pfx\");\n+                            using (var entryStream = entry.Open())\n+                            using (var writer = new BinaryWriter(entryStream))\n+                            {\n+                                writer.Write(clientCert.Export(X509ContentType.Pfx));\n+                                writer.Flush();\n+                                await entryStream.FlushAsync(token);\n+                            }\n+\n+                            entry = archive.CreateEntry($\"{setupInfo.Domain.ToLower()}.client.certificate.pem\");\n+                            using (var entryStream = entry.Open())\n+                            using (var writer = new StreamWriter(entryStream))\n+                            {\n+                                var builder = new StringBuilder();\n+                                builder.AppendLine(\"-----BEGIN CERTIFICATE-----\");\n+                                builder.AppendLine(Convert.ToBase64String(clientCert.Export(X509ContentType.Cert), Base64FormattingOptions.InsertLineBreaks)); //Todo test this. does it includes the private key\n+                                builder.AppendLine(\"-----END CERTIFICATE-----\");\n+\n+                                writer.Write(builder.ToString());\n+                                writer.Flush();\n+                                await entryStream.FlushAsync(token);\n+                            }\n+                        }\n+                        catch (Exception e)\n+                        {\n+                            throw new InvalidOperationException(\"Failed to write the certificates to a zip archive.\", e);\n+                        }\n+                        \n+                        jsonObj[\"Setup.Mode\"] = setupMode.ToString();\n+\n+                        foreach (var node in setupInfo.NodeSetupInfos)\n+                        {\n+                            progress.AddInfo($\"Creating settings file 'settings.josn' for node {node.Key}.\");\n+                            onProgress(progress);\n+\n+                            if (setupMode == SetupMode.Secured)\n+                            {\n+                                jsonObj[\"ServerUrl\"] = GetServerUrlFromCertificate(serverCert, setupInfo, node.Key, node.Value.Port, out var _);\n+                                jsonObj[\"Security.Certificate.Base64\"] = setupInfo.Certificate;\n+                                jsonObj[\"Security.Certificate.Password\"] = setupInfo.Password;\n+                            }\n+                            else if(setupMode == SetupMode.LetsEncrypt)\n+                            {\n+                                jsonObj[\"ServerUrl\"] = $\"https://{node.Key.ToLower()}.{setupInfo.Domain.ToLower()}.dbs.local.ravendb.net:{node.Value.Port}\";\n+                                jsonObj[\"Security.Certificate.Base64\"] = setupInfo.Certificate;\n+                            }\n+                            \n+                            var jsonString = JsonConvert.SerializeObject(jsonObj, Formatting.Indented);\n+\n+                            if (node.Key == LocalNodeTag && setupInfo.ModifyLocalServer)\n+                            {\n+                                try\n+                                {\n+                                    WriteSettingsJsonLocally(SettingsPath, jsonString);\n+                                }\n+                                catch (Exception e)\n+                                {\n+                                    throw new InvalidOperationException(\"Failed to write settings file 'settings.josn' for the local sever.\", e);\n+                                }\n+                            }\n+\n+                            progress.AddInfo($\"Adding settings file for node '{node.Key}' to zip archive.\");\n+                            onProgress(progress);\n+                            try\n+                            {\n+                                var entry = archive.CreateEntry($\"{node.Key}\\\\settings.json\");\n+                                using (var entryStream = entry.Open())\n+                                using (var writer = new StreamWriter(entryStream))\n+                                {\n+                                    writer.Write(jsonString);\n+                                    writer.Flush();\n+                                    await entryStream.FlushAsync(token);\n+                                }\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                throw new InvalidOperationException($\"Failed to to create zip archive for node '{node.Key}'.\", e);\n+                            }\n+                        }\n+                    }\n+                    return ms.ToArray();\n+                }\n+            }\n+            catch (Exception e)\n+            {\n+                throw new InvalidOperationException(\"Failed to create setting file(s).\", e);\n+            }\n         }\n \n         private class UniqueResponseResponder : IStartup\n@@ -284,6 +671,8 @@ public UniqueResponseResponder(string response)\n \n             public IServiceProvider ConfigureServices(IServiceCollection services)\n             {\n+                var x = services.BuildServiceProvider();\n+                \n                 return services.BuildServiceProvider();\n             }\n \n@@ -296,70 +685,102 @@ public void Configure(IApplicationBuilder app)\n             }\n         }\n \n-        public async void AssertServerCanStartSecured(X509Certificate2 serverCertificate, string serverUrl, IPEndPoint[] addresses, string settingsPath)\n+        public static async Task AssertServerCanStartSecured(X509Certificate2 serverCertificate, string serverUrl, IPEndPoint[] addresses, CancellationToken token, SetupInfo setupInfo)\n         {\n-            var configuration = new RavenConfiguration(null, ResourceType.Server, settingsPath);\n+            var configuration = new RavenConfiguration(null, ResourceType.Server, SettingsPath);\n             configuration.Initialize();\n-\n             var guid = Guid.NewGuid().ToString();\n-            var responder = new UniqueResponseResponder(guid);\n \n-            var webHost = new WebHostBuilder()\n-                .CaptureStartupErrors(captureStartupErrors: true)\n-                .UseKestrel(options =>\n-                {\n-                    if (addresses.Length == 0)\n-                        options.Listen(new IPEndPoint(IPAddress.Parse(\"0.0.0.0\"), 8080), listenOptions => listenOptions.UseHttps(serverCertificate));\n+            try\n+            {\n+                var responder = new UniqueResponseResponder(guid);\n \n-                    foreach (var addr in addresses)\n+                var webHost = new WebHostBuilder()\n+                    .CaptureStartupErrors(captureStartupErrors: true)\n+                    .UseKestrel(options =>\n                     {\n-                        options.Listen(addr, listenOptions => listenOptions.UseHttps(serverCertificate));\n-                    }\n-                })\n-                .ConfigureServices(collection =>\n-                {\n-                    collection.AddSingleton(typeof(IStartup), responder);\n-                })\n-                .UseShutdownTimeout(TimeSpan.FromMilliseconds(150))\n-                .Build();\n+                        var port = setupInfo.NodeSetupInfos[LocalNodeTag].Port;\n+                        if (addresses.Length == 0)\n+                        {\n+                            var defaultIp = new IPEndPoint(IPAddress.Parse(\"0.0.0.0\"), port == 0 ? 443 : port);\n+                            options.Listen(defaultIp, listenOptions => listenOptions.UseHttps(serverCertificate));\n+                            if (Logger.IsInfoEnabled)\n+                                Logger.Info($\"List of ip addresses for node '{LocalNodeTag}' is empty. Webhost listening to {defaultIp}\");\n+                        }\n+\n+                        foreach (var addr in addresses)\n+                        {\n+                            options.Listen(addr, listenOptions => listenOptions.UseHttps(serverCertificate));\n+                        }\n+                    })\n+                    .UseSetting(WebHostDefaults.ApplicationKey, \"Setup simulation\")\n+                    .ConfigureServices(collection =>\n+                    {\n+                        collection.AddSingleton(typeof(IStartup), responder);\n+                    })\n+                    .UseShutdownTimeout(TimeSpan.FromMilliseconds(150))\n+                    .Build();\n \n-            webHost.Start();\n+                webHost.Start();\n+            }\n+            catch (Exception e)\n+            {\n+                throw new InvalidOperationException($\"Failed to start webhost on node '{LocalNodeTag}' configuration.{Environment.NewLine}\" +\n+                                                    $\"Settings file:{SettingsPath}.{Environment.NewLine} \" +\n+                                                    $\"IP addresses: {string.Join(\", \", addresses.Select(addr => addr.ToString()))}.\", e);\n+            }\n \n             using (var client = new HttpClient\n             {\n                 BaseAddress = new Uri(serverUrl)\n             })\n             {\n-                // wrap errors\n-                var response = await client.GetAsync(\"/are-you-there?\");\n-                response.EnsureSuccessStatusCode();\n-                var result = await response.Content.ReadAsStringAsync();\n-                if (result != guid)\n+                HttpResponseMessage response = null;\n+                string result = null;\n+                try\n+                {\n+                    var cts = CancellationTokenSource.CreateLinkedTokenSource(token, new CancellationTokenSource(2).Token);\n+                    response = await client.GetAsync(\"/are-you-there?\", cts.Token);\n+                    response.EnsureSuccessStatusCode();\n+                    result = await response.Content.ReadAsStringAsync();\n+                    if (result != guid)\n+                    {\n+                        throw new InvalidOperationException($\"Expected result guid:{guid} but got {result}.\");\n+                    }\n+                }\n+                catch (Exception e)\n                 {\n-                    throw new InvalidOperationException(\"Not a match\");\n+                    throw new InvalidOperationException($\"Failed to start contact server {serverUrl}.{Environment.NewLine}\" +\n+                                                        $\"Settings file:{SettingsPath}.{Environment.NewLine}\" +\n+                                                        $\"IP addresses: {string.Join(\", \", addresses.Select(addr => addr.ToString()))}.{Environment.NewLine}\" +\n+                                                        $\"Response: {response?.StatusCode}.{Environment.NewLine}{result}\", e);\n                 }\n             }\n         }\n \n-        public Task RenewLetsEncryptCertificate()\n+        // Duplicate of AdminCertificatesHandler.GenerateCertificateInternal stripped from authz checks, used by an unauthenticated client during setup only\n+        public static async Task<X509Certificate2> GenerateCertificateTask(string name,  ServerStore serverStore)\n         {\n-            var serverCertificate = _serverStore.Server.ClusterCertificateHolder.Certificate;\n-            if (serverCertificate != null && (serverCertificate.NotAfter - DateTime.Today).TotalDays > 31)\n-                return Task.CompletedTask;\n-\n-            // Need to renew:\n-            // 0. Assert not in setup mode\n-            // 1. read license from cluster\n-            // 2. contact grisha and ask for email\n-            // 3. extract the domain from current certificate\n-            // 4. create new LetsEncryptSetupInfo and call FetchCertificateTask\n-\n-            return Task.CompletedTask;\n-        }\n+            if (serverStore.Server.ClusterCertificateHolder?.Certificate == null)\n+                throw new InvalidOperationException($\"Cannot generate the client certificate '{name}' becuase the server certificate is not loaded.\");\n+            \n+            // this creates a client certificate which is signed by the current server certificate\n+            var selfSignedCertificate = CertificateUtils.CreateSelfSignedClientCertificate(name, serverStore.Server.ClusterCertificateHolder);\n \n-        public void Dispose()\n-        {\n-            CertificateRenewalTimer?.Dispose();\n+            var newCertDef = new CertificateDefinition\n+            {\n+                Name = name,\n+                // this does not include the private key, that is only for the client\n+                Certificate = Convert.ToBase64String(selfSignedCertificate.Export(X509ContentType.Cert)),\n+                Permissions = new Dictionary<string, DatabaseAccess>(),\n+                SecurityClearance = SecurityClearance.ClusterAdmin,\n+                Thumbprint = selfSignedCertificate.Thumbprint\n+            };\n+\n+            var res = await serverStore.PutValueInClusterAsync(new PutCertificateCommand(Constants.Certificates.Prefix + selfSignedCertificate.Thumbprint, newCertDef));\n+            await serverStore.Cluster.WaitForIndexNotification(res.Index);\n+\n+            return selfSignedCertificate;\n         }\n     }\n }"
    },
    {
      "filename": "src/Raven.Server/Config/Categories/CoreConfiguration.cs",
      "status": "modified",
      "patch": "@@ -44,7 +44,7 @@ public class CoreConfiguration : ConfigurationCategory\n         public PathSetting DataDirectory { get; set; }\n \n         [Description(\"Determines what kind of security was chosen during setup.\")]\n-        [DefaultValue(SetupMode.Initial)]\n+        [DefaultValue(SetupMode.None)]\n         [ConfigurationEntry(\"Setup.Mode\", ConfigurationEntryScope.ServerWideOnly)]\n         public SetupMode SetupMode { get; set; }\n "
    },
    {
      "filename": "src/Raven.Server/Config/Categories/SecurityConfiguration.cs",
      "status": "modified",
      "patch": "@@ -10,12 +10,12 @@ namespace Raven.Server.Config.Categories\n {\n     public class SecurityConfiguration : ConfigurationCategory\n     {\n-        [Description(\"The .pfx certificate in Base64 format. If specified, RavenDB will use HTTPS/SSL for all network activities. Certificate setting priority order: 1)Base64 2)Executable 3)Path\")]\n+        [Description(\"The .pfx certificate in Base64 format. If specified, RavenDB will use HTTPS/SSL for all network activities. Certificate setting priority order: 1)Base64 2)Path 3)Executable\")]\n         [DefaultValue(null)]\n         [ConfigurationEntry(\"Security.Certificate.Base64\", ConfigurationEntryScope.ServerWideOnly)]\n         public string Base64 { get; set; }\n \n-        [Description(\"The path to .pfx certificate file. If specified, RavenDB will use HTTPS/SSL for all network activities. You can use the '~/' prefix to refer to RavenDB's base directory. Certificate setting priority order: 1)Base64 2)Executable 3)Path\")]\n+        [Description(\"The path to .pfx certificate file. If specified, RavenDB will use HTTPS/SSL for all network activities. You can use the '~/' prefix to refer to RavenDB's base directory. Certificate setting priority order: 1)Base64 2)Path 3)Executable\")]\n         [DefaultValue(null)]\n         [ConfigurationEntry(\"Security.Certificate.Path\", ConfigurationEntryScope.ServerWideOnly)]\n         public string CertificatePath { get; set; }\n@@ -25,7 +25,7 @@ public class SecurityConfiguration : ConfigurationCategory\n         [ConfigurationEntry(\"Security.Certificate.Password\", ConfigurationEntryScope.ServerWideOnly)]\n         public string CertificatePassword { get; set; }\n \n-        [Description(\"A command or executable providing a .pfx certificate file. If specified, RavenDB will use HTTPS/SSL for all network activities. Certificate setting priority order: 1)Base64 2)Executable 3)Path\")]\n+        [Description(\"A command or executable providing a .pfx certificate file. If specified, RavenDB will use HTTPS/SSL for all network activities. Certificate setting priority order: 1)Base64 2)Path 3)Executable\")]\n         [DefaultValue(null)]\n         [ConfigurationEntry(\"Security.Certificate.Exec\", ConfigurationEntryScope.ServerWideOnly)]\n         public string CertificateExec { get; set; }\n@@ -41,26 +41,6 @@ public class SecurityConfiguration : ConfigurationCategory\n         [ConfigurationEntry(\"Security.Certificate.Exec.TimeoutInSec\", ConfigurationEntryScope.ServerWideOnly)]\n         public TimeSetting CertificateExecTimeout { get; set; }\n \n-        [Description(\"The path to .pfx cluster certificate file. If specified, RavenDB will use this (second) certificate for communications between servers in the cluster.\")]\n-        [DefaultValue(null)]\n-        [ConfigurationEntry(\"Security.ClusterCertificate.Path\", ConfigurationEntryScope.ServerWideOnly)]\n-        public string ClusterCertificatePath { get; set; }\n-\n-        [Description(\"The (optional) password of the .pfx cluster certificate file.\")]\n-        [DefaultValue(null)]\n-        [ConfigurationEntry(\"Security.ClusterCertificate.Password\", ConfigurationEntryScope.ServerWideOnly)]\n-        public string ClusterCertificatePassword { get; set; }\n-\n-        [Description(\"A command or executable providing a .pfx cluster certificate file. If specified, RavenDB will use this (second) certificate for communications between servers in the cluster.\")]\n-        [DefaultValue(null)]\n-        [ConfigurationEntry(\"Security.ClusterCertificate.Exec\", ConfigurationEntryScope.ServerWideOnly)]\n-        public string ClusterCertificateExec { get; set; }\n-\n-        [Description(\"The command line arguments for the 'Security.ClusterCertificate.Exec' command or executable.\")]\n-        [DefaultValue(null)]\n-        [ConfigurationEntry(\"Security.ClusterCertificate.Exec.Arguments\", ConfigurationEntryScope.ServerWideOnly)]\n-        public string ClusterCertificateExecArguments { get; set; }\n-\n         [Description(\"The path of the (512-bit) Master Key. If specified, RavenDB will use this key to protect secrets.\")]\n         [DefaultValue(null)]\n         [ConfigurationEntry(\"Security.MasterKey.Path\", ConfigurationEntryScope.ServerWideOnly)]\n@@ -92,7 +72,7 @@ public class SecurityConfiguration : ConfigurationCategory\n         internal string UnsecureAccessWarningMessage { get; private set; }\n \n         public bool IsCertificateConfigured => string.IsNullOrWhiteSpace(CertificatePath) == false \n-            || string.IsNullOrWhiteSpace(CertificateExec) == false;\n+            || string.IsNullOrWhiteSpace(CertificateExec) == false || string.IsNullOrWhiteSpace(Base64) == false;\n \n         public bool AuthenticationEnabled => IsCertificateConfigured;\n "
    },
    {
      "filename": "src/Raven.Server/Config/RavenConfiguration.cs",
      "status": "modified",
      "patch": "@@ -8,6 +8,7 @@\n using System.Reflection;\n using System.Text;\n using Microsoft.Extensions.Configuration;\n+using Microsoft.Extensions.Configuration.Json;\n using Microsoft.Extensions.Configuration.Memory;\n using Raven.Client.Documents.Conventions;\n using Raven.Server.Config.Attributes;\n@@ -77,6 +78,8 @@ public RavenConfiguration(string resourceName, ResourceType resourceType, string\n             AddEnvironmentVariables();\n             AddJsonConfigurationVariables(customConfigPath);\n \n+            var path = _configBuilder.Sources.OfType<JsonConfigurationSource>().Last().Path;\n+\n             Settings = _configBuilder.Build();\n \n             Core = new CoreConfiguration();"
    },
    {
      "filename": "src/Raven.Server/Documents/Operations/Operations.cs",
      "status": "modified",
      "patch": "@@ -360,8 +360,8 @@ public DynamicJsonValue ToJson()\n \n         public enum OperationType\n         {\n-            [Description(\"Setup Let's Encrypt\")]\n-            SetupLetsEncrypt,\n+            [Description(\"Setup\")]\n+            Setup,\n \n             [Description(\"Update by index\")]\n             UpdateByIndex,"
    },
    {
      "filename": "src/Raven.Server/Json/JsonDeserializationServer.cs",
      "status": "modified",
      "patch": "@@ -101,11 +101,15 @@ internal sealed class JsonDeserializationServer : JsonDeserializationBase\n \n         public static readonly Func<BlittableJsonReaderObject, CertificateDefinition> CertificateDefinition = GenerateJsonDeserializationRoutine<CertificateDefinition>();\n \n-        public static readonly Func<BlittableJsonReaderObject, SecuredSetupInfo> SecuredSetupInfo = GenerateJsonDeserializationRoutine<SecuredSetupInfo>();\n+        public static readonly Func<BlittableJsonReaderObject, UserDomainsResult> UserDomainsResult = GenerateJsonDeserializationRoutine<UserDomainsResult>();\n+\n+        public static readonly Func<BlittableJsonReaderObject, SetupInfo> SetupInfo = GenerateJsonDeserializationRoutine<SetupInfo>();\n \n         public static readonly Func<BlittableJsonReaderObject, UnsecuredSetupInfo> UnsecuredSetupInfo = GenerateJsonDeserializationRoutine<UnsecuredSetupInfo>();\n \n         public static readonly Func<BlittableJsonReaderObject, ClaimDomainInfo> ClaimDomainInfo = GenerateJsonDeserializationRoutine<ClaimDomainInfo>();\n+        \n+        public static readonly Func<BlittableJsonReaderObject, ListDomainsInfo> ListDomainsInfo = GenerateJsonDeserializationRoutine<ListDomainsInfo>();\n \n         public static readonly Func<BlittableJsonReaderObject, RestoreSettings> RestoreSettings = GenerateJsonDeserializationRoutine<RestoreSettings>();\n "
    },
    {
      "filename": "src/Raven.Server/Program.cs",
      "status": "modified",
      "patch": "@@ -1,9 +1,13 @@\n using System;\n+using System.Collections.Generic;\n+using System.IO;\n using System.Linq;\n using System.Runtime.Loader;\n using System.Threading;\n using System.Threading.Tasks;\n using Microsoft.Extensions.CommandLineUtils;\n+using Newtonsoft.Json;\n+using Raven.Server.Commercial;\n using Raven.Server.Config;\n using Raven.Server.Documents.Handlers.Debugging;\n using Raven.Server.ServerWide;\n@@ -81,6 +85,9 @@ public static int Main(string[] args)\n                 {\n                     Console.WriteLine(\"\\nRestarting Server...\");\n                     rerun = false;\n+\n+                    configuration = new RavenConfiguration(null, ResourceType.Server, CommandLineSwitches.CustomConfigPath);\n+                    configuration.Initialize();\n                 }\n \n                 try\n@@ -132,7 +139,7 @@ public static int Main(string[] args)\n                             Console.ForegroundColor = prevColor;\n \n                             IsRunningNonInteractive = false;\n-                            rerun = CommandLineSwitches.NonInteractive ? RunAsNonInteractive() : RunInteractive(server);\n+                            rerun = CommandLineSwitches.NonInteractive || configuration.Core.SetupMode == SetupMode.Initial ? RunAsNonInteractive() : RunInteractive(server);\n \n                             Console.WriteLine(\"Starting shut down...\");\n                             if (Logger.IsInfoEnabled)"
    },
    {
      "filename": "src/Raven.Server/RavenServer.cs",
      "status": "modified",
      "patch": "@@ -108,7 +108,7 @@ public TcpListenerStatus GetTcpServerStatus()\n         public void Initialize()\n         {\n             var sp = Stopwatch.StartNew();\n-            var clusterCert = InitializeClusterCertificate(out var httpsCert);\n+            var clusterCert = InitializeClusterCertificate();\n             try\n             {\n                 ServerStore.Initialize();\n@@ -145,12 +145,11 @@ void ConfigureKestrel(KestrelServerOptions options)\n                     if (Configuration.Http.MaxRequestBufferSize.HasValue)\n                         options.Limits.MaxRequestBufferSize = Configuration.Http.MaxRequestBufferSize.Value.GetValue(SizeUnit.Bytes);\n \n-                    var actualCert = httpsCert ?? clusterCert;\n-                    if (actualCert != null)\n+                    if (clusterCert != null)\n                     {\n                         var adapterOptions = new HttpsConnectionAdapterOptions\n                         {\n-                            ServerCertificate = actualCert.Certificate,\n+                            ServerCertificate = clusterCert.Certificate,\n                             CheckCertificateRevocation = true,\n                             ClientCertificateMode = ClientCertificateMode.AllowCertificate,\n                             SslProtocols = SslProtocols.Tls12,\n@@ -216,7 +215,7 @@ void ConfigureKestrel(KestrelServerOptions options)\n                     // ReSharper disable once AccessToDisposedClosure\n                     .Build();\n \n-                ClusterCertificateHolder = ClusterCertificateHolder ?? httpsCert ?? new CertificateHolder();\n+                ClusterCertificateHolder = ClusterCertificateHolder ?? new CertificateHolder();\n             }\n             catch (Exception e)\n             {\n@@ -252,16 +251,9 @@ void ConfigureKestrel(KestrelServerOptions options)\n             }\n         }\n \n-        public CertificateHolder InitializeClusterCertificate(out CertificateHolder httpsCert)\n+        public CertificateHolder InitializeClusterCertificate()\n         {\n             var clusterCert = LoadCertificate(\n-                Configuration.Security.Base64,\n-                Configuration.Security.ClusterCertificateExec,\n-                Configuration.Security.ClusterCertificateExecArguments,\n-                Configuration.Security.ClusterCertificatePath,\n-                Configuration.Security.ClusterCertificatePassword);\n-\n-            httpsCert = LoadCertificate(\n                 Configuration.Security.Base64,\n                 Configuration.Security.CertificateExec,\n                 Configuration.Security.CertificateExecArguments,\n@@ -274,7 +266,7 @@ public CertificateHolder InitializeClusterCertificate(out CertificateHolder http\n                     Configuration.Security.SslProxyCertificatePassword);\n \n \n-            ClusterCertificateHolder = clusterCert ?? httpsCert ?? new CertificateHolder();\n+            ClusterCertificateHolder = clusterCert ?? new CertificateHolder();\n             return clusterCert;\n         }\n \n@@ -297,11 +289,12 @@ private CertificateHolder LoadCertificate(string base64, string exec, string exe\n             try\n             {\n                 if (string.IsNullOrEmpty(base64) == false)\n-                    return ServerStore.Secrets.LoadCertificateFromBase64(base64);\n-                if (string.IsNullOrEmpty(exec) == false)\n-                    return ServerStore.Secrets.LoadCertificateWithExecutable(exec, execArgs);\n+                    return ServerStore.Secrets.LoadCertificateFromBase64(base64, password);\n                 if (string.IsNullOrEmpty(path) == false)\n                     return ServerStore.Secrets.LoadCertificateFromPath(path, password);\n+                if (string.IsNullOrEmpty(exec) == false)\n+                    return ServerStore.Secrets.LoadCertificateWithExecutable(exec, execArgs);\n+                \n                 return null;\n             }\n             catch (Exception e)"
    },
    {
      "filename": "src/Raven.Server/ServerWide/SecretProtection.cs",
      "status": "modified",
      "patch": "@@ -426,7 +426,7 @@ public X509Certificate2 LoadProxyCertificateFromPath(string path, string passwor\n             return loadedCertificate;\n         }\n \n-        public RavenServer.CertificateHolder LoadCertificateFromBase64(string certificate)\n+        public RavenServer.CertificateHolder LoadCertificateFromBase64(string certificate, string password)\n         {\n             var source = \"settings.json\";\n             try\n@@ -441,21 +441,21 @@ public RavenServer.CertificateHolder LoadCertificateFromBase64(string certificat\n                     throw new ArgumentException($\"Unable to parse the {certificate} property, expected a Base64 value\", e);\n                 }\n \n-                var loadedCertificate = new X509Certificate2(certBytes);\n+                var loadedCertificate = new X509Certificate2(certBytes, password);\n \n-                return ValidateCertificateAndCreateCertificateHolder(certificate, source, loadedCertificate, certBytes);\n+                return ValidateCertificateAndCreateCertificateHolder(certificate, source, loadedCertificate, certBytes, password);\n             }\n             catch (Exception e)\n             {\n                 throw new InvalidOperationException($\"Could not load certificate from {source}\", e);\n             }\n         }\n \n-        public static RavenServer.CertificateHolder ValidateCertificateAndCreateCertificateHolder(string certificate, string source, X509Certificate2 loadedCertificate, byte[] certBytes)\n+        public static RavenServer.CertificateHolder ValidateCertificateAndCreateCertificateHolder(string certificate, string source, X509Certificate2 loadedCertificate, byte[] certBytes, string password)\n         {\n             ValidateExpiration(source, loadedCertificate);\n \n-            ValidatePrivateKey(source, null, certBytes, out var privateKey);\n+            ValidatePrivateKey(source, password, certBytes, out var privateKey);\n \n             ValidateKeyUsages(source, loadedCertificate);\n "
    },
    {
      "filename": "src/Raven.Server/ServerWide/ServerStore.cs",
      "status": "modified",
      "patch": "@@ -86,7 +86,6 @@ public class ServerStore : IDisposable\n         public readonly NotificationCenter.NotificationCenter NotificationCenter;\n         public readonly ServerDashboardNotifications ServerDashboardNotifications;\n         public readonly LicenseManager LicenseManager;\n-        public readonly SetupManager SetupManager;\n         public readonly FeedbackSender FeedbackSender;\n         public readonly SecretProtection Secrets;\n \n@@ -120,8 +119,6 @@ public ServerStore(RavenConfiguration configuration, RavenServer server)\n \n             LicenseManager = new LicenseManager(this);\n \n-            SetupManager = new SetupManager(this);\n-\n             FeedbackSender = new FeedbackSender();\n \n             DatabaseInfoCache = new DatabaseInfoCache();\n@@ -1030,7 +1027,6 @@ public void Dispose()\n                         _engine,\n                         NotificationCenter,\n                         LicenseManager,\n-                        SetupManager,\n                         DatabasesLandlord,\n                         _env,\n                         ContextPool,"
    },
    {
      "filename": "src/Raven.Server/Web/Authentication/AdminCertificatesHandler.cs",
      "status": "modified",
      "patch": "@@ -1,5 +1,4 @@\n \ufeffusing System;\n-using System.Collections;\n using System.Collections.Generic;\n using System.IO;\n using System.Linq;\n@@ -9,7 +8,6 @@\n using System.Threading.Tasks;\n using Microsoft.AspNetCore.Http.Features.Authentication;\n using Raven.Client;\n-using Raven.Client.Documents.Operations;\n using Raven.Client.ServerWide.Operations.Certificates;\n using Raven.Server.Config;\n using Raven.Server.Documents;\n@@ -86,9 +84,7 @@ private async Task<byte[]> GenerateCertificateInternal(TransactionOperationConte\n                 var keys = new[]\n                 {\n                     RavenConfiguration.GetKey(x => x.Security.CertificatePath),\n-                    RavenConfiguration.GetKey(x => x.Security.CertificateExec),\n-                    RavenConfiguration.GetKey(x => x.Security.ClusterCertificatePath),\n-                    RavenConfiguration.GetKey(x => x.Security.ClusterCertificateExec)\n+                    RavenConfiguration.GetKey(x => x.Security.CertificateExec)\n                 };\n \n                 throw new InvalidOperationException($\"Cannot generate the client certificate '{certificate.Name}' becuase the server certificate is not loaded. \" +\n@@ -172,9 +168,7 @@ public static void ValidateCaExistsInOsStores(string base64Cert, string name, Se\n                     var path = new[]\n                     {\n                         serverStore.Configuration.Security.CertificatePath,\n-                        serverStore.Configuration.Security.ClusterCertificatePath,\n                         serverStore.Configuration.Security.CertificateExec,\n-                        serverStore.Configuration.Security.ClusterCertificateExec\n                     }.FirstOrDefault(File.Exists) ?? \"no path defined\";\n \n                     throw new InvalidOperationException($\"Cannot save the client certificate '{name}'. \" +"
    },
    {
      "filename": "src/Raven.Server/Web/System/SetupHandler.cs",
      "status": "modified",
      "patch": "@@ -1,52 +1,108 @@\n-\ufeffusing System;\n+using System;\n using System.Collections.Generic;\n using System.IO;\n-using System.IO.Compression;\n using System.Linq;\n using System.Net;\n using System.Net.Http;\n using System.Net.NetworkInformation;\n using System.Security.Cryptography.X509Certificates;\n using System.Text;\n using System.Threading.Tasks;\n+using Microsoft.Extensions.Primitives;\n using Newtonsoft.Json;\n-using Raven.Client;\n-using Raven.Client.ServerWide.Operations.Certificates;\n+using Raven.Client.Documents.Conventions;\n+using Raven.Client.Documents.Session;\n using Raven.Server.Commercial;\n using Raven.Server.Documents;\n using Raven.Server.Json;\n using Raven.Server.Routing;\n using Raven.Server.ServerWide;\n-using Raven.Server.ServerWide.Commands;\n using Raven.Server.ServerWide.Context;\n-using Raven.Server.Smuggler.Documents;\n-using Raven.Server.Utils;\n-using Raven.Server.Web.Authentication;\n using Sparrow.Json;\n-using Sparrow.Json.Parsing;\n-using Sparrow.Platform;\n \n namespace Raven.Server.Web.System\n {\n     public class SetupHandler : RequestHandler\n     {\n-        [RavenAction(\"/setup/claim\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n-        public async Task ClaimDomain()\n+        [RavenAction(\"/setup/dns-n-cert\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n+        public async Task DnsCertBridge() \n         {\n             AssertOnlyInSetupMode();\n+            var action = GetQueryStringValueAndAssertIfSingleAndNotEmpty(\"action\"); // Action can be: claim | user-domains | check-availability\n \n-            using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n-            using (var setupInfoJson = context.ReadForMemory(RequestBodyStream(), \"claim-domain\"))\n+            using (var reader = new StreamReader(RequestBodyStream()))\n             {\n-                var claimDomainInfo = JsonDeserializationServer.ClaimDomainInfo(setupInfoJson);\n+                var payload = await reader.ReadToEndAsync();\n+                var content = new StringContent(payload, Encoding.UTF8, \"application/json\");\n+                var response = await ApiHttpClient.Instance.PostAsync(\"/api/v1/dns-n-cert/\" + action, content).ConfigureAwait(false);\n \n-                var response = await ApiHttpClient.Instance.PostAsync(\"/api/v4/dns-n-cert/claim\",\n-                        new StringContent(JsonConvert.SerializeObject(claimDomainInfo), Encoding.UTF8, \"application/json\"))\n-                    .ConfigureAwait(false);\n+                HttpContext.Response.StatusCode = (int)response.StatusCode;\n+                using (var responseStream = await response.Content.ReadAsStreamAsync())\n+                {\n+                    await responseStream.CopyToAsync(ResponseBodyStream());\n+                }\n+            }\n+        }\n+\n+        [RavenAction(\"/setup/user-domains\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n+        public async Task UserDomains()\n+        {\n+            AssertOnlyInSetupMode();\n+            \n+            using (var reader = new StreamReader(RequestBodyStream()))\n+            {\n+                var payload = await reader.ReadToEndAsync();\n+                var content = new StringContent(payload, Encoding.UTF8, \"application/json\");\n+                var response = await ApiHttpClient.Instance.PostAsync(\"/api/v1/dns-n-cert/user-domains\", content).ConfigureAwait(false);\n \n                 HttpContext.Response.StatusCode = (int)response.StatusCode;\n-                var serverResponse = await response.Content.ReadAsStreamAsync();\n-                await serverResponse.CopyToAsync(ResponseBodyStream());\n+                \n+                if (response.IsSuccessStatusCode == false)\n+                {\n+                    using (var responseStream = await response.Content.ReadAsStreamAsync())\n+                    {\n+                        await responseStream.CopyToAsync(ResponseBodyStream());\n+                    }\n+                    return;\n+                }\n+\n+                using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n+                {\n+                    var responseString = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n+                    var results = JsonConvert.DeserializeObject<UserDomainsResult>(responseString);\n+\n+                    var fullResult = new UserDomainsWithIps()\n+                    {\n+                        Email = results.Email,\n+                        Domains = new Dictionary<string, List<SubDomainAndIps>>()\n+                    };\n+\n+                    foreach (var domain in results.Domains)\n+                    {\n+                        var list = new List<SubDomainAndIps>();\n+                        foreach (var subDomain in domain.Value)\n+                        {\n+                            try\n+                            {\n+                                list.Add(new SubDomainAndIps\n+                                {\n+                                    SubDomain = subDomain,\n+                                    Ips = Dns.GetHostAddresses($\"{subDomain}.{domain.Key}.{SetupManager.RavenDbDomain}\").Select(ip => ip.ToString()).ToList(),\n+                                });\n+                            }\n+                            catch (Exception e)\n+                            {\n+                                throw new InvalidOperationException($\"Failed to query the ips for host {subDomain}.{domain.Key}.{SetupManager.RavenDbDomain}\", e);\n+                            }\n+                        }\n+                        fullResult.Domains.Add(domain.Key, list);\n+                    }\n+                    using (var writer = new BlittableJsonTextWriter(context, ResponseBodyStream()))\n+                    {\n+                        var blittable = EntityToBlittable.ConvertEntityToBlittable(fullResult, DocumentConventions.Default, context);\n+                        context.Write(writer, blittable);\n+                    }\n+                }\n             }\n         }\n \n@@ -85,23 +141,93 @@ public Task GetIps()\n             return Task.CompletedTask;\n         }\n \n+        [RavenAction(\"/setup/hosts\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n+        public Task GetHosts()\n+        {\n+            AssertOnlyInSetupMode();\n+\n+            using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n+            using (var certificateJson = context.ReadForMemory(RequestBodyStream(), \"setup-certificate\"))\n+            {\n+                var certDef = JsonDeserializationServer.CertificateDefinition(certificateJson);\n+\n+                X509Extension sanNames;\n+                X509Certificate2 certificate = null;\n+                string cn;\n+\n+                try\n+                {\n+                    certificate = certDef.Password == null\n+                        ? new X509Certificate2(Convert.FromBase64String(certDef.Certificate))\n+                        : new X509Certificate2(Convert.FromBase64String(certDef.Certificate), certDef.Password);\n+\n+                    cn = certificate.GetNameInfo(X509NameType.DnsName, false);\n+                    sanNames = certificate.Extensions[\"2.5.29.17\"]; // Alternative names\n+                }\n+                catch (Exception e)\n+                {\n+                    throw new InvalidOperationException($\"Failed to extract CN and SAN from certificate {certificate?.FriendlyName}. Maybe password is wrong?\", e);\n+                }\n+\n+                using (var writer = new BlittableJsonTextWriter(context, ResponseBodyStream()))\n+                {\n+                    writer.WriteStartObject();\n+                    writer.WritePropertyName(\"CN\");\n+                    writer.WriteString(cn);\n+\n+                    if (sanNames != null)\n+                    {\n+                        writer.WriteComma();\n+                        writer.WritePropertyName(\"AlternativeNames\");\n+                        writer.WriteStartArray();\n+                        var first = true;\n+                        foreach (var line in sanNames.Format(true).Split(new[] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries))\n+                        {\n+                            var parts = line.Split('=');\n+                            var value = parts.Length > 0 ? parts[1] : null;\n+\n+                            if (first == false)\n+                                writer.WriteComma();\n+                            first = false;\n+                            writer.WriteString(value);\n+                        }\n+                        writer.WriteEndArray();\n+                    }\n+\n+                    writer.WriteEndObject();\n+                }\n+            }\n+            return Task.CompletedTask;\n+        }\n+\n         [RavenAction(\"/setup/unsecured\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n         public Task SetupUnsecured()\n         {\n             AssertOnlyInSetupMode();\n-            // also get public server url and setup server, make sure we can access it, etc.\n-            // validate by getting a GUID from the temp server.\n \n             using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n             using (var setupInfoJson = context.ReadForMemory(RequestBodyStream(), \"setup-unsecured\"))\n             {\n                 var setupInfo = JsonDeserializationServer.UnsecuredSetupInfo(setupInfoJson);\n-                // also set public server url\n-                SetupManager.WriteSettingsJsonFile(null, null, setupInfo.ServerUrl, SetupManager.SettingsFileName, SetupMode.Unsecured, true);\n+\n+                var settingsJson = File.ReadAllText(SetupManager.SettingsPath);\n+\n+                dynamic jsonObj = JsonConvert.DeserializeObject(settingsJson);\n+                jsonObj[\"Setup.Mode\"] = SetupMode.Unsecured.ToString();\n+                jsonObj[\"Security.UnsecuredAccessAllowed\"] = \"PublicNetwork\";\n+                jsonObj[\"ServerUrl\"] = setupInfo.ServerUrl;\n+                jsonObj.Remove(\"PublicServerUrl\");\n+                if (string.IsNullOrEmpty(setupInfo.PublicServerUrl) == false)\n+                {\n+                    jsonObj[\"PublicServerUrl\"] = setupInfo.PublicServerUrl;                    \n+                }\n+                jsonObj[\"Security.Certificate.Base64\"] = null;\n+                var json = JsonConvert.SerializeObject(jsonObj, Formatting.Indented);\n+\n+                SetupManager.WriteSettingsJsonLocally(SetupManager.SettingsPath, json);\n             }\n \n-            HttpContext.Response.StatusCode = (int)HttpStatusCode.OK;\n-            return Task.CompletedTask;\n+            return NoContent();\n         }\n \n         [RavenAction(\"/setup/secured\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n@@ -110,74 +236,33 @@ public async Task SetupSecured()\n             AssertOnlyInSetupMode();\n \n             var stream = TryGetRequestFromStream(\"Options\") ?? RequestBodyStream();\n+            var operationCancelToken = new OperationCancelToken(ServerStore.ServerShutdown);\n+            var operationId = GetLongQueryString(\"operationId\", false);\n+\n+            if (operationId.HasValue == false)\n+                operationId = ServerStore.Operations.GetNextOperationId();\n \n             using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n             using (var setupInfoJson = context.ReadForMemory(stream, \"setup-secured\"))\n             {\n+                var setupInfo = JsonDeserializationServer.SetupInfo(setupInfoJson);\n \n-                var setupInfo = JsonDeserializationServer.SecuredSetupInfo(setupInfoJson);\n-\n-                foreach (var node in setupInfo.NodeSetupInfos)\n-                {\n-                    if (string.IsNullOrWhiteSpace(node.Certificate))\n-                        throw new ArgumentException($\"{nameof(node.Certificate)} is a mandatory property for a secured setup\");\n-                    if (string.IsNullOrWhiteSpace(node.ServerUrl))\n-                        throw new ArgumentException($\"{nameof(node.ServerUrl)} is a mandatory property for a secured setup\");\n-                    if (string.IsNullOrWhiteSpace(node.NodeTag))\n-                        throw new ArgumentException($\"{nameof(node.NodeTag)} is a mandatory property for a secured setup\");\n-\n-                    if (PlatformDetails.RunningOnPosix)\n-                    {\n-                        AdminCertificatesHandler.ValidateCaExistsInOsStores(node.Certificate, \"Setup server certificate\", ServerStore);\n-                    }\n-                }\n-\n-                // Prepare settings.json files, and write the local one to disk\n-                var settingsPath = SetupManager.SettingsFileName;\n-                var jsons = new Dictionary<string, string>();\n-                SecuredSetupInfo.NodeInfo localNode = null;\n-\n-                foreach (var node in setupInfo.NodeSetupInfos)\n-                {\n-                    try\n-                    {\n-                        if (node.NodeTag == \"A\")\n-                        {\n-                            jsons.Add(node.NodeTag,\n-                                SetupManager.WriteSettingsJsonFile(node.Certificate, node.PublicServerUrl, node.ServerUrl, settingsPath, SetupMode.Secured, modifyLocalServer: true));\n-                            localNode = node;\n-                        }\n-                        else\n-                            jsons.Add(node.NodeTag, SetupManager.WriteSettingsJsonFile(node.Certificate, node.PublicServerUrl, node.ServerUrl, settingsPath, SetupMode.Secured, modifyLocalServer: false));\n-                    }\n-                    catch (Exception e)\n-                    {\n-                        throw new InvalidOperationException($\"Failed to update {settingsPath} with new configuration.\", e);\n-                    }\n-                }\n-\n-                // Here we need to take the jsons, create files and zip them all together\n-                // Need to make this an async operation, just like when sending a certificate for the studio... to know that we're done and sending a file\n-                var zip = new byte[]{};\n+                var operationResult = await ServerStore.Operations.AddOperation(\n+                    null,\n+                    \"Setting up RavenDB in secured mode.\",\n+                    Documents.Operations.Operations.OperationType.Setup,\n+                    progress => SetupManager.SetupSecuredTask(progress, operationCancelToken.Token, setupInfo, ServerStore),\n+                    operationId.Value, operationCancelToken);\n                 \n-                try\n-                {\n-                    var ips = localNode?.Ips.Select(ip => new IPEndPoint(IPAddress.Parse(ip), localNode.Port)).ToArray();\n-\n-                    var certBytes = Convert.FromBase64String(localNode?.Certificate);\n-                    var x509Certificate2 = new X509Certificate2(certBytes);\n-                    ServerStore.SetupManager.AssertServerCanStartSecured(x509Certificate2, localNode?.ServerUrl, ips, settingsPath);\n-\n-                    // Load the certificate in the local server, so we can generate client certs later\n-                    Server.ClusterCertificateHolder = SecretProtection.ValidateCertificateAndCreateCertificateHolder(localNode?.Certificate, \"Setup\", x509Certificate2, certBytes);\n-                }\n-                catch (Exception e)\n-                {\n-                    throw new InvalidOperationException($\"Failed to start server with the new configuration {settingsPath}.\", e);\n-\n-                }\n+                var zip = ((SetupProgressAndResult)operationResult).SettingsZipFile;\n+                \n+                var nodeCert = setupInfo.Password == null\n+                    ? new X509Certificate2(Convert.FromBase64String(setupInfo.Certificate))\n+                    : new X509Certificate2(Convert.FromBase64String(setupInfo.Certificate), setupInfo.Password);\n+                \n+                var cn = nodeCert.GetNameInfo(X509NameType.DnsName, false);\n \n-                var contentDisposition = \"attachment; filename=settings.zip\";\n+                var contentDisposition = $\"attachment; filename={cn}.Cluster.Settings.zip\";\n                 HttpContext.Response.Headers[\"Content-Disposition\"] = contentDisposition;\n                 HttpContext.Response.ContentType = \"binary/octet-stream\";\n \n@@ -191,106 +276,86 @@ public async Task SetupAgreement()\n         {\n             AssertOnlyInSetupMode();\n \n+            var email = GetQueryStringValueAndAssertIfSingleAndNotEmpty(\"email\");\n+\n             using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n-            using (var setupInfoJson = context.ReadForMemory(RequestBodyStream(), \"claim-domain\"))\n             {\n-                var setupInfo = JsonDeserializationServer.SecuredSetupInfo(setupInfoJson);\n-\n-                var uri = await ServerStore.SetupManager.LetsEncryptAgreement(setupInfo.Email);\n+                var baseUri = new Uri(\"https://letsencrypt.org/\");\n+                var uri = new Uri(baseUri, await SetupManager.LetsEncryptAgreement(email));\n \n                 using (var writer = new BlittableJsonTextWriter(context, ResponseBodyStream()))\n                 {\n                     writer.WriteStartObject();\n                     writer.WritePropertyName(\"Uri\");\n-                    writer.WriteString(uri.AbsolutePath);\n+                    writer.WriteString(uri.AbsoluteUri);\n                     writer.WriteEndObject();\n                 }\n             }\n-\n-            HttpContext.Response.StatusCode = (int)HttpStatusCode.OK;\n         }\n \n         [RavenAction(\"/setup/letsencrypt\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n-        public Task SetupLetsEncrypt()\n+        public async Task SetupLetsEncrypt()\n         {\n             AssertOnlyInSetupMode();\n \n             var stream = TryGetRequestFromStream(\"Options\") ?? RequestBodyStream();\n \n+            var operationCancelToken = new OperationCancelToken(ServerStore.ServerShutdown);\n+            var operationId = GetLongQueryString(\"operationId\", false);\n+\n+            if (operationId.HasValue == false)\n+                operationId = ServerStore.Operations.GetNextOperationId();\n \n             using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n             using (var setupInfoJson = context.ReadForMemory(stream, \"setup-lets-encrypt\"))\n             {\n-                var setupInfo = JsonDeserializationServer.SecuredSetupInfo(setupInfoJson);\n-\n-                var operationCancelToken = new OperationCancelToken(ServerStore.ServerShutdown);\n-                var operationId = ServerStore.Operations.GetNextOperationId();\n-\n-                ServerStore.Operations.AddOperation(\n-                    null,\n-                    \"Setting up RavenDB with a Let's Encrypt certificate\",\n-                    Documents.Operations.Operations.OperationType.SetupLetsEncrypt,\n-                    progress => ServerStore.SetupManager.FetchCertificateTask(progress, operationCancelToken.Token, setupInfo),\n-                    operationId, operationCancelToken);\n+                var setupInfo = JsonDeserializationServer.SetupInfo(setupInfoJson);\n \n-                using (var writer = new BlittableJsonTextWriter(context, ResponseBodyStream()))\n-                {\n-                    writer.WriteOperationId(context, operationId);\n-                }\n+                var operationResult = await ServerStore.Operations.AddOperation(\n+                    null, \"Setting up RavenDB with a Let's Encrypt certificate\",\n+                    Documents.Operations.Operations.OperationType.Setup,\n+                    progress => SetupManager.SetupLetsEncryptTask(progress, operationCancelToken.Token, setupInfo, ServerStore),\n+                    operationId.Value, operationCancelToken);\n \n-                // Here we need to take the jsons, create files and zip them all together\n-                // Need to make this an async operation, just like when sending a certificate for the studio... to know that we're done and sending a file\n-                var zip = new byte[]{};\n+                var zip = ((SetupProgressAndResult)operationResult).SettingsZipFile;\n \n-                var contentDisposition = \"attachment; filename=settings.zip\";\n+                var contentDisposition = $\"attachment; filename={setupInfo.Domain}.Cluster.Settings.zip\";\n                 HttpContext.Response.Headers[\"Content-Disposition\"] = contentDisposition;\n                 HttpContext.Response.ContentType = \"binary/octet-stream\";\n \n                 HttpContext.Response.StatusCode = (int)HttpStatusCode.Created;\n                 HttpContext.Response.Body.Write(zip, 0, zip.Length);\n-                return Task.CompletedTask;\n             }\n         }\n \n-        [RavenAction(\"/setup/generate\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n-        public async Task Generate()\n+        [RavenAction(\"/setup/validate\", \"POST\", AuthorizationStatus.UnauthenticatedClients)]\n+        public async Task SetupValidate()\n         {\n             AssertOnlyInSetupMode();\n \n-            ServerStore.EnsureNotPassive();\n-\n-            using (ServerStore.ContextPool.AllocateOperationContext(out TransactionOperationContext ctx))\n-            {\n-                var operationId = GetLongQueryString(\"operationId\", false);\n-                if (operationId.HasValue == false)\n-                    operationId = ServerStore.Operations.GetNextOperationId();\n-\n-                var stream = TryGetRequestFromStream(\"Options\") ?? RequestBodyStream();\n-\n-                var certificateJson = ctx.ReadForDisk(stream, \"certificate-generation\");\n-\n-                var certificate = JsonDeserializationServer.CertificateDefinition(certificateJson);\n+            var stream = TryGetRequestFromStream(\"Options\") ?? RequestBodyStream();\n \n-                byte[] pfx = null;\n-                await\n-                    ServerStore.Operations.AddOperation(\n-                        null,\n-                        \"Generate certificate: \" + certificate.Name,\n-                        Documents.Operations.Operations.OperationType.CertificateGeneration,\n-                        async onProgress =>\n-                        {\n-                            pfx = await GenerateCertificateInternal(certificate);\n+            var setupModeString = GetQueryStringValueAndAssertIfSingleAndNotEmpty(\"setupMode\");\n+            var setupMode = (SetupMode)Enum.Parse(typeof(SetupMode), setupModeString);\n \n-                            return ClientCertificateGenerationResult.Instance;\n-                        },\n-                        operationId.Value);\n+            var operationCancelToken = new OperationCancelToken(ServerStore.ServerShutdown);\n+            var operationId = GetLongQueryString(\"operationId\", false);\n \n-                var contentDisposition = \"attachment; filename=\" + Uri.EscapeDataString(certificate.Name) + \".pfx\";\n-                HttpContext.Response.Headers[\"Content-Disposition\"] = contentDisposition;\n-                HttpContext.Response.ContentType = \"binary/octet-stream\";\n+            if (operationId.HasValue == false)\n+                operationId = ServerStore.Operations.GetNextOperationId();\n \n-                HttpContext.Response.StatusCode = (int)HttpStatusCode.Created;\n-                HttpContext.Response.Body.Write(pfx, 0, pfx.Length);\n+            using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n+            using (var setupInfoJson = context.ReadForMemory(stream, \"setup-validate\"))\n+            {\n+                var setupInfo = JsonDeserializationServer.SetupInfo(setupInfoJson);\n+                \n+                await ServerStore.Operations.AddOperation(\n+                    null,\n+                    \"Setting up RavenDB in secured mode.\",\n+                    Documents.Operations.Operations.OperationType.Setup,\n+                    progress => SetupManager.SetupValidateTask(progress, operationCancelToken.Token, setupInfo, ServerStore, setupMode),\n+                    operationId.Value, operationCancelToken);\n+                \n             }\n         }\n \n@@ -309,7 +374,7 @@ public Task SetupFinish()\n                 Program.ShutdownServerMre.Set();\n             });\n \n-            return Task.CompletedTask;\n+            return NoContent();\n         }\n \n         [RavenAction(\"/admin/setup/letsencrypt/force-renew\", \"POST\", AuthorizationStatus.ClusterAdmin)]\n@@ -318,16 +383,16 @@ public Task ForceRenew()\n             using (ServerStore.ContextPool.AllocateOperationContext(out JsonOperationContext context))\n             using (var setupInfoJson = context.ReadForDisk(RequestBodyStream(), \"setup-lets-encrypt\"))\n             {\n-                var setupInfo = JsonDeserializationServer.SecuredSetupInfo(setupInfoJson);\n+                var setupInfo = JsonDeserializationServer.SetupInfo(setupInfoJson);\n \n                 var operationCancelToken = new OperationCancelToken(ServerStore.ServerShutdown);\n                 var operationId = ServerStore.Operations.GetNextOperationId();\n \n                 ServerStore.Operations.AddOperation(\n                     null,\n                     \"Setting up RavenDB with a Let's Encrypt certificate\",\n-                    Documents.Operations.Operations.OperationType.SetupLetsEncrypt,\n-                    progress => ServerStore.SetupManager.FetchCertificateTask(progress, operationCancelToken.Token, setupInfo),\n+                    Documents.Operations.Operations.OperationType.Setup,\n+                    progress => SetupManager.SetupLetsEncryptTask(progress, operationCancelToken.Token, setupInfo, ServerStore),\n                     operationId, operationCancelToken);\n \n                 using (var writer = new BlittableJsonTextWriter(context, ResponseBodyStream()))\n@@ -347,37 +412,5 @@ private void AssertOnlyInSetupMode()\n \n             throw new UnauthorizedAccessException(\"RavenDB has already been setup. Cannot use the /setup endpoints any longer.\");\n         }\n-        \n-        // Duplicate of AdminCertificatesHandler.GenerateCertificateInternal, but used by an unauthenticated client during setup only\n-        private async Task<byte[]> GenerateCertificateInternal(CertificateDefinition certificate)\n-        {\n-            if (string.IsNullOrWhiteSpace(certificate.Name))\n-                throw new ArgumentException($\"{nameof(certificate.Name)} is a required field in the certificate definition\");\n-\n-            if (Server.ClusterCertificateHolder?.Certificate == null)\n-                throw new InvalidOperationException($\"Cannot generate the client certificate '{certificate.Name}' becuase the server certificate is not loaded.\");\n-\n-            if (PlatformDetails.RunningOnPosix)\n-            {\n-                AdminCertificatesHandler.ValidateCaExistsInOsStores(certificate.Certificate, certificate.Name, ServerStore);\n-            }\n-\n-            // this creates a client certificate which is signed by the current server certificate\n-            var selfSignedCertificate = CertificateUtils.CreateSelfSignedClientCertificate(certificate.Name, Server.ClusterCertificateHolder);\n-\n-            var res = await ServerStore.PutValueInClusterAsync(new PutCertificateCommand(Constants.Certificates.Prefix + selfSignedCertificate.Thumbprint,\n-                new CertificateDefinition\n-                {\n-                    Name = certificate.Name,\n-                    // this does not include the private key, that is only for the client\n-                    Certificate = Convert.ToBase64String(selfSignedCertificate.Export(X509ContentType.Cert)),\n-                    Permissions = certificate.Permissions,\n-                    SecurityClearance = certificate.SecurityClearance,\n-                    Thumbprint = selfSignedCertificate.Thumbprint\n-                }));\n-            await ServerStore.Cluster.WaitForIndexNotification(res.Index);\n-\n-            return selfSignedCertificate.Export(X509ContentType.Pfx, certificate.Password);\n-        }\n     }\n }"
    },
    {
      "filename": "src/Raven.Server/Web/System/StudioHandler.cs",
      "status": "modified",
      "patch": "@@ -21,6 +21,7 @@\n using Microsoft.AspNetCore.Http;\n using Raven.Client;\n using Raven.Client.Extensions.Streams;\n+using Raven.Server.Commercial;\n using Sparrow.Collections;\n using Sparrow.Threading;\n using StringSegment = Sparrow.StringSegment;\n@@ -157,15 +158,52 @@ public Task StudioAuthError()\n             return HttpContext.Response.WriteAsync(HtmlUtil.RenderStudioAuthErrorPage(error));\n         }\n \n+        [RavenAction(\"/server-setup/index.html\", \"GET\", AuthorizationStatus.UnauthenticatedClients)]\n+        public Task GetSetupIndexFile()\n+        {\n+            // if user asks for entry point but we are already configured redirect to studio\n+            if (ServerStore.Configuration.Core.SetupMode != SetupMode.Initial)\n+            {\n+                HttpContext.Response.Headers[\"Location\"] = \"/studio/index.html\";\n+                HttpContext.Response.StatusCode = (int)HttpStatusCode.Moved;\n+            }\n+\n+            return GetStudioFileInternal(\"index.html\");\n+        }\n+\n+        [RavenAction(\"/server-setup/$\", \"GET\", AuthorizationStatus.UnauthenticatedClients)]\n+        public Task GetSetupFile()\n+        {\n+            string serverRelativeFileName = new StringSegment(\n+                RouteMatch.Url, RouteMatch.MatchLength, RouteMatch.Url.Length - RouteMatch.MatchLength);\n+            return GetStudioFileInternal(serverRelativeFileName);\n+        }\n+\n+        [RavenAction(\"/studio/index.html\", \"GET\", AuthorizationStatus.UnauthenticatedClients)]\n+        public Task GetStudioIndexFile()\n+        {\n+            // if user asks for entry point but we are NOT already configured redirect to setup\n+            if (ServerStore.Configuration.Core.SetupMode == SetupMode.Initial)\n+            {\n+                HttpContext.Response.Headers[\"Location\"] = \"/server-setup/index.html\";\n+                HttpContext.Response.StatusCode = (int)HttpStatusCode.Moved;\n+            }\n \n+            return GetStudioFileInternal(\"index.html\");\n+        }\n+        \n         [RavenAction(\"/studio/$\", \"GET\", AuthorizationStatus.UnauthenticatedClients)]\n-        public async Task GetStudioFile()\n+        public Task GetStudioFile()\n         {\n             // This is casted to string on purpose here. Everything else works\n             // with strings, so reifying this now is good.\n             string serverRelativeFileName = new StringSegment(\n                 RouteMatch.Url, RouteMatch.MatchLength, RouteMatch.Url.Length - RouteMatch.MatchLength);\n-\n+            return GetStudioFileInternal(serverRelativeFileName);\n+        }\n+        \n+        private async Task GetStudioFileInternal(string serverRelativeFileName)\n+        {\n             HttpContext.Response.Headers[\"Raven-Static-Served-From\"] = \"Cache\";\n             if (await ServeFromCache(serverRelativeFileName))\n                 return;\n@@ -604,6 +642,7 @@ public Task RavenRoot()\n         {\n             HttpContext.Response.Headers[\"Location\"] = \"/studio/index.html\";\n             HttpContext.Response.StatusCode = (int)HttpStatusCode.MovedPermanently;\n+           \n             return Task.CompletedTask;\n         }\n     }"
    },
    {
      "filename": "src/Raven.Server/settings.json",
      "status": "modified",
      "patch": "@@ -1,7 +1,4 @@\n \ufeff{\n-    \"ServerUrl\": \"http://localhost:8080\",\n-    \"RunInMemory\": false,\n-    \"Setup\": {\n-        \"Mode\": \"Initial\"\n-    }\n+    \"ServerUrl\": \"http://127.0.0.1:0\",\n+    \"Setup.Mode\": \"Initial\"\n }"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/checkDomainAvailabilityCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,25 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class checkDomainAvailabilityCommand extends commandBase {\n+\n+    constructor(private domainName: string, private license: Raven.Server.Commercial.License) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<domainAvailabilityResult> {\n+        const args = {\n+            action: \"domain-availability\"\n+        };\n+        const url = endpoints.global.setup.setupDnsNCert + this.urlEncodeArgs(args); \n+        const payload = {\n+            Domain: this.domainName,\n+            License: this.license\n+        };\n+\n+        return this.post(url, JSON.stringify(payload), null)\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to check domain availability\", response.responseText, response.statusText));\n+    }\n+}\n+\n+export = checkDomainAvailabilityCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/claimDomainCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,25 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class claimDomainCommand extends commandBase {\n+\n+    constructor(private domain: string, private license: Raven.Server.Commercial.License) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<void> {\n+        const args = {\n+            action: \"claim\"\n+        };\n+        const url = endpoints.global.setup.setupDnsNCert + this.urlEncodeArgs(args); \n+        const payload = { \n+            Domain: this.domain,\n+            License: this.license\n+        } as Raven.Server.Commercial.ClaimDomainInfo;\n+\n+        return this.post(url, JSON.stringify(payload), null, { dataType: undefined })\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to obtain domain information\", response.responseText, response.statusText));\n+    }\n+}\n+\n+export = claimDomainCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/finishSetupCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,18 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class finishSetupCommand extends commandBase {\n+\n+    constructor() {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<void> {\n+        const url = endpoints.global.setup.setupFinish;\n+\n+        return this.post(url, null, null, { dataType: undefined })\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to save configuration\", response.responseText, response.statusText));\n+    }\n+}\n+\n+export = finishSetupCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/listHostsForCertificateCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,34 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class listHostsForCertificateCommand extends commandBase {\n+\n+    constructor(private certificate: string, private password: string) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<Array<string>> {\n+        const url = endpoints.global.setup.setupHosts; \n+        const payload = {\n+            Certificate: this.certificate,\n+            Password: this.password\n+        };\n+\n+        const task = $.Deferred<Array<string>>();\n+        \n+        this.post(url, JSON.stringify(payload), null)\n+            .done(result => {\n+                const cns = [];\n+                cns.push(result.CN);\n+                if (result.AlternativeNames) {\n+                    cns.push(...result.AlternativeNames);\n+                }\n+                task.resolve(cns);\n+            })\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to fetch CNs from certificate\", response.responseText, response.statusText));\n+        \n+        return task;\n+    }\n+}\n+\n+export = listHostsForCertificateCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/loadAgreementCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,22 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class loadAgreementCommand extends commandBase {\n+\n+    constructor(private email: string) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<string> {\n+        const args = {\n+            email: this.email\n+        };\n+        \n+        const url = endpoints.global.setup.setupLetsencryptAgreement + this.urlEncodeArgs(args);\n+\n+        return this.query(url, null, null, x => x.Uri)\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to load Let's Encrypt agreement\", response.responseText, response.statusText));\n+    }\n+}\n+\n+export = loadAgreementCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/registrationInfoCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,35 @@\n+import commandBase = require(\"commands/commandBase\");\n+import endpoints = require(\"endpoints\");\n+\n+class registrationInfoCommand extends commandBase {\n+\n+    constructor(private license: Raven.Server.Commercial.License) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<Raven.Server.Commercial.UserDomainsWithIps> {\n+        const url = endpoints.global.setup.setupUserDomains;\n+        const payload = {\n+            License: this.license\n+        };\n+\n+        const task = $.Deferred<Raven.Server.Commercial.UserDomainsWithIps>();\n+\n+        this.post(url, JSON.stringify(payload), null)\n+            .done(result => task.resolve(result))\n+            .fail((response: JQueryXHR) => {\n+                if (response.status === 404) {\n+                    task.resolve(null);\n+                } else {\n+                    this.reportError(\"Failed to load registration information\", response.responseText, response.statusText);\n+                    task.reject();\n+                }\n+            });\n+        \n+        return task;\n+        \n+        \n+    }\n+}\n+\n+export = registrationInfoCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/commands/setup/saveUnsecuredSetupCommand.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,19 @@\n+import commandBase = require(\"commands/commandBase\");\n+import database = require(\"models/resources/database\");\n+import endpoints = require(\"endpoints\");\n+\n+class saveUnsecuredSetupCommand extends commandBase {\n+\n+    constructor(private dto: Raven.Server.Commercial.UnsecuredSetupInfo) {\n+        super();\n+    }\n+\n+    execute(): JQueryPromise<void> {\n+        const url = endpoints.global.setup.setupUnsecured;\n+\n+        return this.post(url, JSON.stringify(this.dto), null, { dataType: undefined })\n+            .fail((response: JQueryXHR) => this.reportError(\"Failed to save configuration\", response.responseText, response.statusText));\n+    }\n+}\n+\n+export = saveUnsecuredSetupCommand;"
    },
    {
      "filename": "src/Raven.Studio/typescript/common/extensions.ts",
      "status": "modified",
      "patch": "@@ -74,7 +74,7 @@ class extensions {\n             message: (params: any, url: KnockoutObservable<string>) => {\n                 return extensions.validateUrl(url());\n             }\n-        };  \n+        };\n \n         (ko.validation.rules as any)['validDatabaseName'] = {\n             validator: (val: string) => !extensions.validateDatabaseName(val),\n@@ -90,6 +90,23 @@ class extensions {\n             },\n             message: 'Invaild base64 string.'\n         };\n+        \n+        (ko.validation.rules as any)['validLicense'] = {\n+            validator: (license: string) => {\n+                try {\n+                    const parsedLicense = JSON.parse(license);\n+\n+                    const hasId = \"Id\" in parsedLicense;\n+                    const hasName = \"Name\" in parsedLicense;\n+                    const hasKeys = \"Keys\" in parsedLicense;\n+\n+                    return hasId && hasName && hasKeys;\n+                } catch (e) {\n+                    return false;\n+                }\n+            },\n+            message: \"Invalid license format\"\n+        };\n \n         (ko.validation.rules as any)['aceValidation'] = {\n             validator: (text: string) => {"
    },
    {
      "filename": "src/Raven.Studio/typescript/common/setup/routes.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,55 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+class routes {\n+\n+    static get(): Array<DurandalRouteConfiguration> {\n+        let routes = [\n+            {\n+                route: [\"\", \"welcome\"],\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/welcome\",\n+                nav: false\n+            },{\n+                route: \"unsecured\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/unsecured\",\n+                nav: false\n+            },{\n+                route: \"finish\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/finish\",\n+                nav: false\n+            },{\n+                route: \"license\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/license\",\n+                nav: false\n+            },{\n+                route: \"domain\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/domain\",\n+                nav: false\n+            },{\n+                route: \"nodes\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/nodes\",\n+                nav: false\n+            },{\n+                route: \"certificate\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/certificate\",\n+                nav: false\n+            },{\n+                route: \"agreement\",\n+                title: \"RavenDB setup wizard\",\n+                moduleId: \"viewmodels/server-setup/agreement\",\n+                nav: false\n+            }\n+        ] as Array<DurandalRouteConfiguration>;\n+\n+        return routes;\n+    }\n+\n+}\n+\n+export = routes;"
    },
    {
      "filename": "src/Raven.Studio/typescript/main.ts",
      "status": "modified",
      "patch": "@@ -49,7 +49,13 @@ define([\"durandal/system\", \"durandal/app\", \"durandal/viewLocator\", \"plugins/dial\n \n         if (\"WebSocket\" in window) {\n             //Show the app by setting the root view model for our application with a transition.\n-            app.setRoot(\"viewmodels/shell\");\n+            \n+            if (window.location.pathname.startsWith(\"/studio\")) {\n+                app.setRoot(\"viewmodels/shell\");\n+            } else {\n+                app.setRoot(\"viewmodels/server-setup/setupShell\")\n+            }\n+            \n             composition.defaultTransitionName = \"fadeIn\";\n         } else {\n             //The browser doesn't support WebSocket"
    },
    {
      "filename": "src/Raven.Studio/typescript/models/setup/certificateInfo.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,41 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+class certificateInfo {\n+    certificate = ko.observable<string>();\n+    certificatePassword = ko.observable<string>();\n+    certificateCNs = ko.observableArray<string>([]);\n+\n+    wildcardCertificate: KnockoutComputed<boolean>;\n+\n+    validationGroup: KnockoutValidationGroup;\n+\n+    constructor() {\n+        this.initValidation();\n+        \n+        this.wildcardCertificate = ko.pureComputed(() => {\n+            const cns = this.certificateCNs();\n+            return _.some(cns, x => x.startsWith(\"*\"));\n+        });\n+    }\n+\n+    private initValidation() {\n+        this.certificate.extend({\n+            required: true\n+        });\n+\n+        this.certificateCNs.extend({\n+            validation: [{\n+                validator: (val: Array<string>) => val.length > 0,\n+                message: `Certificate must contain at least one CN or Subject Alternative Name.`\n+            }]\n+        });\n+\n+        this.validationGroup = ko.validatedObservable({\n+            certificate: this.certificate,\n+            certificatePassword: this.certificatePassword,\n+            certificateCNs: this.certificateCNs\n+        });\n+    }\n+}\n+\n+export = certificateInfo;"
    },
    {
      "filename": "src/Raven.Studio/typescript/models/setup/domainInfo.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,57 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+import generalUtils = require(\"common/generalUtils\");\n+import checkDomainAvailabilityCommand = require(\"commands/setup/checkDomainAvailabilityCommand\");\n+\n+class domainInfo {\n+    private licenseProvider: () => Raven.Server.Commercial.License;\n+    \n+    domain = ko.observable<string>();\n+    userEmail = ko.observable<string>();\n+    \n+    availableDomains = ko.observableArray<string>([]);\n+    \n+    validationGroup: KnockoutValidationGroup;\n+    \n+    constructor(licenseProvider: () => Raven.Server.Commercial.License) {\n+        this.initValidation();\n+        this.licenseProvider = licenseProvider;\n+    }\n+    \n+    private initValidation() {\n+\n+        const checkDomain = (val: string, params: any, callback: (currentValue: string, result: boolean) => void) => {\n+            new checkDomainAvailabilityCommand(val, this.licenseProvider())\n+                .execute()\n+                .done(result => {\n+                    callback(this.domain(), result.Available || result.IsOwnedByMe); \n+                });\n+        };\n+        \n+        this.domain.extend({\n+            required: true,\n+            validation: {\n+                message: \"Sorry, domain name is taken.\",\n+                async: true,\n+                onlyIf: () => !!this.domain(),\n+                validator: generalUtils.debounceAndFunnel(checkDomain)\n+            }\n+        });\n+        \n+        this.userEmail.extend({\n+            required: true,\n+            email: true\n+        });\n+        \n+        this.validationGroup = ko.validatedObservable({\n+            domain: this.domain,\n+            userEmail: this.userEmail\n+        });\n+    }\n+    \n+    setDomain(value: string) {\n+        this.domain(value);\n+    }\n+}\n+\n+export = domainInfo;"
    },
    {
      "filename": "src/Raven.Studio/typescript/models/setup/ipEntry.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,25 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+class ipEntry {\n+    \n+   ip = ko.observable<string>();\n+   validationGroup: KnockoutValidationGroup;\n+   \n+   constructor() {\n+       this.ip.extend({\n+           required: true\n+       });\n+       \n+       this.validationGroup = ko.validatedObservable({\n+           ip: this.ip\n+       });\n+   }\n+   \n+   static forIp(ip: string) {\n+       const entry = new ipEntry();\n+       entry.ip(ip);\n+       return entry;\n+   }\n+}\n+\n+export = ipEntry;"
    },
    {
      "filename": "src/Raven.Studio/typescript/models/setup/licenseInfo.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,31 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+class licenseInfo {\n+    license = ko.observable<string>();\n+    \n+    validationGroup: KnockoutValidationGroup;\n+    \n+    constructor() {\n+        this.initValidation();\n+    }\n+    \n+    private initValidation() {\n+        this.license.extend({\n+            required: true,\n+            validLicense: true\n+        });\n+        \n+        this.validationGroup = ko.validatedObservable({\n+            license: this.license\n+        });\n+    }\n+    \n+    toDto(): Raven.Server.Commercial.License {\n+        if (this.license()) {\n+            return JSON.parse(this.license()) as Raven.Server.Commercial.License;\n+        }\n+        return null;\n+    }\n+}\n+\n+export = licenseInfo;"
    },
    {
      "filename": "src/Raven.Studio/typescript/models/setup/nodeInfo.ts",
      "status": "added",
      "patch": "@@ -0,0 +1,73 @@\n+/// <reference path=\"../../../typings/tsd.d.ts\"/>\n+\n+import ipEntry = require(\"models/setup/ipEntry\");\n+\n+class nodeInfo {\n+    \n+    nodeTag = ko.observable<string>();\n+    ips = ko.observableArray<ipEntry>([]);\n+    port = ko.observable<string>();\n+    hostname = ko.observable<string>();\n+    \n+    validationGroup: KnockoutValidationGroup;\n+    \n+    private hostnameIsRequired: () => boolean;\n+    \n+    constructor(hostnameIsRequired: () => boolean) {\n+        this.hostnameIsRequired = hostnameIsRequired;\n+        this.initValidation();\n+        \n+        this.ips.push(new ipEntry());\n+    }\n+\n+    private initValidation() {\n+        this.port.extend({\n+            number: true\n+        });\n+        \n+        this.hostname.extend({\n+            requried: {\n+                onlyIf: () => this.hostnameIsRequired()\n+            }\n+        });\n+        \n+        this.ips.extend({\n+            validation: [\n+                {\n+                    validator: () => this.ips().length > 0,\n+                    message: \"Please define at least one IP for this node\"\n+                }\n+            ]\n+        });\n+\n+        this.validationGroup = ko.validatedObservable({\n+            nodeTag: this.nodeTag,\n+            port: this.port, \n+            ips: this.ips,\n+            serverUrl: this.hostname\n+        });\n+    }\n+\n+    addIpAddress() {\n+        this.ips.push(new ipEntry());\n+    }\n+\n+    removeIp(ipEntry: ipEntry) {\n+        this.ips.remove(ipEntry);\n+    }\n+\n+    toDto(): Raven.Server.Commercial.SetupInfo.NodeInfo {\n+        let serverUrl = \"https://\" + this.hostname();\n+        if (this.port() && this.port() !== \"443\") {\n+            serverUrl += \":\" + this.port();\n+        }\n+        \n+        return {\n+            Ips: this.ips().map(x => x.ip()),\n+            Port: this.port() ? parseInt(this.port(), 10) : null,\n+            ServerUrl: serverUrl\n+        };\n+    }\n+}\n+\n+export = nodeInfo;"
    }
  ],
  "fix_category": "Change condition",
  "root_cause_category": "Randomness",
  "root_cause_subcategory": NaN
}