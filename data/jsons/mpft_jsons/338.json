{
  "id": 338,
  "repo": "ladybird",
  "issue_url": "https://github.com/LadybirdBrowser/ladybird/commit/4330cdee74c86a383055d788de43fd4ae2bd7bc2",
  "pr_url": "https://github.com/LadybirdBrowser/ladybird/commit/4330cdee74c86a383055d788de43fd4ae2bd7bc2",
  "issue_description": "This PR implements the Fullscreen API. \r\n\r\nThe final commit also adds some Qt UI (an \"exit fullscreen\" button that animates from the top down, sort of like how Chrome does it, and also Firefox). For Qt-backends, the escape key also exits out of fullscreen, fully.\r\n\r\nThe spec can be found [here](https://fullscreen.spec.whatwg.org/).\r\n\r\nNew web platform test results (fullscreen/api) with this patch series applied:\r\n\r\n```\r\nRan 57 tests finished in 13.7 seconds.\r\n  \u2022 36 ran as expected. 0 tests skipped.\r\n  \u2022 1 tests had errors unexpectedly\r\n  \u2022 1 tests timed out unexpectedly\r\n  \u2022 21 tests had unexpected subtest results\r\n```\r\n(up from 0 expected to 36. Another test succeeds when #4329 is applied)\r\n\r\nAdditional work that needs to happen:\r\n- https://fullscreen.spec.whatwg.org/#dom-document-fullscreenenabled needs to be implemented fully, where a document's \"allowed to use\" can be deterimined by the `allowFullscreen` attribute set on an iframe. This attribute can not be changed dynamically and once set for a document, is set for the rest of it's life time.\r\n\r\nAdditional work that's required can be determined by the WPT suite.",
  "files_changed": [
    {
      "filename": "Libraries/LibWeb/CSS/Default.css",
      "status": "modified",
      "patch": "@@ -933,6 +933,32 @@ button, meter, progress, select {\n     animation-play-state: inherit;\n }\n \n+/* Fullscreen API defaults https://fullscreen.spec.whatwg.org/#user-agent-level-style-sheet-defaults */\n+*|*:not(:root):fullscreen {\n+  position:fixed !important;\n+  inset:0 !important;\n+  margin:0 !important;\n+  box-sizing:border-box !important;\n+  min-width:0 !important;\n+  max-width:none !important;\n+  min-height:0 !important;\n+  max-height:none !important;\n+  width:100% !important;\n+  height:100% !important;\n+  transform:none !important;\n+  /* intentionally not !important */\n+  object-fit:contain;\n+}\n+\n+iframe:fullscreen {\n+  border:none !important;\n+  padding:0 !important;\n+}\n+\n+*|*:not(:root):fullscreen::backdrop {\n+  background:black;\n+}\n+\n /* Default cross-fade transition */\n @keyframes -ua-view-transition-fade-out {\n     to { opacity: 0; }"
    },
    {
      "filename": "Libraries/LibWeb/CSS/PseudoClasses.json",
      "status": "modified",
      "patch": "@@ -47,6 +47,9 @@\n   \"focus-within\": {\n     \"argument\": \"\"\n   },\n+  \"fullscreen\": {\n+    \"argument\": \"\"\n+  },\n   \"has\": {\n     \"argument\": \"<relative-selector-list>\"\n   },"
    },
    {
      "filename": "Libraries/LibWeb/CSS/SelectorEngine.cpp",
      "status": "modified",
      "patch": "@@ -8,6 +8,7 @@\n #include <LibWeb/CSS/ComputedProperties.h>\n #include <LibWeb/CSS/Keyword.h>\n #include <LibWeb/CSS/Parser/Parser.h>\n+#include <LibWeb/CSS/PseudoClass.h>\n #include <LibWeb/CSS/SelectorEngine.h>\n #include <LibWeb/DOM/Attr.h>\n #include <LibWeb/DOM/Document.h>\n@@ -555,6 +556,9 @@ static inline bool matches_pseudo_class(CSS::Selector::SimpleSelector::PseudoCla\n         auto* focused_element = element.document().focused_element();\n         return focused_element && element.is_inclusive_ancestor_of(*focused_element);\n     }\n+    case CSS::PseudoClass::Fullscreen: {\n+        return element.is_fullscreen_element();\n+    }\n     case CSS::PseudoClass::FirstChild:\n         if (context.collect_per_element_selector_involvement_metadata) {\n             const_cast<DOM::Element&>(element).set_affected_by_sibling_position_or_count_pseudo_class(true);"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Document.cpp",
      "status": "modified",
      "patch": "@@ -5,6 +5,7 @@\n  * Copyright (c) 2021-2024, Sam Atkins <sam@ladybird.org>\n  * Copyright (c) 2024, Matthew Olsson <mattco@serenityos.org>\n  * Copyright (c) 2025, Jelle Raaijmakers <jelle@ladybird.org>\n+ * Copyright (c) 2025, Simon Farre <simon.farre.cx@gmail.com>\n  *\n  * SPDX-License-Identifier: BSD-2-Clause\n  */\n@@ -135,6 +136,7 @@\n #include <LibWeb/HTML/Scripting/Agent.h>\n #include <LibWeb/HTML/Scripting/ClassicScript.h>\n #include <LibWeb/HTML/Scripting/ExceptionReporter.h>\n+#include <LibWeb/HTML/Scripting/TemporaryExecutionContext.h>\n #include <LibWeb/HTML/Scripting/WindowEnvironmentSettingsObject.h>\n #include <LibWeb/HTML/SharedResourceRequest.h>\n #include <LibWeb/HTML/Storage.h>\n@@ -156,6 +158,7 @@\n #include <LibWeb/Painting/DisplayList.h>\n #include <LibWeb/Painting/ViewportPaintable.h>\n #include <LibWeb/PermissionsPolicy/AutoplayAllowlist.h>\n+#include <LibWeb/Platform/EventLoopPlugin.h>\n #include <LibWeb/ResizeObserver/ResizeObserver.h>\n #include <LibWeb/ResizeObserver/ResizeObserverEntry.h>\n #include <LibWeb/SVG/SVGDecodedImageData.h>\n@@ -603,6 +606,10 @@ void Document::visit_edges(Cell::Visitor& visitor)\n         visitor.visit(event.target);\n     }\n \n+    for (auto& event : m_pending_fullscreen_events) {\n+        visitor.visit(event.element);\n+    }\n+\n     visitor.visit(m_adopted_style_sheets);\n     visitor.visit(m_script_blocking_style_sheet_set);\n \n@@ -4098,6 +4105,7 @@ void Document::run_unloading_cleanup_steps()\n     }\n \n     FileAPI::run_unloading_cleanup_steps(*this);\n+    fully_exit_fullscreen();\n }\n \n // https://html.spec.whatwg.org/multipage/document-lifecycle.html#destroy-a-document\n@@ -4452,6 +4460,9 @@ bool Document::is_allowed_to_use_feature(PolicyControlledFeature feature) const\n     case PolicyControlledFeature::FocusWithoutUserActivation:\n         // FIXME: Implement allowlist for this.\n         return true;\n+    case PolicyControlledFeature::Fullscreen:\n+        // FIXME: Implement the permissions policy specification\n+        return true;\n     }\n \n     // 4. Return false.\n@@ -6152,6 +6163,7 @@ void Document::remove_an_element_from_the_top_layer_immediately(GC::Ref<Element>\n     // FIXME: 3. Remove the UA !important overlay: auto rule targeting el, if it exists.\n     element->set_rendered_in_top_layer(false);\n     element->set_needs_style_update(true);\n+    invalidate_layout_tree(InvalidateLayoutTreeReason::DocumentRemoveAnElementFromTheTopLayer);\n }\n \n // https://drafts.csswg.org/css-position-4/#process-top-layer-removals\n@@ -6293,6 +6305,315 @@ void Document::remove_render_blocking_element(GC::Ref<Element> element)\n     m_render_blocking_elements.remove(element);\n }\n \n+// https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps\n+void Document::run_fullscreen_steps()\n+{\n+    // 1. Let pendingEvents be document\u2019s list of pending fullscreen events.\n+    auto pending_events = GC::ConservativeVector<PendingFullscreenEvent> { vm().heap() };\n+    pending_events.extend(m_pending_fullscreen_events);\n+\n+    // 2. Empty document\u2019s list of pending fullscreen events.\n+    m_pending_fullscreen_events.clear();\n+\n+    // 3. For each (type, element) in pendingEvents:\n+    for (auto const& [type, element] : pending_events) {\n+        // 1. Let target be element if element is connected and its node document is document, and otherwise let target be document.\n+        EventTarget* target = nullptr;\n+        if (element->is_connected() && &element->document() == this) {\n+            target = element;\n+        } else {\n+            target = this;\n+        }\n+        // 2. Fire an event named type, with its bubbles and composed attributes set to true, at target.\n+        switch (type) {\n+        case PendingFullscreenEvent::Type::Change:\n+            target->dispatch_event(Event::create(realm(), HTML::EventNames::fullscreenchange, EventInit { .bubbles = true, .composed = true }));\n+            break;\n+        case PendingFullscreenEvent::Type::Error:\n+            target->dispatch_event(Event::create(realm(), HTML::EventNames::fullscreenerror, EventInit { .bubbles = true, .composed = true }));\n+            break;\n+        }\n+    }\n+}\n+\n+void Document::append_pending_fullscreen_change(PendingFullscreenEvent::Type type, GC::Ref<Element> element)\n+{\n+    m_pending_fullscreen_events.append(PendingFullscreenEvent { type, element });\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#fullscreen-an-element\n+void Document::fullscreen_element_within_doc(GC::Ref<Element> element)\n+{\n+    auto const get_hide_until = [&](auto const& popover_list) {\n+        return HTML::HTMLElement::topmost_popover_ancestor(element, popover_list, nullptr, HTML::IsPopover::No);\n+    };\n+\n+    // 1. Let hideUntil be the result of running topmost popover ancestor given\n+    // element, null, and false.\n+    auto hide_until = get_hide_until(showing_hint_popover_list());\n+\n+    // Finding topmost popover ancestor algorithm takes different parameters than those\n+    // described by the fullscreen spec. Since the new algorithm takes 4 parameters, with the new \"popover list\"\n+    // we must also account for the auto popover list.\n+    // More can be read about this \"spec bug\" in https://github.com/whatwg/fullscreen/issues/245\n+    if (hide_until == nullptr)\n+        hide_until = get_hide_until(showing_auto_popover_list());\n+\n+    // Our hide_all_popovers_until takes a variant. topmost_popover_ancestor produces a Ptr<HTMLElement>\n+    Variant<GC::Ptr<HTML::HTMLElement>, GC::Ptr<Document>> hide_until_argument { hide_until };\n+\n+    // 2. If hideUntil is null, then set hideUntil to element\u2019s node document.\n+    if (hide_until == nullptr)\n+        hide_until_argument = element->owner_document();\n+\n+    // 3. Run hide all popovers until given hideUntil, false, and true.\n+    HTML::HTMLElement::hide_all_popovers_until(hide_until_argument, HTML::FocusPreviousElement::No, HTML::FireEvents::Yes);\n+\n+    // 4. Set element\u2019s fullscreen flag.\n+    element->set_fullscreen_flag(true);\n+    // 5. Remove from the top layer immediately given element.\n+    remove_an_element_from_the_top_layer_immediately(element);\n+    // 6. Add to the top layer given element.\n+    add_an_element_to_the_top_layer(element);\n+    element->invalidate_style(StyleInvalidationReason::Fullscreen);\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#fullscreen-element\n+GC::Ptr<Element> Document::fullscreen_element() const\n+{\n+    for (auto const& el : top_layer_elements().in_reverse()) {\n+        if (el->is_fullscreen_element())\n+            return el;\n+    }\n+    return nullptr;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#dom-document-fullscreenelement\n+GC::Ptr<Element> Document::fullscreen_element_for_bindings() const\n+{\n+    GC::Ptr<Element> fullscreen_element = this->fullscreen_element();\n+\n+    if (!fullscreen_element) {\n+        return nullptr;\n+    }\n+\n+    // 1. If this is a shadow root and its host is not connected, then return null.\n+    // Note: We're not a shadow root. See ShadowRoot::fullscreen_element_for_bindings() instead.\n+    // 2. Let candidate be the result of retargeting fullscreen element against this.\n+    auto* candidate = retarget(fullscreen_element.ptr(), const_cast<Document*>(this));\n+    if (!candidate) {\n+        return nullptr;\n+    }\n+    // 3. If candidate and this are in the same tree, then return candidate.\n+    if (auto* retargeted_element = as<Element>(candidate); retargeted_element && &retargeted_element->root() == &root()) {\n+        return retargeted_element;\n+    }\n+    // 4. Return null.\n+    return nullptr;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#dom-document-fullscreen\n+bool Document::fullscreen() const\n+{\n+    // The fullscreen getter steps are to return false if this's fullscreen element is null, and true otherwise.\n+    return fullscreen_element() != nullptr;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#dom-document-fullscreenenabled\n+bool Document::fullscreen_enabled() const\n+{\n+    // FIXME: Implement check policy check and \"is supported\" check.\n+    return is_allowed_to_use_feature(PolicyControlledFeature::Fullscreen);\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#fully-exit-fullscreen\n+void Document::fully_exit_fullscreen()\n+{\n+    // 1. If document\u2019s fullscreen element is null, terminate these steps.\n+    GC::Ptr<Element> fullscreened_element = fullscreen_element();\n+    if (!fullscreened_element)\n+        return;\n+\n+    // 2. Unfullscreen elements whose fullscreen flag is set, within document\u2019s top layer, except for document\u2019s fullscreen element.\n+    GC::RootVector<GC::Ref<Element>, 8> fullscreen_elements { heap() };\n+    for (auto const& element : top_layer_elements()) {\n+        if (element->is_fullscreen_element() && element != fullscreened_element)\n+            fullscreen_elements.append(element);\n+    }\n+\n+    for (auto const& element : fullscreen_elements) {\n+        unfullscreen_element(element);\n+    }\n+\n+    // 3. Exit fullscreen document.\n+\n+    // Note/FIXME: Because Document::destroy() does not \"Assert: this is running as part of a task queued on document's relevant agent's event loop.\" and doesn't seem\n+    // to have any temporary execution context while it's running (because it's making exit_fullscreen crash), we check if there's an execution context\n+    // if not, it means this is running via the \"run_unloading_cleanup_steps\" and thus we must first add a context.\n+    HTML::TemporaryExecutionContext context(realm(), HTML::TemporaryExecutionContext::CallbacksEnabled::Yes);\n+    (void)exit_fullscreen();\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#exit-fullscreen\n+GC::Ref<WebIDL::Promise> Document::exit_fullscreen()\n+{\n+    auto& realm = this->realm();\n+\n+    auto* doc = this;\n+    // 1. Let promise be a new promise.\n+    auto promise = WebIDL::create_promise(realm);\n+\n+    // 2. If doc is not fully active or doc\u2019s fullscreen element is null, then reject promise with a TypeError exception and return promise.\n+    if (!is_fully_active() || !fullscreen_element()) {\n+        WebIDL::reject_promise(realm, promise, JS::TypeError::create(realm, \"Document not fully active or no fullscreen element.\"sv));\n+        return promise;\n+    }\n+\n+    // 3. Let resize be false.\n+    bool resize = false;\n+\n+    // 4. Let docs be the result of collecting documents to unfullscreen given doc.\n+    GC::RootVector<GC::Ref<Document>> docs = doc->collect_documents_to_unfullscreen();\n+\n+    // 5. Let topLevelDoc be doc\u2019s node navigable\u2019s top-level traversable\u2019s active document.\n+    auto top_level_doc = navigable()->top_level_traversable()->active_document();\n+\n+    // 6. If topLevelDoc is in docs, and it is a simple fullscreen document, then set doc to topLevelDoc and resize to true.\n+    if (top_level_doc->is_simple_fullscreen_document() && docs.contains_slow(GC::Ref { *top_level_doc })) {\n+        doc = top_level_doc;\n+        resize = true;\n+    }\n+\n+    // 7. If doc\u2019s fullscreen element is not connected:\n+    if (auto fullscreen_element = doc->fullscreen_element(); !fullscreen_element->is_connected()) {\n+        // 1. Append (fullscreenchange, doc\u2019s fullscreen element) to doc\u2019s list of pending fullscreen events.\n+        doc->append_pending_fullscreen_change(PendingFullscreenEvent::Type::Change, *fullscreen_element);\n+        // 2. Unfullscreen doc\u2019s fullscreen element.\n+        doc->unfullscreen_element(*fullscreen_element);\n+    }\n+\n+    // 8. Return promise, and run the remaining steps in parallel.\n+    Platform::EventLoopPlugin::the().deferred_invoke(GC::create_function(heap(), [&realm, doc = GC::Ref { *doc }, promise, resize]() {\n+        HTML::TemporaryExecutionContext context(realm, HTML::TemporaryExecutionContext::CallbacksEnabled::Yes);\n+        // FIXME: 9. Run the fully unlock the screen orientation steps with doc.\n+        // 10. If resize is true, resize doc\u2019s viewport to its \"normal\" dimensions.\n+        // N.B: Fullscreen API is affected by site-isolation and will require additional work once site-isolation is implemented.\n+        if (resize)\n+            doc->page().client().page_did_request_exit_fullscreen();\n+\n+        // 11. If doc\u2019s fullscreen element is null, then resolve promise with undefined and terminate these steps.\n+        if (!doc->fullscreen_element()) {\n+            WebIDL::resolve_promise(realm, promise, JS::js_undefined());\n+            return;\n+        }\n+\n+        // 12. Let exitDocs be the result of collecting documents to unfullscreen given doc.\n+        auto exit_docs = doc->collect_documents_to_unfullscreen();\n+\n+        // 13. Let descendantDocs be an ordered set consisting of doc\u2019s descendant navigables' active documents whose fullscreen element is non-null, if any, in tree order.\n+        GC::RootVector<GC::Ref<Document>> descendant_docs(realm.heap());\n+        for (auto& descendant : doc->descendant_navigables()) {\n+            if (descendant->active_document()->fullscreen_element())\n+                descendant_docs.append(*descendant->active_document());\n+        }\n+\n+        // 14. For each exitDoc in exitDocs:\n+        for (auto const& exit_doc : exit_docs) {\n+            // 1. Append (fullscreenchange, exitDoc\u2019s fullscreen element) to exitDoc\u2019s list of pending fullscreen events.\n+            exit_doc->append_pending_fullscreen_change(PendingFullscreenEvent::Type::Change, *exit_doc->fullscreen_element());\n+            if (resize) {\n+                // 2. If resize is true, unfullscreen exitDoc.\n+                for (auto el : exit_doc->top_layer_elements()) {\n+                    if (el->is_fullscreen_element())\n+                        exit_doc->unfullscreen_element(el);\n+                }\n+            } else {\n+                // 3. Otherwise, unfullscreen exitDoc\u2019s fullscreen element.\n+                exit_doc->unfullscreen_element(*exit_doc->fullscreen_element());\n+            }\n+        }\n+\n+        // 15. For each descendantDoc in descendantDocs:\n+        for (auto& descendant_doc : descendant_docs) {\n+            // 1. Append (fullscreenchange, descendantDoc\u2019s fullscreen element) to descendantDoc\u2019s list of pending fullscreen events.\n+            descendant_doc->append_pending_fullscreen_change(PendingFullscreenEvent::Type::Change, *descendant_doc->fullscreen_element());\n+            // 2. Unfullscreen descendantDoc.\n+            GC::RootVector<GC::Ref<Element>, 8> fullscreen_elements(realm.heap());\n+            for (auto const& element : descendant_doc->top_layer_elements()) {\n+                if (element->is_fullscreen_element())\n+                    fullscreen_elements.append(element);\n+            }\n+\n+            for (auto& el : fullscreen_elements) {\n+                descendant_doc->unfullscreen_element(el);\n+            }\n+        }\n+\n+        // NOTE: The order in which documents are unfullscreened is not observable, because run the fullscreen steps is invoked in tree order.\n+        // 16. Resolve promise with undefined.\n+        WebIDL::resolve_promise(realm, promise, JS::js_undefined());\n+    }));\n+    return promise;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#simple-fullscreen-document\n+bool Document::is_simple_fullscreen_document() const\n+{\n+    // A document is said to be a simple fullscreen document if there is exactly one element in its top layer that has its fullscreen flag set.\n+    u32 total = 0;\n+    for (auto const& element : top_layer_elements()) {\n+        if (element->is_fullscreen_element())\n+            ++total;\n+\n+        if (total > 1)\n+            return false;\n+    }\n+    return total == 1;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#collect-documents-to-unfullscreen\n+GC::RootVector<GC::Ref<Document>> Document::collect_documents_to_unfullscreen() const\n+{\n+    // 1. Let docs be an ordered set consisting of doc.\n+    GC::RootVector<GC::Ref<Document>> docs { heap() };\n+    docs.append(GC::Ref { *const_cast<Document*>(this) });\n+    // 2. While true:\n+    while (true) {\n+        //  1. Let lastDoc be docs\u2019s last document.\n+        auto last_doc = docs.last();\n+        //  2. Assert: lastDoc\u2019s fullscreen element is not null.\n+        VERIFY(last_doc->fullscreen_element());\n+        //  3. If lastDoc is not a simple fullscreen document, break.\n+        if (!last_doc->is_simple_fullscreen_document())\n+            break;\n+        //  4. Let container be lastDoc\u2019s node navigable\u2019s container.\n+        // Note on spec: It doesn't first check if `node navigable` is null.\n+        auto container = last_doc->navigable() ? last_doc->navigable()->container() : nullptr;\n+        //  5. If container is null, then break.\n+        if (!container)\n+            break;\n+        //  6. If container\u2019s iframe fullscreen flag is set, break.\n+        if (auto* iframe_element = as<HTML::HTMLIFrameElement>(container.ptr()); iframe_element->iframe_fullscreen_flag())\n+            break;\n+\n+        //  7. Append container\u2019s node document to docs.\n+        docs.append(container->document());\n+    }\n+    // 3. Return docs.\n+    return docs;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#unfullscreen-an-element\n+void Document::unfullscreen_element(GC::Ref<Element> element)\n+{\n+    // To unfullscreen an element, unset element\u2019s fullscreen flag and iframe fullscreen flag (if any), and remove from the top layer immediately given element.\n+    element->set_fullscreen_flag(false);\n+    if (HTML::HTMLIFrameElement* iframe_element = as_if<HTML::HTMLIFrameElement>(element.ptr()))\n+        iframe_element->set_iframe_fullscreen_flag(false);\n+\n+    remove_an_element_from_the_top_layer_immediately(element);\n+}\n+\n // https://dom.spec.whatwg.org/#document-allow-declarative-shadow-roots\n void Document::set_allow_declarative_shadow_roots(bool allow)\n {\n@@ -6615,6 +6936,26 @@ void Document::set_onvisibilitychange(WebIDL::CallbackType* value)\n     set_event_handler_attribute(HTML::EventNames::visibilitychange, value);\n }\n \n+WebIDL::CallbackType* Document::onfullscreenchange()\n+{\n+    return event_handler_attribute(HTML::EventNames::fullscreenchange);\n+}\n+\n+void Document::set_onfullscreenchange(WebIDL::CallbackType* value)\n+{\n+    set_event_handler_attribute(HTML::EventNames::fullscreenchange, value);\n+}\n+\n+WebIDL::CallbackType* Document::onfullscreenerror()\n+{\n+    return event_handler_attribute(HTML::EventNames::fullscreenerror);\n+}\n+\n+void Document::set_onfullscreenerror(WebIDL::CallbackType* value)\n+{\n+    set_event_handler_attribute(HTML::EventNames::fullscreenerror, value);\n+}\n+\n ElementByIdMap& Document::element_by_id() const\n {\n     if (!m_element_by_id)"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Document.h",
      "status": "modified",
      "patch": "@@ -56,6 +56,7 @@ enum class QuirksMode {\n \n #define ENUMERATE_INVALIDATE_LAYOUT_TREE_REASONS(X)       \\\n     X(DocumentAddAnElementToTheTopLayer)                  \\\n+    X(DocumentRemoveAnElementFromTheTopLayer)             \\\n     X(DocumentRequestAnElementToBeRemovedFromTheTopLayer) \\\n     X(ShadowRootSetInnerHTML)\n \n@@ -160,6 +161,15 @@ struct ElementCreationOptions {\n enum class PolicyControlledFeature : u8 {\n     Autoplay,\n     FocusWithoutUserActivation,\n+    Fullscreen,\n+};\n+\n+struct PendingFullscreenEvent {\n+    enum class Type {\n+        Change,\n+        Error,\n+    } type;\n+    GC::Ref<Element> element;\n };\n \n class WEB_API Document\n@@ -856,6 +866,12 @@ class WEB_API Document\n     [[nodiscard]] WebIDL::CallbackType* onvisibilitychange();\n     void set_onvisibilitychange(WebIDL::CallbackType*);\n \n+    // https://fullscreen.spec.whatwg.org/#api\n+    [[nodiscard]] WebIDL::CallbackType* onfullscreenchange();\n+    void set_onfullscreenchange(WebIDL::CallbackType*);\n+    [[nodiscard]] WebIDL::CallbackType* onfullscreenerror();\n+    void set_onfullscreenerror(WebIDL::CallbackType*);\n+\n     void reset_cursor_blink_cycle();\n \n     GC::Ref<EditingHostManager> editing_host_manager() const { return *m_editing_host_manager; }\n@@ -905,6 +921,22 @@ class WEB_API Document\n \n     ElementByIdMap& element_by_id() const;\n \n+    // https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps\n+    void run_fullscreen_steps();\n+    void append_pending_fullscreen_change(PendingFullscreenEvent::Type type, GC::Ref<Element> element);\n+\n+    void fullscreen_element_within_doc(GC::Ref<Element> element);\n+    GC::Ptr<Element> fullscreen_element() const;\n+    GC::Ptr<Element> fullscreen_element_for_bindings() const;\n+\n+    bool fullscreen() const;\n+    bool fullscreen_enabled() const;\n+\n+    void fully_exit_fullscreen();\n+    GC::Ref<WebIDL::Promise> exit_fullscreen();\n+\n+    void unfullscreen_element(GC::Ref<Element> element);\n+\n     auto& script_blocking_style_sheet_set() { return m_script_blocking_style_sheet_set; }\n     auto const& script_blocking_style_sheet_set() const { return m_script_blocking_style_sheet_set; }\n \n@@ -939,6 +971,9 @@ class WEB_API Document\n \n     void evaluate_media_rules();\n \n+    bool is_simple_fullscreen_document() const;\n+    GC::RootVector<GC::Ref<Document>> collect_documents_to_unfullscreen() const;\n+\n     enum class AddLineFeed {\n         Yes,\n         No,\n@@ -1287,6 +1322,9 @@ class WEB_API Document\n \n     // https://www.w3.org/TR/css-properties-values-api-1/#dom-window-registeredpropertyset-slot\n     HashMap<FlyString, GC::Ref<Web::CSS::CSSPropertyRule>> m_registered_custom_properties;\n+\n+    // https://fullscreen.spec.whatwg.org/#list-of-pending-fullscreen-events\n+    Vector<PendingFullscreenEvent> m_pending_fullscreen_events;\n };\n \n template<>"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Document.idl",
      "status": "modified",
      "patch": "@@ -159,6 +159,15 @@ interface Document : Node {\n \n     // https://www.w3.org/TR/SVG2/struct.html#InterfaceDocumentExtensions\n     readonly attribute SVGSVGElement? rootElement;\n+\n+    // https://fullscreen.spec.whatwg.org/#api\n+    attribute EventHandler onfullscreenchange;\n+    attribute EventHandler onfullscreenerror;\n+    // FIXME: [LegacyLenientSetter]\n+    readonly attribute boolean fullscreenEnabled;\n+    // FIXME: [LegacyLenientSetter, Unscopable]\n+    readonly attribute boolean fullscreen; // historical\n+    Promise<undefined> exitFullscreen();\n };\n \n dictionary ElementCreationOptions {"
    },
    {
      "filename": "Libraries/LibWeb/DOM/DocumentOrShadowRoot.idl",
      "status": "modified",
      "patch": "@@ -8,4 +8,9 @@ interface mixin DocumentOrShadowRoot {\n \n     // https://www.w3.org/TR/web-animations-1/#extensions-to-the-documentorshadowroot-interface-mixin\n     sequence<Animation> getAnimations();\n+\n+    // https://fullscreen.spec.whatwg.org/#fullscreen-an-element\n+    // FIXME: [LegacyLenientSetter] not implemented\n+    [ImplementedAs=fullscreen_element_for_bindings]\n+    readonly attribute Element? fullscreenElement;\n };"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Element.cpp",
      "status": "modified",
      "patch": "@@ -1,6 +1,7 @@\n /*\n  * Copyright (c) 2018-2024, Andreas Kling <andreas@ladybird.org>\n  * Copyright (c) 2022-2023, Sam Atkins <atkinssj@serenityos.org>\n+ * Copyright (c) 2025, Simon Farre <simon.farre.cx@gmail.com>\n  *\n  * SPDX-License-Identifier: BSD-2-Clause\n  */\n@@ -53,9 +54,11 @@\n #include <LibWeb/HTML/HTMLAreaElement.h>\n #include <LibWeb/HTML/HTMLBodyElement.h>\n #include <LibWeb/HTML/HTMLButtonElement.h>\n+#include <LibWeb/HTML/HTMLDialogElement.h>\n #include <LibWeb/HTML/HTMLFieldSetElement.h>\n #include <LibWeb/HTML/HTMLFrameSetElement.h>\n #include <LibWeb/HTML/HTMLHtmlElement.h>\n+#include <LibWeb/HTML/HTMLIFrameElement.h>\n #include <LibWeb/HTML/HTMLInputElement.h>\n #include <LibWeb/HTML/HTMLLIElement.h>\n #include <LibWeb/HTML/HTMLMenuElement.h>\n@@ -82,10 +85,12 @@\n #include <LibWeb/Layout/ListItemBox.h>\n #include <LibWeb/Layout/TreeBuilder.h>\n #include <LibWeb/Layout/Viewport.h>\n+#include <LibWeb/MathML/MathMLElement.h>\n #include <LibWeb/Namespace.h>\n #include <LibWeb/Page/Page.h>\n #include <LibWeb/Painting/PaintableBox.h>\n #include <LibWeb/Painting/ViewportPaintable.h>\n+#include <LibWeb/Platform/EventLoopPlugin.h>\n #include <LibWeb/SVG/SVGAElement.h>\n #include <LibWeb/Selection/Selection.h>\n #include <LibWeb/WebIDL/AbstractOperations.h>\n@@ -1388,6 +1393,7 @@ void Element::removed_from(Node* old_parent, Node& old_root)\n \n     play_or_cancel_animations_after_display_property_change();\n     remove_animations_from_timeline();\n+    removing_steps_fullscreen();\n }\n \n void Element::moved_from(GC::Ptr<Node> old_parent)\n@@ -2177,6 +2183,230 @@ WebIDL::ExceptionOr<void> Element::insert_adjacent_html(String const& position,\n     return {};\n }\n \n+// Used to signal what message should be shown when the promise for the algorithm rejects..\n+enum class RequestFullscreenError : u8 {\n+    False,\n+    ElementReadyCheckFailed,\n+    UnsupportedElement,\n+    NoTransientUserActivation,\n+    ElementNodeDocIsNotPendingDoc\n+};\n+\n+static constexpr String to_string(RequestFullscreenError error)\n+{\n+    switch (error) {\n+    // This should never be called with this value\n+    case RequestFullscreenError::False:\n+        return \"false\"_string;\n+    case RequestFullscreenError::ElementReadyCheckFailed:\n+        return \"Element ready check failed\"_string;\n+    case RequestFullscreenError::UnsupportedElement:\n+        return \"Not supported element\"_string;\n+    case RequestFullscreenError::NoTransientUserActivation:\n+        return \"No transient user activation available to consume\"_string;\n+    case RequestFullscreenError::ElementNodeDocIsNotPendingDoc:\n+        return \"Element's node document is not pending doc\"_string;\n+    }\n+    VERIFY_NOT_REACHED();\n+}\n+\n+// step 5 of requestFullscreen:\n+// 5. If any of conditions are false, set error to true\n+static RequestFullscreenError fullscreen_has_error_check(Element const& element)\n+{\n+    // This\u2019s namespace is the HTML namespace or this is an SVG svg or MathML math element. [SVG] [MATHML]\n+    if (!(element.namespace_uri() == Namespace::HTML || element.is_svg_svg_element() || is<MathML::MathMLElement>(element)))\n+        return RequestFullscreenError::UnsupportedElement;\n+\n+    // This is not a dialog element\n+    if (is<HTML::HTMLDialogElement>(element))\n+        return RequestFullscreenError::UnsupportedElement;\n+\n+    // The fullscreen element ready check for this returns true.\n+    if (!element.element_ready_check())\n+        return RequestFullscreenError::ElementReadyCheckFailed;\n+    // FIXME: Implement 'Fullscreen is supported.' check\n+\n+    // This\u2019s relevant global object has transient activation or\n+    // FIXME: the algorithm is triggered by a user generated orientation change.\n+    HTML::Window* window = as_if<HTML::Window>(&HTML::relevant_global_object(element));\n+\n+    // is_connected, in element_ready_check has returned true, there should be a window.\n+    ASSERT(window);\n+\n+    if (!window->has_transient_activation())\n+        return RequestFullscreenError::NoTransientUserActivation;\n+\n+    return RequestFullscreenError::False;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#fullscreen-element-ready-check\n+bool Element::element_ready_check() const\n+{\n+    // A fullscreen element ready check for an element element returns true if all of the following are true, and false otherwise:\n+\n+    // element is connected.\n+    if (!is_connected())\n+        return false;\n+\n+    // element\u2019s node document is allowed to use the \"fullscreen\" feature.\n+    if (!m_document->is_allowed_to_use_feature(PolicyControlledFeature::Fullscreen))\n+        return false;\n+\n+    // element namespace is not the HTML namespace or element\u2019s popover visibility state is hidden.\n+    if (namespace_uri() != Namespace::HTML)\n+        return true;\n+\n+    auto const* html_element = as_if<HTML::HTMLElement>(this);\n+    return html_element ? (html_element->popover_visibility_state() == HTML::HTMLElement::PopoverVisibilityState::Hidden) : false;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#dom-element-requestfullscreen\n+GC::Ref<WebIDL::Promise> Element::request_fullscreen()\n+{\n+    auto& realm = this->realm();\n+\n+    // 1. Let pendingDoc be this\u2019s node document.\n+    auto pending_doc = m_document;\n+\n+    // 2. Let promise be a new promise.\n+    auto promise = WebIDL::create_promise(realm);\n+\n+    // 3. If pendingDoc is not fully active, then reject promise with a TypeError exception and return promise.\n+    if (!pending_doc->is_fully_active()) {\n+        WebIDL::reject_promise(realm, promise, JS::TypeError::create(realm, \"Document not fully active.\"_string));\n+        return promise;\n+    }\n+\n+    // 4. Let error be false.\n+    // 5. If any of conditions are false, set error to true\n+    RequestFullscreenError error = fullscreen_has_error_check(*this);\n+\n+    // 6. If error is false, then consume user activation given pendingDoc\u2019s relevant global object.\n+    if (error == RequestFullscreenError::False) {\n+        auto& relevant_global = as<HTML::Window>(relevant_global_object(*pending_doc));\n+        relevant_global.consume_user_activation();\n+    }\n+\n+    // 7. Return promise, and run the remaining steps in parallel.\n+    Platform::EventLoopPlugin::the().deferred_invoke(GC::create_function(heap(), [&realm, error, pending_doc, requesting_element = GC::Ref<Element> { *this }, promise]() mutable {\n+        HTML::TemporaryExecutionContext context(realm, HTML::TemporaryExecutionContext::CallbacksEnabled::Yes);\n+        // N.B: Fullscreen API is affected by site-isolation and will require additional work once site-isolation is implemented.\n+\n+        // 8. If error is false, then resize pendingDoc\u2019s node navigable\u2019s top-level traversable\u2019s\n+        // active document\u2019s viewport\u2019s dimensions FIXME: optionally taking into account options[\"navigationUI\"]:\n+        if (error == RequestFullscreenError::False)\n+            pending_doc->page().client().page_did_request_fullscreen_window();\n+\n+        // 9. If any of the following conditions are false, then set error to true:\n+        //      This\u2019s node document is pendingDoc.\n+        //      The fullscreen element ready check for this returns true.\n+        if (pending_doc != requesting_element->owner_document())\n+            error = RequestFullscreenError::ElementNodeDocIsNotPendingDoc;\n+        if (!requesting_element->element_ready_check())\n+            error = RequestFullscreenError::ElementReadyCheckFailed;\n+\n+        // 10. If error is true:\n+        //      Append (fullscreenerror, this) to pendingDoc\u2019s list of pending fullscreen events.\n+        //      Reject promise with a TypeError exception and terminate these steps.\n+        if (error != RequestFullscreenError::False) {\n+            pending_doc->append_pending_fullscreen_change(PendingFullscreenEvent::Type::Error, requesting_element);\n+            WebIDL::reject_promise(realm, promise, JS::TypeError::create(realm, to_string(error)));\n+            return;\n+        }\n+\n+        // 11. Let fullscreenElements be an ordered set initially consisting of this.\n+        Vector<GC::Ref<Element>> fullscreen_elements;\n+\n+        fullscreen_elements.append(requesting_element);\n+        // 12. While true:\n+        //      1. Let last be the last item of fullscreenElements.\n+        //      2. Let container be last\u2019s node navigable\u2019s container.\n+        //      3. If container is null, then break.\n+        //      4. Append container to fullscreenElements.\n+        while (true) {\n+            auto last = fullscreen_elements.last();\n+            auto container = last->navigable()->container();\n+            if (!container)\n+                break;\n+\n+            fullscreen_elements.append(*container);\n+        }\n+\n+        // 13. For each element in fullscreenElements:\n+        for (GC::Ref<Element>& element : fullscreen_elements) {\n+            // 1. Let doc be element\u2019s node document.\n+            Document& doc = element->document();\n+            // 2. If element is doc\u2019s fullscreen element, continue.\n+            if (doc.fullscreen_element() == element) {\n+                // Spec note: No need to notify observers when nothing has changed.\n+                continue;\n+            }\n+            // 4. If element is this and this is an iframe element, then set element\u2019s iframe fullscreen flag.\n+            if (element == requesting_element && requesting_element->is_html_iframe_element()) {\n+                auto& iframe_element = static_cast<HTML::HTMLIFrameElement&>(*element);\n+                iframe_element.set_iframe_fullscreen_flag(true);\n+            }\n+            // 5. Fullscreen element within doc.\n+            doc.fullscreen_element_within_doc(element);\n+            // 6. Append (fullscreenchange, element) to doc\u2019s list of pending fullscreen events.\n+            doc.append_pending_fullscreen_change(PendingFullscreenEvent::Type::Change, element);\n+        }\n+\n+        // 14. Resolve promise with undefined\n+        WebIDL::resolve_promise(realm, promise, JS::js_undefined());\n+    }));\n+\n+    return promise;\n+}\n+\n+// https://fullscreen.spec.whatwg.org/#removing-steps\n+void Element::removing_steps_fullscreen()\n+{\n+    // 1. Let document be removedNode\u2019s node document.\n+    auto& document = this->document();\n+    // 2. Let nodes be removedNode\u2019s shadow-including inclusive descendants that have their fullscreen flag set, in shadow-including tree order.\n+    // 3. For each node in nodes:\n+    for_each_shadow_including_inclusive_descendant([&](Node& node) {\n+        Element* element = as_if<Element>(node);\n+        if (!element)\n+            return TraversalDecision::Continue;\n+\n+        if (element->is_fullscreen_element()) {\n+            if (document.fullscreen_element() == element) {\n+                // 1. If node is document\u2019s fullscreen element, exit fullscreen document.\n+                document.exit_fullscreen();\n+            } else {\n+                // 2. Otherwise, unfullscreen node.\n+                document.unfullscreen_element(*element);\n+            }\n+            // 3. If document\u2019s top layer contains node, remove from the top layer immediately given node\n+            document.remove_an_element_from_the_top_layer_immediately(*element);\n+        }\n+        return TraversalDecision::Continue;\n+    });\n+}\n+\n+GC::Ptr<WebIDL::CallbackType> Element::onfullscreenchange()\n+{\n+    return event_handler_attribute(HTML::EventNames::fullscreenchange);\n+}\n+\n+void Element::set_onfullscreenchange(GC::Ptr<WebIDL::CallbackType> event_handler)\n+{\n+    set_event_handler_attribute(HTML::EventNames::fullscreenchange, event_handler);\n+}\n+\n+GC::Ptr<WebIDL::CallbackType> Element::onfullscreenerror()\n+{\n+    return event_handler_attribute(HTML::EventNames::fullscreenerror);\n+}\n+\n+void Element::set_onfullscreenerror(GC::Ptr<WebIDL::CallbackType> event_handler)\n+{\n+    set_event_handler_attribute(HTML::EventNames::fullscreenerror, event_handler);\n+}\n+\n // https://dom.spec.whatwg.org/#insert-adjacent\n WebIDL::ExceptionOr<GC::Ptr<Node>> Element::insert_adjacent(StringView where, GC::Ref<Node> node)\n {"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Element.h",
      "status": "modified",
      "patch": "@@ -245,6 +245,19 @@ class WEB_API Element\n \n     WebIDL::ExceptionOr<void> insert_adjacent_html(String const& position, String const&);\n \n+    bool element_ready_check() const;\n+    GC::Ref<WebIDL::Promise> request_fullscreen();\n+    void removing_steps_fullscreen();\n+\n+    void set_fullscreen_flag(bool is_fullscreen) { m_fullscreen_flag = is_fullscreen; }\n+    bool is_fullscreen_element() const { return m_fullscreen_flag; }\n+\n+    GC::Ptr<WebIDL::CallbackType> onfullscreenchange();\n+    void set_onfullscreenchange(GC::Ptr<WebIDL::CallbackType>);\n+\n+    GC::Ptr<WebIDL::CallbackType> onfullscreenerror();\n+    void set_onfullscreenerror(GC::Ptr<WebIDL::CallbackType>);\n+\n     WebIDL::ExceptionOr<String> outer_html() const;\n     WebIDL::ExceptionOr<void> set_outer_html(String const&);\n \n@@ -629,6 +642,7 @@ class WEB_API Element\n     bool m_affected_by_sibling_position_or_count_pseudo_class : 1 { false };\n     bool m_affected_by_nth_child_pseudo_class : 1 { false };\n     bool m_affected_by_has_pseudo_class_with_relative_selector_that_has_sibling_combinator : 1 { false };\n+    bool m_fullscreen_flag : 1 { false };\n \n     size_t m_sibling_invalidation_distance { 0 };\n "
    },
    {
      "filename": "Libraries/LibWeb/DOM/Element.idl",
      "status": "modified",
      "patch": "@@ -125,6 +125,11 @@ interface Element : Node {\n     undefined setPointerCapture(long pointerId);\n     undefined releasePointerCapture(long pointerId);\n     boolean hasPointerCapture(long pointerId);\n+\n+    // partial interface for https://fullscreen.spec.whatwg.org/#api\n+    Promise<undefined> requestFullscreen();\n+    attribute EventHandler onfullscreenchange;\n+    attribute EventHandler onfullscreenerror;\n };\n \n dictionary GetHTMLOptions {"
    },
    {
      "filename": "Libraries/LibWeb/DOM/Node.h",
      "status": "modified",
      "patch": "@@ -64,6 +64,7 @@ enum class ShouldComputeRole {\n     X(EditingInsertion)                             \\\n     X(ElementAttributeChange)                       \\\n     X(ElementSetShadowRoot)                         \\\n+    X(Fullscreen)                                   \\\n     X(HTMLDialogElementSetIsModal)                  \\\n     X(HTMLHyperlinkElementHrefChange)               \\\n     X(HTMLIFrameElementGeometryChange)              \\"
    },
    {
      "filename": "Libraries/LibWeb/DOM/ShadowRoot.cpp",
      "status": "modified",
      "patch": "@@ -9,6 +9,7 @@\n #include <LibWeb/DOM/Document.h>\n #include <LibWeb/DOM/Event.h>\n #include <LibWeb/DOM/ShadowRoot.h>\n+#include <LibWeb/DOM/Utils.h>\n #include <LibWeb/HTML/HTMLTemplateElement.h>\n #include <LibWeb/HTML/Parser/HTMLParser.h>\n #include <LibWeb/Layout/BlockContainer.h>\n@@ -31,6 +32,30 @@ void ShadowRoot::finalize()\n     document().unregister_shadow_root({}, *this);\n }\n \n+// https://fullscreen.spec.whatwg.org/#dom-document-fullscreenelement\n+GC::Ptr<Element> ShadowRoot::fullscreen_element_for_bindings() const\n+{\n+    // 1. If this is a shadow root and its host is not connected, then return null.\n+    if (!host() || !host()->is_connected())\n+        return nullptr;\n+\n+    // 2. Let candidate be the result of retargeting fullscreen element against this.\n+    // Note: ShadowRoot does not have it's own top layer. But the algorithm says to get the fullscreen\n+    // element from the top layer, so it's grabbed from this' document.\n+\n+    auto* candidate = retarget(const_cast<ShadowRoot*>(this)->document().fullscreen_element().ptr(), const_cast<ShadowRoot*>(this));\n+\n+    if (!candidate)\n+        return nullptr;\n+\n+    // 3. If candidate and this are in the same tree, then return candidate.\n+    if (auto* retargeted_element = as<Element>(candidate); &retargeted_element->root() == &root())\n+        return retargeted_element;\n+\n+    // 4. Return null.\n+    return nullptr;\n+}\n+\n void ShadowRoot::initialize(JS::Realm& realm)\n {\n     WEB_SET_PROTOTYPE_FOR_INTERFACE(ShadowRoot);"
    },
    {
      "filename": "Libraries/LibWeb/DOM/ShadowRoot.h",
      "status": "modified",
      "patch": "@@ -68,6 +68,8 @@ class WEB_API ShadowRoot final : public DocumentFragment {\n \n     virtual void finalize() override;\n \n+    GC::Ptr<Element> fullscreen_element_for_bindings() const;\n+\n protected:\n     virtual void visit_edges(Cell::Visitor&) override;\n "
    },
    {
      "filename": "Libraries/LibWeb/HTML/EventLoop/EventLoop.cpp",
      "status": "modified",
      "patch": "@@ -383,7 +383,10 @@ void EventLoop::update_the_rendering()\n         document->update_animations_and_send_events(HighResolutionTime::relative_high_resolution_time(frame_timestamp, relevant_global_object(*document)));\n     };\n \n-    // FIXME: 12. For each doc of docs, run the fullscreen steps for doc. [FULLSCREEN]\n+    // 12. For each doc of docs, run the fullscreen steps for doc. [FULLSCREEN]\n+    for (auto& document : docs) {\n+        document->run_fullscreen_steps();\n+    }\n \n     // FIXME: 13. For each doc of docs, if the user agent detects that the backing storage associated with a CanvasRenderingContext2D or an OffscreenCanvasRenderingContext2D, context, has been lost, then it must run the context lost steps for each such context:\n "
    },
    {
      "filename": "Libraries/LibWeb/HTML/EventNames.h",
      "status": "modified",
      "patch": "@@ -65,6 +65,8 @@ namespace Web::HTML::EventNames {\n     __ENUMERATE_HTML_EVENT(focusin)                  \\\n     __ENUMERATE_HTML_EVENT(focusout)                 \\\n     __ENUMERATE_HTML_EVENT(formdata)                 \\\n+    __ENUMERATE_HTML_EVENT(fullscreenchange)         \\\n+    __ENUMERATE_HTML_EVENT(fullscreenerror)          \\\n     __ENUMERATE_HTML_EVENT(hashchange)               \\\n     __ENUMERATE_HTML_EVENT(input)                    \\\n     __ENUMERATE_HTML_EVENT(invalid)                  \\"
    },
    {
      "filename": "Libraries/LibWeb/HTML/HTMLIFrameElement.h",
      "status": "modified",
      "patch": "@@ -37,6 +37,9 @@ class HTMLIFrameElement final\n \n     virtual void visit_edges(Cell::Visitor&) override;\n \n+    void set_iframe_fullscreen_flag(bool iframe_fullscreen_flag) { m_iframe_fullscreen_flag = iframe_fullscreen_flag; }\n+    bool iframe_fullscreen_flag() const { return m_iframe_fullscreen_flag; }\n+\n private:\n     HTMLIFrameElement(DOM::Document&, DOM::QualifiedName);\n \n@@ -62,6 +65,9 @@ class HTMLIFrameElement final\n     // https://html.spec.whatwg.org/multipage/iframe-embed-object.html#current-navigation-was-lazy-loaded\n     bool m_current_navigation_was_lazy_loaded { false };\n \n+    // https://fullscreen.spec.whatwg.org/#iframe-fullscreen-flag\n+    bool m_iframe_fullscreen_flag { false };\n+\n     // https://html.spec.whatwg.org/multipage/iframe-embed-object.html#iframe-pending-resource-timing-start-time\n     Optional<HighResolutionTime::DOMHighResTimeStamp> m_pending_resource_start_time = {};\n "
    },
    {
      "filename": "Libraries/LibWeb/Page/EventHandler.cpp",
      "status": "modified",
      "patch": "@@ -20,6 +20,8 @@\n #include <LibWeb/HTML/HTMLImageElement.h>\n #include <LibWeb/HTML/HTMLMediaElement.h>\n #include <LibWeb/HTML/HTMLVideoElement.h>\n+#include <LibWeb/HTML/Scripting/TemporaryExecutionContext.h>\n+#include <LibWeb/HTML/TraversableNavigable.h>\n #include <LibWeb/Layout/Label.h>\n #include <LibWeb/Layout/Viewport.h>\n #include <LibWeb/Page/DragAndDropEventHandler.h>\n@@ -1258,7 +1260,16 @@ EventResult EventHandler::handle_keydown(UIEvents::KeyCode key, u32 modifiers, u\n     }\n \n     // https://html.spec.whatwg.org/multipage/interaction.html#close-requests\n+    // FIXME: Close requests should queue a global task on the user interaction task source, given `document`'s relevant global object.\n     if (key == UIEvents::KeyCode::Key_Escape) {\n+        // 1. If document's fullscreen element is not null, then:\n+        if (document->fullscreen()) {\n+            // 1. Fully exit fullscreen given document's node navigable's top-level traversable's active document.\n+            m_navigable->top_level_traversable()->active_document()->fully_exit_fullscreen();\n+            // 2. Return.\n+            return EventResult::Handled;\n+        }\n+\n         // 7. Let closedSomething be the result of processing close watchers on document's relevant global object.\n         auto closed_something = document->window()->close_watcher_manager()->process_close_watchers();\n "
    },
    {
      "filename": "Libraries/LibWeb/Page/Page.h",
      "status": "modified",
      "patch": "@@ -329,6 +329,7 @@ class PageClient : public JS::Cell {\n     virtual void page_did_request_maximize_window() { }\n     virtual void page_did_request_minimize_window() { }\n     virtual void page_did_request_fullscreen_window() { }\n+    virtual void page_did_request_exit_fullscreen() { }\n     virtual void page_did_start_loading(URL::URL const&, bool is_redirect) { (void)is_redirect; }\n     virtual void page_did_create_new_document(Web::DOM::Document&) { }\n     virtual void page_did_change_active_document_in_top_level_browsing_context(Web::DOM::Document&) { }"
    },
    {
      "filename": "Libraries/LibWebView/HeadlessWebView.cpp",
      "status": "modified",
      "patch": "@@ -43,6 +43,7 @@ HeadlessWebView::HeadlessWebView(Core::AnonymousBuffer theme, Web::DevicePixelSi\n     };\n \n     on_reposition_window = [this](auto position) {\n+        m_previous_dimensions.set_location(position.template to_type<Web::DevicePixels>());\n         client().async_set_window_position(m_client_state.page_index, position.template to_type<Web::DevicePixels>());\n \n         client().async_did_update_window_rect(m_client_state.page_index);\n@@ -67,6 +68,7 @@ HeadlessWebView::HeadlessWebView(Core::AnonymousBuffer theme, Web::DevicePixelSi\n \n     on_maximize_window = [this]() {\n         m_viewport_size = screen_rect.size();\n+        m_previous_dimensions = screen_rect;\n \n         client().async_set_window_position(m_client_state.page_index, screen_rect.location());\n         client().async_set_window_size(m_client_state.page_index, screen_rect.size());\n@@ -76,6 +78,7 @@ HeadlessWebView::HeadlessWebView(Core::AnonymousBuffer theme, Web::DevicePixelSi\n     };\n \n     on_fullscreen_window = [this]() {\n+        m_previous_dimensions.set_size(m_viewport_size);\n         m_viewport_size = screen_rect.size();\n \n         client().async_set_window_position(m_client_state.page_index, screen_rect.location());\n@@ -85,6 +88,15 @@ HeadlessWebView::HeadlessWebView(Core::AnonymousBuffer theme, Web::DevicePixelSi\n         client().async_did_update_window_rect(m_client_state.page_index);\n     };\n \n+    on_exit_fullscreen_window = [this]() {\n+        m_viewport_size = m_previous_dimensions.size();\n+        client().async_set_window_position(m_client_state.page_index, m_previous_dimensions.location());\n+        client().async_set_window_size(m_client_state.page_index, m_previous_dimensions.size());\n+        client().async_set_viewport_size(m_client_state.page_index, m_previous_dimensions.size());\n+\n+        client().async_did_update_window_rect(m_client_state.page_index);\n+    };\n+\n     on_request_alert = [this](auto const&) {\n         m_pending_dialog = Web::Page::PendingDialog::Alert;\n     };"
    },
    {
      "filename": "Libraries/LibWebView/HeadlessWebView.h",
      "status": "modified",
      "patch": "@@ -36,6 +36,9 @@ class WEBVIEW_API HeadlessWebView : public WebView::ViewImplementation {\n     Web::Page::PendingDialog m_pending_dialog { Web::Page::PendingDialog::None };\n     Optional<String> m_pending_prompt_text;\n \n+    // When restoring from fullscreen, we need to know to what dimension.\n+    Web::DevicePixelRect m_previous_dimensions;\n+\n     // FIXME: We should implement UI-agnostic platform APIs to interact with the system clipboard.\n     Optional<Web::Clipboard::SystemClipboardItem> m_clipboard;\n "
    },
    {
      "filename": "Libraries/LibWebView/ViewImplementation.cpp",
      "status": "modified",
      "patch": "@@ -426,6 +426,11 @@ void ViewImplementation::js_console_request_messages(i32 start_index)\n     client().async_js_console_request_messages(page_id(), start_index);\n }\n \n+void ViewImplementation::exit_fullscreen()\n+{\n+    client().async_exit_fullscreen(page_id());\n+}\n+\n void ViewImplementation::alert_closed()\n {\n     client().async_alert_closed(page_id());"
    },
    {
      "filename": "Libraries/LibWebView/ViewImplementation.h",
      "status": "modified",
      "patch": "@@ -124,6 +124,7 @@ class WEBVIEW_API ViewImplementation : public SettingsObserver {\n     void run_javascript(String const&);\n     void js_console_input(String const&);\n     void js_console_request_messages(i32 start_index);\n+    void exit_fullscreen();\n \n     void alert_closed();\n     void confirm_closed(bool accepted);\n@@ -219,6 +220,7 @@ class WEBVIEW_API ViewImplementation : public SettingsObserver {\n     Function<void()> on_maximize_window;\n     Function<void()> on_minimize_window;\n     Function<void()> on_fullscreen_window;\n+    Function<void()> on_exit_fullscreen_window;\n     Function<void(Color current_color)> on_request_color_picker;\n     Function<void(Web::HTML::FileFilter const& accepted_file_types, Web::HTML::AllowMultipleFiles)> on_request_file_picker;\n     Function<void(Gfx::IntPoint content_position, i32 minimum_width, Vector<Web::HTML::SelectItem> items)> on_request_select_dropdown;"
    },
    {
      "filename": "Libraries/LibWebView/WebContentClient.cpp",
      "status": "modified",
      "patch": "@@ -619,12 +619,21 @@ void WebContentClient::did_request_minimize_window(u64 page_id)\n     }\n }\n \n-void WebContentClient::did_request_fullscreen_window(u64 page_id)\n+Messages::WebContentClient::DidRequestFullscreenWindowResponse WebContentClient::did_request_fullscreen_window(u64 page_id)\n {\n     if (auto view = view_for_page_id(page_id); view.has_value()) {\n         if (view->on_fullscreen_window)\n             view->on_fullscreen_window();\n     }\n+    return true;\n+}\n+\n+void WebContentClient::did_request_exit_fullscreen(u64 page_id)\n+{\n+    if (auto view = view_for_page_id(page_id); view.has_value()) {\n+        if (view->on_fullscreen_window)\n+            view->on_exit_fullscreen_window();\n+    }\n }\n \n void WebContentClient::did_request_file(u64 page_id, ByteString path, i32 request_id)"
    },
    {
      "filename": "Libraries/LibWebView/WebContentClient.h",
      "status": "modified",
      "patch": "@@ -122,7 +122,8 @@ class WEBVIEW_API WebContentClient final\n     virtual void did_request_resize_window(u64 page_id, Gfx::IntSize) override;\n     virtual void did_request_maximize_window(u64 page_id) override;\n     virtual void did_request_minimize_window(u64 page_id) override;\n-    virtual void did_request_fullscreen_window(u64 page_id) override;\n+    virtual Messages::WebContentClient::DidRequestFullscreenWindowResponse did_request_fullscreen_window(u64 page_id) override;\n+    virtual void did_request_exit_fullscreen(u64 page_id) override;\n     virtual void did_request_file(u64 page_id, ByteString path, i32) override;\n     virtual void did_request_color_picker(u64 page_id, Color current_color) override;\n     virtual void did_request_file_picker(u64 page_id, Web::HTML::FileFilter accepted_file_types, Web::HTML::AllowMultipleFiles) override;"
    },
    {
      "filename": "Services/WebContent/ConnectionFromClient.cpp",
      "status": "modified",
      "patch": "@@ -35,6 +35,7 @@\n #include <LibWeb/Dump.h>\n #include <LibWeb/HTML/BrowsingContext.h>\n #include <LibWeb/HTML/HTMLInputElement.h>\n+#include <LibWeb/HTML/Scripting/TemporaryExecutionContext.h>\n #include <LibWeb/HTML/SelectedFile.h>\n #include <LibWeb/HTML/Storage.h>\n #include <LibWeb/HTML/TraversableNavigable.h>\n@@ -1331,4 +1332,12 @@ void ConnectionFromClient::cookies_changed(Vector<Web::Cookie::Cookie> cookies)\n     }\n }\n \n+void ConnectionFromClient::exit_fullscreen(u64 page_id)\n+{\n+    if (auto page = this->page(page_id); page.has_value()) {\n+        Web::HTML::TemporaryExecutionContext context(page->page().top_level_browsing_context().active_document()->realm(), Web::HTML::TemporaryExecutionContext::CallbacksEnabled::Yes);\n+        page->page().top_level_browsing_context().active_document()->fully_exit_fullscreen();\n+    }\n+}\n+\n }"
    },
    {
      "filename": "Services/WebContent/ConnectionFromClient.h",
      "status": "modified",
      "patch": "@@ -160,6 +160,8 @@ class ConnectionFromClient final\n     virtual void system_time_zone_changed() override;\n     virtual void cookies_changed(Vector<Web::Cookie::Cookie>) override;\n \n+    virtual void exit_fullscreen(u64 page_id) override;\n+\n     NonnullOwnPtr<PageHost> m_page_host;\n \n     HashMap<int, Web::FileRequest> m_requested_files {};"
    },
    {
      "filename": "Services/WebContent/PageClient.cpp",
      "status": "modified",
      "patch": "@@ -267,6 +267,11 @@ void PageClient::page_did_request_fullscreen_window()\n     client().async_did_request_fullscreen_window(m_id);\n }\n \n+void PageClient::page_did_request_exit_fullscreen()\n+{\n+    client().async_did_request_exit_fullscreen(m_id);\n+}\n+\n void PageClient::page_did_request_tooltip_override(Web::CSSPixelPoint position, ByteString const& title)\n {\n     auto device_position = page().css_to_device_point(position);"
    },
    {
      "filename": "Services/WebContent/PageClient.h",
      "status": "modified",
      "patch": "@@ -120,6 +120,7 @@ class PageClient final : public Web::PageClient {\n     virtual void page_did_request_maximize_window() override;\n     virtual void page_did_request_minimize_window() override;\n     virtual void page_did_request_fullscreen_window() override;\n+    virtual void page_did_request_exit_fullscreen() override;\n     virtual void page_did_request_tooltip_override(Web::CSSPixelPoint, ByteString const&) override;\n     virtual void page_did_stop_tooltip_override() override;\n     virtual void page_did_enter_tooltip_area(ByteString const&) override;"
    },
    {
      "filename": "Services/WebContent/WebContentClient.ipc",
      "status": "modified",
      "patch": "@@ -93,7 +93,8 @@ endpoint WebContentClient\n     did_request_resize_window(u64 page_id, Gfx::IntSize size) =|\n     did_request_maximize_window(u64 page_id) =|\n     did_request_minimize_window(u64 page_id) =|\n-    did_request_fullscreen_window(u64 page_id) =|\n+    did_request_fullscreen_window(u64 page_id) => (bool success)\n+    did_request_exit_fullscreen(u64 page_id) =|\n     did_request_file(u64 page_id, ByteString path, i32 request_id) =|\n     did_request_color_picker(u64 page_id, Color current_color) =|\n     did_request_file_picker(u64 page_id, Web::HTML::FileFilter accepted_file_types, Web::HTML::AllowMultipleFiles allow_multiple_files) =|"
    },
    {
      "filename": "Services/WebContent/WebContentServer.ipc",
      "status": "modified",
      "patch": "@@ -130,4 +130,6 @@ endpoint WebContentServer\n \n     system_time_zone_changed() =|\n     cookies_changed(Vector<Web::Cookie::Cookie> cookies) =|\n+    \n+    exit_fullscreen(u64 page_id) =|\n }"
    }
  ],
  "fix_category": "Make deterministic",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": NaN
}