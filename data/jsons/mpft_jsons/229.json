{
  "id": 229,
  "repo": "kubernetes",
  "issue_url": "https://github.com/kubernetes/kubernetes/commit/7c1d133dff775f9a8f66b73b4d30af2bacdde5a9",
  "pr_url": "https://github.com/kubernetes/kubernetes/commit/7c1d133dff775f9a8f66b73b4d30af2bacdde5a9",
  "issue_description": "Also change cloudcfg.sh, to make it possible to call from the examples/guestbook directory.\n",
  "files_changed": [
    {
      "filename": "examples/guestbook/guestbook.md",
      "status": "modified",
      "patch": "@@ -50,7 +50,7 @@ You should see a single redis master task.  It will also display the machine tha\n sudo docker ps\n ```\n \n-And see the actual task.  (note that initial ```docker pull``` may take a few minutes, depending on network conditions.\n+And see the actual task.  (Note that initial ```docker pull``` may take a few minutes, depending on network conditions.)\n \n ### Step Two: Turn up the master service.\n A Kubernetes 'service' is named load balancer that proxies traffic to one or more containers.  The services in a Kubernetes cluster are discoverable inside other containers via environment variables.  Services find the containers to load balance based on task labels.  The task that you created in Step One has the label \"name=redis-master\", so the corresponding service is defined by that label.  Create a file named redis-master-service.json that contains:\n@@ -68,7 +68,7 @@ A Kubernetes 'service' is named load balancer that proxies traffic to one or mor\n Once you have that service description, you can create the service with the cloudcfg cli:\n \n ```shell\n-./src/scripts/cloudcfg.sh -c redis-master-service create /services\n+./src/scripts/cloudcfg.sh -c redis-master-service.json create /services\n ```\n \n Once created, the service proxy on each minion is configured to set up a proxy on the specified port (in this case port 10000).\n@@ -131,7 +131,7 @@ Just like the master, we want to have a service to proxy connections to the read\n }\n ```\n \n-This time the label query for the service is 'name=redis-slave'\n+This time the label query for the service is 'name=redis-slave'.\n \n Now that you have created the service specification, create it in your cluster with the cloudcfg cli:\n \n@@ -219,4 +219,4 @@ if (isset($_GET['cmd']) === true) {\n } ?>\n ```\n \n-To play with the service itself, find the name of a frontend, grab the external IP of that host from the Google Cloud Console, and visit http://&lt;host-ip&gt;:8080, note you may need to open the firewall for port 8080 using the console or the gcloud tool.\n+To play with the service itself, find the name of a frontend, grab the external IP of that host from the Google Cloud Console, and visit http://&lt;host-ip&gt;:8080. Note, you may need to open the firewall for port 8080 using the console or the gcloud tool."
    },
    {
      "filename": "src/scripts/cloudcfg.sh",
      "status": "modified",
      "patch": "@@ -20,5 +20,5 @@\n \n detect-master\n \n-./target/cloudcfg -h https://${KUBE_MASTER_IP} $@\n+$(dirname $0)/../../target/cloudcfg -h https://${KUBE_MASTER_IP} $@\n "
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}