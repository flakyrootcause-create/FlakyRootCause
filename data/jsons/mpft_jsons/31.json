{
  "id": 31,
  "repo": "flink",
  "issue_url": "https://github.com/apache/flink/commit/4f7f6a97f799a4a30d1aea57fc0af5d07dc0eeed",
  "pr_url": "https://github.com/apache/flink/commit/4f7f6a97f799a4a30d1aea57fc0af5d07dc0eeed",
  "issue_description": "The StringComparator now works on serialized data.\n\nTo this end new string read/write/copy/compare methods were introduced, which use a variable-length encoding for the characters.\n\n~~key-points:~~\n  ~~\\- The most significant bits are written/read first.~~\n  ~~\\- The first 2 bits of the character are used to encode the size of the character.~~\n ~~\\- A character is at most 3 Bytes big.~~\n\nAdditionally, the StringSerializer now has full unicode support. ~~i couldn't find a unicode character that ~~uses more than 22 bits, as such 3 Bytes should be sufficient.~~\n",
  "files_changed": [
    {
      "filename": "stratosphere-core/src/main/java/eu/stratosphere/api/common/typeutils/base/StringComparator.java",
      "status": "modified",
      "patch": "@@ -39,9 +39,7 @@ public StringComparator(boolean ascending) {\n \n \t@Override\n \tpublic int compare(DataInputView firstSource, DataInputView secondSource) throws IOException {\n-\t\tString s1 = StringValue.readString(firstSource);\n-\t\tString s2 = StringValue.readString(secondSource);\n-\t\tint comp = s1.compareTo(s2); \n+\t\tint comp = StringValue.compareUnicodeString(firstSource, secondSource);\n \t\treturn ascendingComparison ? comp : -comp;\n \t}\n "
    },
    {
      "filename": "stratosphere-core/src/main/java/eu/stratosphere/api/common/typeutils/base/StringSerializer.java",
      "status": "modified",
      "patch": "@@ -57,16 +57,16 @@ public int getLength() {\n \n \t@Override\n \tpublic void serialize(String record, DataOutputView target) throws IOException {\n-\t\tStringValue.writeString(record, target);\n+\t\tStringValue.writeUnicodeString(record, target);\n \t}\n \n \t@Override\n \tpublic String deserialize(String record, DataInputView source) throws IOException {\n-\t\treturn StringValue.readString(source);\n+\t\treturn StringValue.readUnicodeString(source);\n \t}\n \n \t@Override\n \tpublic void copy(DataInputView source, DataOutputView target) throws IOException {\n-\t\tStringValue.copyString(source, target);\n+\t\tStringValue.copyUnicodeString(source, target);\n \t}\n }"
    },
    {
      "filename": "stratosphere-core/src/main/java/eu/stratosphere/types/StringValue.java",
      "status": "modified",
      "patch": "@@ -46,11 +46,12 @@ public class StringValue implements NormalizableKey<StringValue>, CharSequence,\n \t\n \tprivate static final int HIGH_BIT = 0x1 << 7;\n \t\n+\tprivate static final int END_BYTE = 0x60;\n+\t\n \tprivate static final int HIGH_BIT2 = 0x1 << 13;\n \t\n \tprivate static final int HIGH_BIT2_MASK = 0x3 << 6;\n \t\n-\t\n \tprivate char[] value;\t\t// character value of the string value, not necessarily completely filled\n \t\n \tprivate int len;\t\t\t// length of the string value\n@@ -835,4 +836,198 @@ public static final void copyString(DataInput in, DataOutput out) throws IOExcep\n \t\t\t}\n \t\t}\n \t}\n-}\n+\t\n+\t/**\n+\t Writes a CharSequence as a variable-length encoded Unicode String.\n+\t Supports Unicode characters up to 22 bits.\n+\t @param cs CharSequence to write\n+\t @param out output channel\n+\t @throws IOException \n+\t */\n+\tpublic static final void writeUnicodeString(CharSequence cs, DataOutput out) throws IOException {\n+\t\tif (cs == null) {\n+\t\t\twriteLength(0, out);\n+\t\t} else {\n+\t\t\twriteLength(Character.codePointCount(cs, 0, cs.length()) + 1, out);\n+\t\t\tfor (int i = 0; i < cs.length(); i++) {\n+\t\t\t\tint c = Character.codePointAt(cs, i);\n+\t\t\t\tif (c >= 65536) {\n+\t\t\t\t\t//Non-BMP Unicode character, two characters are treated as one\n+\t\t\t\t\ti++;\n+\t\t\t\t}\n+\t\t\t\twriteUnicodeChar(c, out);\n+\t\t\t}\n+\t\t}\n+\t\t//end-of-string byte\n+\t\tout.write(END_BYTE);\n+\t}\n+\t\n+\t/**\n+\tWrites the given int variable-length encoded to the given DataOutput. NOT adjusted for null offset.\n+\t@param lenToWrite int to write\n+\t@param out output\n+\t@throws IOException \n+\t*/\n+\tprivate static void writeLength(int lenToWrite, DataOutput out) throws IOException {\n+\t\tif (lenToWrite < 0) {\n+\t\t\tthrow new IllegalArgumentException(\"CharSequence is too long.\");\n+\t\t}\n+\n+\t\t// write the length, variable-length encoded\n+\t\twhile (lenToWrite >= HIGH_BIT) {\n+\t\t\tout.write(lenToWrite | HIGH_BIT);\n+\t\t\tlenToWrite >>>= 7;\n+\t\t}\n+\t\tout.write(lenToWrite);\n+\t}\n+\n+\t/**\n+\t Writes a variable-length encoded Unicode Character.\n+\t @param c char to write\n+\t @param out output channel\n+\t @return Unicode Character\n+\t @throws IOException \n+\t */\n+\tprivate static void writeUnicodeChar(int c, DataOutput out) throws IOException {\n+\t\tint shift = 0;\n+\n+\t\twhile (c >= (HIGH_BIT << shift)) {\n+\t\t\tshift += 5;\n+\t\t}\n+\n+\t\twhile (shift >= 0) {\n+\t\t\tswitch (shift) {\n+\t\t\t\tcase 0:\n+\t\t\t\t\tout.write(c | 0x80);\n+\t\t\t\t\tshift -= 1;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 5:\n+\t\t\t\t\tout.write((c >> shift + 2) & 0x1F);\n+\t\t\t\t\tshift -= 5;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 10:\n+\t\t\t\t\tout.write(((c >> shift + 2) | 0x20) & 0x3F);\n+\t\t\t\t\tshift -= 5;\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 15:\n+\t\t\t\t\tout.write(((c >> shift + 2) | 0x40) & 0x5F);\n+\t\t\t\t\tshift -= 5;\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t Reads and returns a variable-length encoded Unicode String.\n+\t @param in input channel\n+\t @return Unicode String\n+\t @throws IOException \n+\t */\n+\tpublic static final String readUnicodeString(DataInput in) throws IOException {\n+\t\tint len = readLength(in);\n+\t\t\n+\t\tfinal int[] data = new int[len];\n+\t\t\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tdata[i] = readUnicodeChar(in);\n+\t\t}\n+\t\t//end-of-string byte\n+\t\tin.readUnsignedByte();\n+\t\treturn new String(data, 0, len);\n+\t}\n+\t\n+\t/**\n+\tReads a variable-length encoded int from the given DataInput. Adjusted for null offset.\n+\t@param in input\n+\t@return read int\n+\t@throws IOException \n+\t*/\n+\tprivate static int readLength(DataInput in) throws IOException {\n+\t\t// the length we read is offset by one, because a length of zero indicates a null value\n+\t\tint len = in.readUnsignedByte();\n+\n+\t\tif (len == 0) {\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tif (len >= HIGH_BIT) {\n+\t\t\tint shift = 7;\n+\t\t\tint curr;\n+\t\t\tlen = len & 0x7f;\n+\t\t\twhile ((curr = in.readUnsignedByte()) >= HIGH_BIT) {\n+\t\t\t\tlen |= (curr & 0x7f) << shift;\n+\t\t\t\tshift += 7;\n+\t\t\t}\n+\t\t\tlen |= curr << shift;\n+\t\t}\n+\n+\t\t// subtract one for the null length\n+\t\tlen -= 1;\n+\n+\t\treturn len;\n+\t}\n+\t\n+\t/**\n+\tReads and returns a variable-length encoded Unicode Character.\n+\t@param in input channel\n+\t@return Unicode Character\n+\t@throws IOException \n+\t*/\n+\tprivate static int readUnicodeChar(DataInput in) throws IOException {\n+\t\tint r = 0;\n+\t\tint c;\n+\t\twhile ((c = in.readUnsignedByte()) < HIGH_BIT) {\n+\t\t\tr |= (c & 0x1F);\n+\t\t\tr <<= 5;\n+\t\t}\n+\t\tr <<= 2;\n+\t\tr |= (c & 0x7F);\n+\t\treturn r;\n+\t}\n+\t\n+\t/**\n+\t Copies a serialized variable-length encoded Unicode String.\n+\t @param in input channel\n+\t @param out output channel\n+\t @throws IOException \n+\t */\n+\tpublic static final void copyUnicodeString(DataInput in, DataOutput out) throws IOException {\n+\t\t//copy length\n+\t\tint length = readLength(in);\n+\t\t// the length we write is offset by one, because a length of zero indicates a null value\n+\t\twriteLength(length + 1, out);\n+\n+\t\t//copy data\n+\t\tfor (int i = 0; i < length; i++) {\n+\t\t\twriteUnicodeChar(readUnicodeChar(in),out);\n+\t\t}\n+\t\t//end-of-string byte\n+\t\tin.readUnsignedByte();\n+\t\tout.writeByte(END_BYTE);\n+\t}\n+\n+\t/**\n+\t Compares two serialized variable-length encoded Unicode String.\n+\t @param first input channel\n+\t @param second input channel\n+\t @return A negative value if the first String is less than the second, 0 if equal, a positive value if greater.\n+\t @throws IOException \n+\t */\n+\tpublic static final int compareUnicodeString(DataInputView first, DataInputView second) throws IOException {\n+\t\tint lengthFirst = readLength(first);\n+\t\tint lengthSecond = readLength(second);\n+\t\tbyte c1, c2;\n+\t\tint cmp = 0;\n+\t\tfor(\n+\t\t\t\tint x = 0;\n+\t\t\t\t(c1=first.readByte()) < END_BYTE && \n+\t\t\t\t(c2=second.readByte()) < END_BYTE && \n+\t\t\t\t(cmp=c1-c2) == 0; \n+\t\t\t\tx++);\n+\t\tif (cmp!=0){\n+\t\t\treturn cmp;\n+\t\t}\n+\t\t//the first min(lengthFirst, lengthSecond) characters are equal, longer String > shorter String\n+\t\treturn lengthFirst - lengthSecond;\n+\t}\n+}\n\\ No newline at end of file"
    },
    {
      "filename": "stratosphere-core/src/test/java/eu/stratosphere/api/common/typeutils/base/StringComparatorTest.java",
      "status": "modified",
      "patch": "@@ -17,8 +17,6 @@\n import eu.stratosphere.api.common.typeutils.ComparatorTestBase;\n import eu.stratosphere.api.common.typeutils.TypeComparator;\n import eu.stratosphere.api.common.typeutils.TypeSerializer;\n-import eu.stratosphere.api.common.typeutils.base.StringComparator;\n-import eu.stratosphere.api.common.typeutils.base.StringSerializer;\n \n public class StringComparatorTest extends ComparatorTestBase<String> {\n \n@@ -42,7 +40,10 @@ protected String[] getSortedTestData() {\n \t\t\t\"abce\",\n \t\t\t\"abdd\",\n \t\t\t\"accd\",\n-\t\t\t\"bbcd\"\n+\t\t\t\"bbcd\",\n+\t\t\t\"bbcde\",\n+\t\t\t((char)128)+\"\"+((char)32896),\n+\t\t\t((char)128)+\"\"+((char)32897)\n \t\t};\n \t}\n }"
    },
    {
      "filename": "stratosphere-core/src/test/java/eu/stratosphere/api/common/typeutils/base/StringSerializerTest.java",
      "status": "modified",
      "patch": "@@ -16,6 +16,8 @@\n \n import eu.stratosphere.api.common.typeutils.SerializerTestBase;\n import eu.stratosphere.api.common.typeutils.TypeSerializer;\n+import eu.stratosphere.util.StringUtils;\n+import java.util.Random;\n \n /**\n  * A test for the {@link StringSerializer}.\n@@ -39,6 +41,12 @@ protected Class<String> getTypeClass() {\n \t\n \t@Override\n \tprotected String[] getTestData() {\n-\t\treturn new String[] {\"a\", \"\", \"bcd\", \"jbmbmner8 jhk hj \\n \\t \u00fc\u00e4\u00df\u00df@\u00b5\", \"\", \"non-empty\"};\n+\t\tRandom rnd = new Random(289347567856686223L);\n+\t\treturn new String[] {\n+\t\t\tStringUtils.getRandomString(rnd, 300, 350), new String(Character.toChars(127315)), \n+\t\t\t(char)128+(char)32896+\"\", \"\"+(char)24640+(char)24640+(char)24640+(char)24640+(char)24640,\n+\t\t\t\"\"+(char)65535+(char)65535+(char)65535+(char)65535+(char)65535,\n+\t\t\t\"\"+(char)0,\n+\t\t\t\"a\", \"\", \"bcd\", \"jbmbmner8 jhk hj \\n \\t \u00fc\u00e4\u00df\u00df@\u00b5\", \"\", \"non-empty\"};\n \t}\n }"
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}