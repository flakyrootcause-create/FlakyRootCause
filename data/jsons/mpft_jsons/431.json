{
  "id": 431,
  "repo": "deno",
  "issue_url": "https://github.com/denoland/deno/pull/23134",
  "pr_url": "https://github.com/denoland/deno/pull/23134",
  "issue_description": "There's a TOCTOU issue that can happen when selecting unused ports for the server to use (we get assigned an unused port by the OS, and between then and when the server actually binds to the port another test steals it). Improve this by checking if the server existed soon after setup, and if so we retry starting it. Client connection can also fail spuriously (in local testing) so added a retry mechanism.\r\n\r\nThis also fixes a hang, where if the server exited (almost always due to the issue described above) before we connected to it, attempting to connect our client ZMQ sockets to it would just hang. To resolve this, I added a timeout so we can't wait forever. ",
  "files_changed": [
    {
      "filename": "tests/integration/jupyter_tests.rs",
      "status": "modified",
      "patch": "@@ -191,7 +191,24 @@ async fn connect_socket<S: zeromq::Socket>(\n ) -> S {\n   let addr = spec.endpoint(port);\n   let mut socket = S::new();\n-  socket.connect(&addr).await.unwrap();\n+  let mut connected = false;\n+  for _ in 0..5 {\n+    match timeout(Duration::from_secs(5), socket.connect(&addr)).await {\n+      Ok(Ok(_)) => {\n+        connected = true;\n+        break;\n+      }\n+      Ok(Err(e)) => {\n+        eprintln!(\"Failed to connect to {addr}: {e}\");\n+      }\n+      Err(e) => {\n+        eprintln!(\"Timed out connecting to {addr}: {e}\");\n+      }\n+    }\n+  }\n+  if !connected {\n+    panic!(\"Failed to connect to {addr}\");\n+  }\n   socket\n }\n \n@@ -369,27 +386,48 @@ impl Drop for JupyterServerProcess {\n   }\n }\n \n-fn setup_server() -> (TestContext, ConnectionSpec, JupyterServerProcess) {\n+async fn setup_server() -> (TestContext, ConnectionSpec, JupyterServerProcess) {\n   let context = TestContextBuilder::new().use_temp_cwd().build();\n-  let conn = ConnectionSpec::default();\n+  let mut conn = ConnectionSpec::default();\n   let conn_file = context.temp_dir().path().join(\"connection.json\");\n   conn_file.write_json(&conn);\n-  let process = context\n-    .new_command()\n-    .piped_output()\n-    .args_vec(vec![\n-      \"jupyter\",\n-      \"--kernel\",\n-      \"--conn\",\n-      conn_file.to_string().as_str(),\n-    ])\n-    .spawn()\n-    .unwrap();\n+\n+  let start_process = |conn_file: &test_util::PathRef| {\n+    context\n+      .new_command()\n+      .args_vec(vec![\n+        \"jupyter\",\n+        \"--kernel\",\n+        \"--conn\",\n+        conn_file.to_string().as_str(),\n+      ])\n+      .spawn()\n+      .unwrap()\n+  };\n+\n+  // try to start the server, retrying up to 5 times\n+  // (this can happen due to TOCTOU errors with selecting unused TCP ports)\n+  let mut process = start_process(&conn_file);\n+  tokio::time::sleep(Duration::from_millis(1000)).await;\n+\n+  for _ in 0..5 {\n+    if process.try_wait().unwrap().is_none() {\n+      break;\n+    } else {\n+      conn = ConnectionSpec::default();\n+      conn_file.write_json(&conn);\n+      process = start_process(&conn_file);\n+      tokio::time::sleep(Duration::from_millis(1000)).await;\n+    }\n+  }\n+  if process.try_wait().unwrap().is_some() {\n+    panic!(\"Failed to start Jupyter server\");\n+  }\n   (context, conn, JupyterServerProcess(Some(process)))\n }\n \n async fn setup() -> (TestContext, JupyterClient, JupyterServerProcess) {\n-  let (context, conn, process) = setup_server();\n+  let (context, conn, process) = setup_server().await;\n   let client = JupyterClient::new(&conn).await;\n   client.io_subscribe(\"\").await.unwrap();\n "
    }
  ],
  "fix_category": "WaitFor",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": NaN
}