{
  "id": 156,
  "repo": "emqx",
  "issue_url": "https://github.com/emqx/emqx/pull/15870",
  "pr_url": "https://github.com/emqx/emqx/pull/15870",
  "issue_description": "",
  "files_changed": [
    {
      "filename": "apps/emqx/test/emqx_persistent_session_ds_SUITE.erl",
      "status": "modified",
      "patch": "@@ -178,9 +178,29 @@ start_client(Opts0 = #{}) ->\n     Client.\n \n start_connect_client(Opts = #{}) ->\n-    Client = start_client(Opts),\n-    ?assertMatch({ok, _}, emqtt:connect(Client)),\n-    Client.\n+    Pid = start_client(Opts),\n+    case emqtt_connect(Pid) of\n+        {ok, _ConnAck} ->\n+            Pid;\n+        {error, {server_busy, _ConnAckProps}} ->\n+            timer:sleep(10),\n+            ClientId = proplists:get_value(clientid, Opts),\n+            ct:pal(\"~s reconnect after delay\", [ClientId]),\n+            start_connect_client(Opts);\n+        {error, Reason} ->\n+            error(Reason)\n+    end.\n+\n+emqtt_connect(ClientPid) ->\n+    unlink(ClientPid),\n+    case emqtt:connect(ClientPid) of\n+        {ok, ConnAck} ->\n+            {ok, ConnAck};\n+        {error, Reason} ->\n+            %% ensure failed client is killed\n+            exit(ClientPid, kill),\n+            {error, Reason}\n+    end.\n \n mk_clientid(Prefix, ID) ->\n     iolist_to_binary(io_lib:format(\"~p/~p\", [Prefix, ID])).\n@@ -257,12 +277,10 @@ t_storage_generations(Config) ->\n         #{timetrap => 30_000},\n         begin\n             %% Start subscriber:\n-            Sub = start_client(#{port => Port, clientid => ClientId, auto_ack => never}),\n-            {ok, _} = emqtt:connect(Sub),\n+            Sub = start_connect_client(#{port => Port, clientid => ClientId, auto_ack => never}),\n             {ok, _, _} = emqtt:subscribe(Sub, TopicFilter, qos2),\n             %% Start publisher:\n-            Pub = start_client(#{port => Port, clientid => mk_clientid(?FUNCTION_NAME, pub)}),\n-            {ok, _} = emqtt:connect(Pub),\n+            Pub = start_connect_client(#{port => Port, clientid => mk_clientid(?FUNCTION_NAME, pub)}),\n             %% Publish 3 messages. Subscriber receives them, but\n             %% doesn't ack them initially.\n             {ok, _} = emqtt:publish(Pub, <<\"t/1\">>, <<\"1\">>, ?QOS_1),\n@@ -290,7 +308,7 @@ t_storage_generations(Config) ->\n             ok = emqtt:puback(Sub, PI2),\n             ok = emqtt:puback(Sub, PI3),\n             ok = emqtt:puback(Sub, PI4),\n-            [#{packet_id := PI5}] = emqx_common_test_helpers:wait_publishes(1, 5_000)\n+            [#{packet_id := _PI5}] = emqx_common_test_helpers:wait_publishes(1, 5_000)\n         end,\n         [fun check_stream_state_transitions/1]\n     ),\n@@ -321,8 +339,7 @@ t_session_subscription_idempotency(Config) ->\n             spawn_link(fun() -> restart_node(Node1, Node1Spec) end),\n \n             ?tp(notice, \"starting 1\", #{}),\n-            Client0 = start_client(#{port => Port, clientid => ClientId}),\n-            {ok, _} = emqtt:connect(Client0),\n+            Client0 = start_connect_client(#{port => Port, clientid => ClientId}),\n             ?tp(notice, \"subscribing 1\", #{}),\n             process_flag(trap_exit, true),\n             catch emqtt:subscribe(Client0, SubTopicFilter, qos2),\n@@ -335,8 +352,7 @@ t_session_subscription_idempotency(Config) ->\n \n             {ok, _} = ?block_until(#{?snk_kind := restarted_node}, 15_000),\n             ?tp(notice, \"starting 2\", #{}),\n-            Client1 = start_client(#{port => Port, clientid => ClientId}),\n-            {ok, _} = emqtt:connect(Client1),\n+            Client1 = start_connect_client(#{port => Port, clientid => ClientId}),\n             ?tp(notice, \"subscribing 2\", #{}),\n             {ok, _, [2]} = emqtt:subscribe(Client1, SubTopicFilter, qos2),\n \n@@ -382,8 +398,7 @@ t_session_unsubscription_idempotency(Config) ->\n             spawn_link(fun() -> restart_node(Node1, Node1Spec) end),\n \n             ?tp(notice, \"starting 1\", #{}),\n-            Client0 = start_client(#{port => Port, clientid => ClientId}),\n-            {ok, _} = emqtt:connect(Client0),\n+            Client0 = start_connect_client(#{port => Port, clientid => ClientId}),\n             ?tp(notice, \"subscribing 1\", #{}),\n             {ok, _, [?RC_GRANTED_QOS_2]} = emqtt:subscribe(Client0, SubTopicFilter, qos2),\n             ?tp(notice, \"unsubscribing 1\", #{}),\n@@ -398,8 +413,7 @@ t_session_unsubscription_idempotency(Config) ->\n \n             {ok, _} = ?block_until(#{?snk_kind := restarted_node}, 15_000),\n             ?tp(notice, \"starting 2\", #{}),\n-            Client1 = start_client(#{port => Port, clientid => ClientId}),\n-            {ok, _} = emqtt:connect(Client1),\n+            Client1 = start_connect_client(#{port => Port, clientid => ClientId}),\n             ?tp(notice, \"subscribing 2\", #{}),\n             {ok, _, [?RC_GRANTED_QOS_2]} = emqtt:subscribe(Client1, SubTopicFilter, qos2),\n             ?tp(notice, \"unsubscribing 2\", #{}),\n@@ -450,10 +464,8 @@ t_subscription_state_change(Config) ->\n         #{timetrap => 30_000},\n         begin\n             %% Init:\n-            Sub = start_client(#{port => Port, clientid => ClientId, auto_ack => never}),\n-            {ok, _} = emqtt:connect(Sub),\n-            Pub = start_client(#{port => Port, clientid => mk_clientid(?FUNCTION_NAME, pub)}),\n-            {ok, _} = emqtt:connect(Pub),\n+            Sub = start_connect_client(#{port => Port, clientid => ClientId, auto_ack => never}),\n+            Pub = start_connect_client(#{port => Port, clientid => mk_clientid(?FUNCTION_NAME, pub)}),\n             %% Subscribe to the topic using QoS1 initially:\n             {ok, _, _} = emqtt:subscribe(Sub, TopicFilter, ?QOS_1),\n             #{subscriptions := Subs1} = GetS(),\n@@ -515,8 +527,7 @@ t_new_stream_notifications(Config) ->\n         #{timetrap => 30_000},\n         begin\n             %% Init:\n-            Sub0 = start_client(#{port => Port, clientid => ClientId}),\n-            {ok, _} = emqtt:connect(Sub0),\n+            Sub0 = start_connect_client(#{port => Port, clientid => ClientId}),\n             %% 1. Sessions should start watching streams when they\n             %% subscribe to the topics:\n             ?wait_async_action(\n@@ -535,8 +546,7 @@ t_new_stream_notifications(Config) ->\n                 2,\n                 timer:seconds(10)\n             ),\n-            Sub1 = start_client(#{port => Port, clientid => ClientId, clean_start => false}),\n-            {ok, _} = emqtt:connect(Sub1),\n+            Sub1 = start_connect_client(#{port => Port, clientid => ClientId, clean_start => false}),\n             %% Verify that both subscriptions have been renewed:\n             {ok, EventsAfterRestart} = snabbkaffe:receive_events(SNKsub),\n             ?assertMatch(\n@@ -612,13 +622,12 @@ do_t_session_discard(Params) ->\n         #{timetrap => 30_000},\n         begin\n             ?tp(notice, \"starting\", #{}),\n-            Client0 = start_client(#{\n+            Client0 = start_connect_client(#{\n                 clientid => ClientId,\n                 clean_start => false,\n                 properties => #{'Session-Expiry-Interval' => 30},\n                 proto_ver => v5\n             }),\n-            {ok, _} = emqtt:connect(Client0),\n             ?tp(notice, \"subscribing\", #{}),\n             {ok, _, [?RC_GRANTED_QOS_2]} = emqtt:subscribe(Client0, SubTopicFilter, qos2),\n             %% Store some matching messages so that streams and iterators are created.\n@@ -635,8 +644,7 @@ do_t_session_discard(Params) ->\n             ?tp(notice, \"reconnecting\", #{}),\n             %% we still have the session:\n             ?assertMatch(#{}, emqx_persistent_session_ds_state:print_session(ClientId)),\n-            Client1 = start_client(ReconnectOpts),\n-            {ok, _} = emqtt:connect(Client1),\n+            Client1 = start_connect_client(ReconnectOpts),\n             ?assertEqual([], emqtt:subscriptions(Client1)),\n             case is_persistent_connect_opts(ReconnectOpts) of\n                 true ->\n@@ -704,8 +712,7 @@ do_t_session_expiration(_Config, Opts) ->\n         begin\n             Topic = <<\"some/topic\">>,\n             Params0 = maps:merge(CommonParams, FirstConn),\n-            Client0 = start_client(Params0),\n-            {ok, _} = emqtt:connect(Client0),\n+            Client0 = start_connect_client(Params0),\n             {ok, _, [?RC_GRANTED_QOS_2]} = emqtt:subscribe(Client0, Topic, ?QOS_2),\n             #{s := #{subscriptions := Subs0}} = emqx_persistent_session_ds:print_session(ClientId),\n             ?assertEqual(1, map_size(Subs0), #{subs => Subs0}),\n@@ -714,8 +721,7 @@ do_t_session_expiration(_Config, Opts) ->\n             emqtt:disconnect(Client0, ?RC_NORMAL_DISCONNECTION, FirstDisconn),\n \n             Params1 = maps:merge(CommonParams, SecondConn),\n-            Client1 = start_client(Params1),\n-            {ok, _} = emqtt:connect(Client1),\n+            Client1 = start_connect_client(Params1),\n             Info1 = maps:from_list(emqtt:info(Client1)),\n             ?assertEqual(1, maps:get(session_present, Info1), #{info => Info1}),\n             Subs1 = emqtt:subscriptions(Client1),\n@@ -725,8 +731,7 @@ do_t_session_expiration(_Config, Opts) ->\n             ct:sleep(2_500),\n \n             Params2 = maps:merge(CommonParams, ThirdConn),\n-            Client2 = start_client(Params2),\n-            {ok, _} = emqtt:connect(Client2),\n+            Client2 = start_connect_client(Params2),\n             Info2 = maps:from_list(emqtt:info(Client2)),\n             ?assertEqual(0, maps:get(session_present, Info2), #{info => Info2}),\n             Subs2 = emqtt:subscriptions(Client2),\n@@ -761,9 +766,7 @@ t_session_gc(Config) ->\n             port => Port,\n             properties => #{'Session-Expiry-Interval' => ExpiryInterval}\n         }),\n-        Client = start_client(Params),\n-        {ok, _} = emqtt:connect(Client),\n-        Client\n+        start_connect_client(Params)\n     end,\n \n     ?check_trace(\n@@ -859,14 +862,13 @@ t_crashed_node_session_gc(Config) ->\n         #{timetrap => 30_000},\n         begin\n             ClientId = <<\"session_on_crashed_node\">>,\n-            Client = start_client(#{\n+            _ = start_connect_client(#{\n                 clientid => ClientId,\n                 port => Port,\n                 properties => #{'Session-Expiry-Interval' => 1},\n                 clean_start => false,\n                 proto_ver => v5\n             }),\n-            {ok, _} = emqtt:connect(Client),\n             ct:sleep(1500),\n             emqx_cth_peer:kill(Node1),\n \n@@ -912,14 +914,13 @@ t_last_alive_at_cleanup(Config) ->\n                 []\n             ),\n             ClientId = <<\"session_on_crashed_node\">>,\n-            Client = start_client(#{\n+            _ = start_connect_client(#{\n                 clientid => ClientId,\n                 port => Port,\n                 properties => #{'Session-Expiry-Interval' => 1},\n                 clean_start => false,\n                 proto_ver => v5\n             }),\n-            {ok, _} = emqtt:connect(Client),\n \n             %% Kill node making its lifetime epoch invalid.\n             emqx_cth_peer:kill(Node1),\n@@ -1014,14 +1015,13 @@ t_session_gc_will_message(_Config) ->\n             WillTopic = <<\"will/t\">>,\n             ok = emqx:subscribe(WillTopic, #{qos => 2}),\n             ClientId = <<\"will_msg_client\">>,\n-            Client = start_client(#{\n+            Client = start_connect_client(#{\n                 clientid => ClientId,\n                 will_topic => WillTopic,\n                 will_payload => <<\"will payload\">>,\n                 will_qos => 0,\n                 will_props => #{'Will-Delay-Interval' => 300}\n             }),\n-            {ok, _} = emqtt:connect(Client),\n             %% Use reason code =/= `?RC_SUCCESS' to allow will message\n             {ok, {ok, _}} =\n                 ?wait_async_action("
    }
  ],
  "fix_category": "Sleep",
  "root_cause_category": "Test order dependency",
  "root_cause_subcategory": NaN
}