{
  "id": 236,
  "repo": "ray",
  "issue_url": "https://github.com/ray-project/ray/pull/56152",
  "pr_url": "https://github.com/ray-project/ray/pull/56152",
  "issue_description": "## Why are these changes needed?\r\n\r\nTSAN failure is a data race only in the test's `FakeShutdownExecutor`, not production code. Fake was writing shared `std::string` fields from two threads without synchronization -- https://buildkite.com/ray-project/postmerge/builds/12666#019907c0-3bdd-4401-9aa8-6f13215ce819/176-796\r\n\r\n- Added a `std::mutex` to `FakeShutdownExecutor` and guarded assignments to `last_exit_type` and `last_detail` in all `Execute*` methods. No production code changes.\r\n- Added mutex-guarded getters in `FakeShutdownExecutor` and used them in the assertion to eliminate remaining unsynchronized reads in the TSAN test.\r\n\r\n## Related issue number\r\n\r\nCloses #55801\r\n",
  "files_changed": [
    {
      "filename": "src/ray/core_worker/tests/BUILD.bazel",
      "status": "modified",
      "patch": "@@ -18,6 +18,7 @@ ray_cc_test(\n     tags = [\"team:core\"],\n     deps = [\n         \"//src/ray/core_worker:shutdown_coordinator\",\n+        \"@com_google_absl//absl/synchronization\",\n         \"@com_google_googletest//:gtest\",\n         \"@com_google_googletest//:gtest_main\",\n     ],"
    },
    {
      "filename": "src/ray/core_worker/tests/shutdown_coordinator_test.cc",
      "status": "modified",
      "patch": "@@ -24,6 +24,7 @@\n #include <utility>\n #include <vector>\n \n+#include \"absl/synchronization/mutex.h\"\n #include \"ray/common/buffer.h\"\n #include \"src/ray/protobuf/common.pb.h\"\n \n@@ -41,42 +42,68 @@ class FakeShutdownExecutor : public ShutdownExecutorInterface {\n \n   std::string last_exit_type;\n   std::string last_detail;\n+  mutable absl::Mutex mu_;\n+\n+  std::string GetLastExitType() const {\n+    absl::MutexLock lk(&mu_);\n+    return last_exit_type;\n+  }\n+\n+  std::string GetLastDetail() const {\n+    absl::MutexLock lk(&mu_);\n+    return last_detail;\n+  }\n \n   void ExecuteGracefulShutdown(std::string_view exit_type,\n                                std::string_view detail,\n                                std::chrono::milliseconds timeout_ms) override {\n     graceful_calls++;\n-    last_exit_type = std::string(exit_type);\n-    last_detail = std::string(detail);\n+    {\n+      absl::MutexLock lk(&mu_);\n+      last_exit_type = std::string(exit_type);\n+      last_detail = std::string(detail);\n+    }\n   }\n   void ExecuteForceShutdown(std::string_view exit_type,\n                             std::string_view detail) override {\n     force_calls++;\n-    last_exit_type = std::string(exit_type);\n-    last_detail = std::string(detail);\n+    {\n+      absl::MutexLock lk(&mu_);\n+      last_exit_type = std::string(exit_type);\n+      last_detail = std::string(detail);\n+    }\n   }\n   void ExecuteWorkerExit(std::string_view exit_type,\n                          std::string_view detail,\n                          std::chrono::milliseconds timeout_ms) override {\n     worker_exit_calls++;\n-    last_exit_type = std::string(exit_type);\n-    last_detail = std::string(detail);\n+    {\n+      absl::MutexLock lk(&mu_);\n+      last_exit_type = std::string(exit_type);\n+      last_detail = std::string(detail);\n+    }\n   }\n   void ExecuteExit(std::string_view exit_type,\n                    std::string_view detail,\n                    std::chrono::milliseconds timeout_ms,\n                    const std::shared_ptr<::ray::LocalMemoryBuffer>\n                        &creation_task_exception_pb_bytes) override {\n     worker_exit_calls++;\n-    last_exit_type = std::string(exit_type);\n-    last_detail = std::string(detail);\n+    {\n+      absl::MutexLock lk(&mu_);\n+      last_exit_type = std::string(exit_type);\n+      last_detail = std::string(detail);\n+    }\n   }\n   void ExecuteHandleExit(std::string_view exit_type,\n                          std::string_view detail,\n                          std::chrono::milliseconds timeout_ms) override {\n     handle_exit_calls++;\n-    last_exit_type = std::string(exit_type);\n-    last_detail = std::string(detail);\n+    {\n+      absl::MutexLock lk(&mu_);\n+      last_exit_type = std::string(exit_type);\n+      last_detail = std::string(detail);\n+    }\n   }\n   void KillChildProcessesImmediately() override {}\n   bool ShouldWorkerIdleExit() const override { return idle_exit_allowed.load(); }\n@@ -366,7 +393,8 @@ TEST_F(ShutdownCoordinatorTest, Concurrent_DoubleForce_ForceExecutesOnce) {\n   // Verify that only one forced shutdown was called\n   EXPECT_EQ(fake_ptr->force_calls.load(), 1);\n   EXPECT_EQ(fake_ptr->graceful_calls.load(), 0);\n-  EXPECT_TRUE(fake_ptr->last_detail == \"force1\" || fake_ptr->last_detail == \"force2\");\n+  EXPECT_TRUE(fake_ptr->GetLastDetail() == \"force1\" ||\n+              fake_ptr->GetLastDetail() == \"force2\");\n }\n \n }  // namespace core"
    }
  ],
  "fix_category": "Lock atomic region",
  "root_cause_category": "Concurrency",
  "root_cause_subcategory": NaN
}