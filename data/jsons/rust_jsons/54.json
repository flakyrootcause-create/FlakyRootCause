{
  "id": 54,
  "repo": "sui",
  "issue_url": "https://github.com/MystenLabs/sui/issues/5021",
  "pr_url": "https://github.com/MystenLabs/sui/pull/5099",
  "issue_description": "`test_process_certificate` (https://github.com/MystenLabs/sui/blob/main/crates/sui-core/src/unit_tests/authority_aggregator_tests.rs#L815) is flaky. The first run usually succeeds, but if you iterate the test it will quickly fail.\r\n\r\nTo reproduce, run: \r\n\r\n     $ MSIM_TEST_NUM=10 cargo simtest test_process_certificate\r\n\r\nThis will usually fail in the first few iterations. If we do nothing, this will likely eventually fail on the first try during an unlucky CI run.\r\n\r\n I took a look at the logs and it appears this may be a real bug, not just a fragile test - passing runs indicate that `sync_certificate_to_authority` is called more often when the test passes then when it fails: \r\n\r\n<img width=\"1713\" alt=\"image\" src=\"https://user-images.githubusercontent.com/103447440/194340895-4a1d0b79-38ee-4a47-a6c0-a30631af0c75.png\">\r\n\r\n(After https://github.com/MystenLabs/sui/pull/5020 merges, it will be possible to reproduce the failed iteration exactly by specifying the random seed - for now, that does not work).",
  "files_changed": [
    {
      "filename": "crates/sui-core/src/authority_aggregator.rs",
      "status": "modified",
      "patch": "@@ -1485,36 +1485,12 @@ where\n                                 name = ?name.concise(),\n                                 \"Validator handled certificate successfully\",\n                             );\n-                            // We got an ok answer, so returning the result of processing\n-                            // the transaction.\n-                            return res;\n                         }\n \n-                        // LockErrors indicate the authority may be out-of-date.\n-                        // We only attempt to update authority and retry if we are seeing LockErrors.\n-                        // For any other error, we stop here and return.\n-                        if !matches!(res, Err(SuiError::ObjectErrors { .. })) {\n-                            debug!(\n-                                tx_digest = ?tx_digest,\n-                                name = ?name.concise(),\n-                                \"Error from validator handle_confirmation_transaction: {:?}\",\n-                                res\n-                            );\n-                            return res;\n-                        }\n-\n-                        debug!(authority =? name, error =? res, ?timeout_after_quorum, \"Validator out of date - syncing certificates\");\n-                        // If we got LockErrors, we try to update the authority asynchronously\n-                        self.sync_certificate_to_authority(\n-                                cert_ref.clone(),\n-                                name,\n-                                DEFAULT_RETRIES,\n-                                self.timeouts.authority_request_timeout,\n-                                self.timeouts.pre_quorum_timeout,\n-                            )\n-                            .instrument(tracing::trace_span!(\"sync_cert\", authority =? name.concise()))\n-                            .await\n-                            .map_err(|e| { info!(err =? e, \"Error from sync_certificate\"); e})\n+                        // The authority may have failed to process the certificate if there were\n+                        // missing parents. In that case, the authority will attempt to perform causal\n+                        // completion and execute the cert later.\n+                        res\n                     })\n                 },\n                 |mut state, name, weight, result| {\n@@ -1599,15 +1575,6 @@ where\n         })\n     }\n \n-    /// Find the higgest sequence number that is known to a quorum of authorities.\n-    /// NOTE: This is only reliable in the synchronous model, with a sufficient timeout value.\n-    #[cfg(test)]\n-    async fn get_latest_sequence_number(&self, object_id: ObjectID) -> SequenceNumber {\n-        let (object_infos, _certificates) = self.get_object_by_id(object_id).await.unwrap(); // Not safe, but want to blow up if testing.\n-        let top_ref = object_infos.keys().last().unwrap().0;\n-        top_ref.1\n-    }\n-\n     pub async fn execute_transaction(\n         &self,\n         transaction: &Transaction,"
    },
    {
      "filename": "crates/sui-core/src/authority_server.rs",
      "status": "modified",
      "patch": "@@ -25,6 +25,7 @@ use sui_network::{\n };\n \n use sui_types::{error::*, messages::*};\n+use tap::TapFallible;\n use tokio::{\n     sync::mpsc::{channel, Receiver, Sender},\n     task::JoinHandle,\n@@ -34,7 +35,7 @@ use sui_types::messages_checkpoint::CheckpointRequest;\n use sui_types::messages_checkpoint::CheckpointResponse;\n \n use crate::authority::ConsensusHandler;\n-use tracing::{info, Instrument};\n+use tracing::{error, info, Instrument};\n \n #[cfg(test)]\n #[path = \"unit_tests/server_tests.rs\"]\n@@ -444,13 +445,23 @@ impl ValidatorService {\n             tx_kind = certificate.signed_data.data.kind_as_str()\n         );\n \n-        let response = state\n-            .handle_certificate(certificate)\n+        match state\n+            .handle_certificate(certificate.clone())\n             .instrument(span)\n             .await\n-            .map_err(|e| tonic::Status::internal(e.to_string()))?;\n-\n-        Ok(tonic::Response::new(response))\n+            .map_err(|e| tonic::Status::internal(e.to_string()))\n+        {\n+            Err(e) => {\n+                // Record the cert for later execution, including causal completion if necessary.\n+                let tx_digest = *tx_digest;\n+                let _ = state\n+                    .database\n+                    .add_pending_certificates(vec![(tx_digest, Some(certificate))])\n+                    .tap_err(|e| error!(?tx_digest, \"add_pending_certificates failed: {}\", e));\n+                Err(e)\n+            }\n+            Ok(response) => Ok(tonic::Response::new(response)),\n+        }\n     }\n }\n "
    },
    {
      "filename": "crates/sui-core/src/unit_tests/authority_aggregator_tests.rs",
      "status": "modified",
      "patch": "@@ -792,73 +792,6 @@ async fn test_sync_all_owned_objects() {\n     );\n }\n \n-async fn get_owned_objects(\n-    authorities: &AuthorityAggregator<LocalAuthorityClient>,\n-    addr: SuiAddress,\n-) -> BTreeMap<ObjectRef, Vec<AuthorityPublicKeyBytes>> {\n-    let (owned_objects, _) = authorities\n-        .get_all_owned_objects(addr, Duration::from_secs(10))\n-        .await\n-        .unwrap();\n-\n-    // As a result, we have 2 gas objects and 1 created object.\n-    dbg!(&owned_objects);\n-    owned_objects\n-}\n-\n-#[sim_test]\n-async fn test_process_certificate() {\n-    let (addr1, key1): (_, AccountKeyPair) = get_key_pair();\n-    let gas_object1 = Object::with_owner_for_testing(addr1);\n-    let gas_object2 = Object::with_owner_for_testing(addr1);\n-    let (authorities, _, pkg_ref) =\n-        init_local_authorities(4, vec![gas_object1.clone(), gas_object2.clone()]).await;\n-    let authority_clients: Vec<_> = authorities.authority_clients.values().collect();\n-\n-    // Make a schedule of transactions\n-    let gas_ref_1 = get_latest_ref(authority_clients[0], gas_object1.id()).await;\n-    let create1 = crate_object_move_transaction(addr1, &key1, addr1, 100, pkg_ref, gas_ref_1);\n-\n-    do_transaction(authority_clients[0], &create1).await;\n-    do_transaction(authority_clients[1], &create1).await;\n-    do_transaction(authority_clients[2], &create1).await;\n-\n-    // Get a cert\n-    let cert1 = extract_cert(&authority_clients, &authorities.committee, create1.digest()).await;\n-\n-    // Submit the cert to 1 authority.\n-    let new_ref_1 = do_cert(authority_clients[0], &cert1).await.created[0].0;\n-    do_cert(authority_clients[1], &cert1).await;\n-    do_cert(authority_clients[2], &cert1).await;\n-\n-    // Check the new object is at version 1\n-    let new_object_version = authorities.get_latest_sequence_number(new_ref_1.0).await;\n-    assert_eq!(SequenceNumber::from(1), new_object_version);\n-    get_owned_objects(&authorities, addr1).await;\n-\n-    // Make a schedule of transactions\n-    let gas_ref_set = get_latest_ref(authority_clients[0], gas_object1.id()).await;\n-    let create2 = set_object_move_transaction(addr1, &key1, new_ref_1, 100, pkg_ref, gas_ref_set);\n-\n-    do_transaction(authority_clients[0], &create2).await;\n-    do_transaction(authority_clients[1], &create2).await;\n-    do_transaction(authority_clients[2], &create2).await;\n-\n-    let cert2 = extract_cert(&authority_clients, &authorities.committee, create2.digest()).await;\n-    get_owned_objects(&authorities, addr1).await;\n-\n-    // Test: process the certificate, including bring up to date authority 3.\n-    //       which is 2 certs behind.\n-    authorities.process_certificate(cert2).await.unwrap();\n-    // Give authority 3 enough time to process the certificate\n-    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;\n-    let owned_object = get_owned_objects(&authorities, addr1).await;\n-    assert_eq!(3, owned_object.len());\n-    // Check this is the latest version.\n-    let new_object_version = authorities.get_latest_sequence_number(new_ref_1.0).await;\n-    assert_eq!(SequenceNumber::from(2), new_object_version);\n-}\n-\n #[sim_test]\n async fn test_execute_cert_to_true_effects() {\n     let (addr1, key1): (_, AccountKeyPair) = get_key_pair();"
    }
  ],
  "fix_category": "Wait",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": "Wait"
}