{
  "id": 59,
  "repo": "graph-node",
  "issue_url": "https://github.com/graphprotocol/graph-node/issues/434",
  "pr_url": "https://github.com/graphprotocol/graph-node/pull/562",
  "issue_description": null,
  "files_changed": [
    {
      "filename": "core/tests/tests.rs",
      "status": "modified",
      "patch": "@@ -11,16 +11,15 @@ use walkdir::WalkDir;\n use std::collections::HashSet;\n use std::fs::read_to_string;\n use std::io::Cursor;\n-use std::iter::FromIterator;\n+use std::sync::Mutex;\n use std::time::Duration;\n use std::time::Instant;\n \n use graph::components::ethereum::*;\n-use graph::ethabi::Token;\n use graph::prelude::*;\n+use graph::web3::types::*;\n use graph_core::SubgraphInstanceManager;\n-use graph_mock::{FakeStore, MockStore};\n-use graph_runtime_wasm::RuntimeHostBuilder;\n+use graph_mock::{FakeStore, MockBlockStreamBuilder, MockStore};\n \n /// Adds subgraph located in `test/subgraphs/`, replacing \"link to\" placeholders\n /// in the subgraph manifest with links to files just added into a local IPFS\n@@ -63,55 +62,64 @@ fn add_subgraph_to_ipfs(\n     ipfs_upload.and_then(move |subgraph_string| add(&add_client, subgraph_string))\n }\n \n-#[cfg(any())]\n #[test]\n fn multiple_data_sources_per_subgraph() {\n-    struct MockEthereumAdapter {\n-        received_subscriptions: Vec<String>,\n+    struct MockRuntimeHost {\n+        manifest: SubgraphManifest,\n     }\n \n-    impl EthereumAdapter for MockEthereumAdapter {\n-        fn net_identifiers(\n-            &self,\n-        ) -> Box<Future<Item = EthereumNetworkIdentifier, Error = Error> + Send> {\n-            unimplemented!()\n+    impl RuntimeHost for MockRuntimeHost {\n+        fn subgraph_manifest(&self) -> &SubgraphManifest {\n+            &self.manifest\n         }\n \n-        fn block_by_hash(\n-            &self,\n-            _: H256,\n-        ) -> Box<Future<Item = Option<EthereumBlock>, Error = Error> + Send> {\n-            unimplemented!()\n+        fn matches_log(&self, _: &Log) -> bool {\n+            true\n         }\n \n-        fn block_hash_by_block_number(\n+        fn process_log(\n             &self,\n-            _: u64,\n-        ) -> Box<Future<Item = Option<H256>, Error = Error> + Send> {\n-            unimplemented!()\n+            _: &Logger,\n+            _: Arc<EthereumBlock>,\n+            _: Arc<Transaction>,\n+            _: Arc<Log>,\n+            _: Vec<EntityOperation>,\n+        ) -> Box<Future<Item = Vec<EntityOperation>, Error = Error> + Send> {\n+            unimplemented!();\n         }\n+    }\n \n-        fn is_on_main_chain(\n-            &self,\n-            _: EthereumBlockPointer,\n-        ) -> Box<Future<Item = bool, Error = Error> + Send> {\n-            unimplemented!()\n+    #[derive(Default)]\n+    struct MockRuntimeHostBuilder {\n+        data_sources_received: Arc<Mutex<Vec<DataSource>>>,\n+    }\n+\n+    impl MockRuntimeHostBuilder {\n+        fn new() -> Self {\n+            Self::default()\n         }\n+    }\n \n-        fn find_first_blocks_with_logs(\n-            &self,\n-            _: u64,\n-            _: u64,\n-            _: EthereumLogFilter,\n-        ) -> Box<Future<Item = Vec<EthereumBlockPointer>, Error = Error> + Send> {\n-            unimplemented!()\n+    impl Clone for MockRuntimeHostBuilder {\n+        fn clone(&self) -> Self {\n+            Self {\n+                data_sources_received: self.data_sources_received.clone(),\n+            }\n         }\n+    }\n \n-        fn contract_call(\n+    impl RuntimeHostBuilder for MockRuntimeHostBuilder {\n+        type Host = MockRuntimeHost;\n+\n+        fn build(\n             &self,\n-            _: EthereumContractCall,\n-        ) -> Box<Future<Item = Vec<Token>, Error = EthereumContractCallError>> {\n-            unimplemented!()\n+            _: &Logger,\n+            manifest: SubgraphManifest,\n+            data_source: DataSource,\n+        ) -> Self::Host {\n+            self.data_sources_received.lock().unwrap().push(data_source);\n+\n+            MockRuntimeHost { manifest }\n         }\n     }\n \n@@ -126,22 +134,19 @@ fn multiple_data_sources_per_subgraph() {\n         .block_on(future::lazy(|| {\n             let resolver = Arc::new(IpfsClient::default());\n             let logger = Logger::root(slog::Discard, o!());\n-            let eth_adapter = Arc::new(Mutex::new(MockEthereumAdapter {\n-                received_subscriptions: vec![],\n-            }));\n-            let fake_store = Arc::new(Mutex::new(FakeStore));\n-            let host_builder = RuntimeHostBuilder::new(\n+            let store = Arc::new(FakeStore);\n+            let host_builder = MockRuntimeHostBuilder::new();\n+            let block_stream_builder = MockBlockStreamBuilder::new();\n+            let manager = SubgraphInstanceManager::new(\n                 &logger,\n-                eth_adapter.clone(),\n-                resolver.clone(),\n-                fake_store.clone(),\n+                store,\n+                host_builder.clone(),\n+                block_stream_builder,\n+                None,\n             );\n-            let manager = RuntimeManager::new(&logger, fake_store, host_builder);\n \n-            // Load a subgraph with two data sets, one listening for `ExampleEvent`\n-            // and the other for `ExampleEvent2`.\n+            // Load a subgraph with two data sources\n             SubgraphManifest::resolve(\n-                \"example_subgraph\".to_owned(),\n                 Link {\n                     link: subgraph_link,\n                 },\n@@ -153,19 +158,29 @@ fn multiple_data_sources_per_subgraph() {\n                     .event_sink()\n                     .send(SubgraphProviderEvent::SubgraphStart(subgraph))\n             }).and_then(move |_| {\n-                // If we subscribed to both events, then we're handling multiple data sets.\n+                // If we created a RuntimeHost for each data source,\n+                // then we're handling multiple data sets.\n                 // Wait for thirty seconds for that to happen, otherwise fail the test.\n                 let start_time = Instant::now();\n                 let max_wait = Duration::from_secs(30);\n                 loop {\n-                    let subscriptions = &eth_adapter.lock().unwrap().received_subscriptions;\n-                    if subscriptions.contains(&\"ExampleEvent\".to_owned())\n-                        && subscriptions.contains(&\"ExampleEvent2\".to_owned())\n-                    {\n+                    let data_sources_received = host_builder.data_sources_received.lock().unwrap();\n+                    let data_source_names = data_sources_received\n+                        .iter()\n+                        .map(|data_source| data_source.name.as_str())\n+                        .collect::<HashSet<&str>>();\n+                    use std::iter::FromIterator;\n+                    let expected_data_source_names =\n+                        HashSet::from_iter(vec![\"ExampleDataSource\", \"ExampleDataSource2\"]);\n+\n+                    if data_source_names == expected_data_source_names {\n                         break;\n                     }\n                     if Instant::now().duration_since(start_time) > max_wait {\n-                        panic!(\"Test failed, events subscribed to: {:?}\", subscriptions)\n+                        panic!(\n+                            \"Test failed, runtime hosts created for data sources: {:?}\",\n+                            data_source_names\n+                        )\n                     }\n                     ::std::thread::yield_now();\n                 }"
    },
    {
      "filename": "graph/src/components/store.rs",
      "status": "modified",
      "patch": "@@ -1,30 +1,29 @@\n use failure::Error;\n use futures::Future;\n use futures::Stream;\n-use std::fmt;\n use web3::types::H256;\n \n use data::store::*;\n use prelude::*;\n \n /// Key by which an individual entity in the store can be accessed.\n #[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct StoreKey {\n-    // ID of the subgraph.\n-    pub subgraph: String,\n+pub struct EntityKey {\n+    /// ID of the subgraph.\n+    pub subgraph_id: String,\n \n     /// Name of the entity type.\n-    pub entity: String,\n+    pub entity_type: String,\n \n     /// ID of the individual entity.\n-    pub id: String,\n+    pub entity_id: String,\n }\n \n /// Supported types of store filters.\n #[derive(Clone, Debug, PartialEq)]\n-pub enum StoreFilter {\n-    And(Vec<StoreFilter>),\n-    Or(Vec<StoreFilter>),\n+pub enum EntityFilter {\n+    And(Vec<EntityFilter>),\n+    Or(Vec<EntityFilter>),\n     Equal(Attribute, Value),\n     Not(Attribute, Value),\n     GreaterThan(Attribute, Value),\n@@ -43,14 +42,14 @@ pub enum StoreFilter {\n \n /// The order in which entities should be restored from a store.\n #[derive(Clone, Debug, PartialEq)]\n-pub enum StoreOrder {\n+pub enum EntityOrder {\n     Ascending,\n     Descending,\n }\n \n /// How many entities to return, how many to skip etc.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct StoreRange {\n+pub struct EntityRange {\n     /// How many entities to return.\n     pub first: usize,\n \n@@ -60,24 +59,24 @@ pub struct StoreRange {\n \n /// A query for entities in a store.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct StoreQuery {\n-    // ID of the subgraph.\n-    pub subgraph: String,\n+pub struct EntityQuery {\n+    /// ID of the subgraph.\n+    pub subgraph_id: SubgraphId,\n \n     /// The name of the entity type.\n-    pub entity: String,\n+    pub entity_type: String,\n \n     /// Filter to filter entities by.\n-    pub filter: Option<StoreFilter>,\n+    pub filter: Option<EntityFilter>,\n \n     /// An optional attribute to order the entities by.\n     pub order_by: Option<(String, ValueType)>,\n \n     /// The direction to order entities in.\n-    pub order_direction: Option<StoreOrder>,\n+    pub order_direction: Option<EntityOrder>,\n \n     /// An optional range to limit the size of the result.\n-    pub range: Option<StoreRange>,\n+    pub range: Option<EntityRange>,\n }\n \n /// Operation types that lead to entity changes.\n@@ -96,11 +95,11 @@ pub enum EntityChangeOperation {\n #[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]\n pub struct EntityChange {\n     /// ID of the subgraph the changed entity belongs to.\n-    pub subgraph: String,\n+    pub subgraph_id: String,\n     /// Entity type name of the changed entity.\n-    pub entity: String,\n+    pub entity_type: String,\n     /// ID of the changed entity.\n-    pub id: String,\n+    pub entity_id: String,\n     /// Operation that caused the change.\n     pub operation: EntityChangeOperation,\n }\n@@ -109,21 +108,12 @@ pub struct EntityChange {\n pub type EntityChangeStream = Box<Stream<Item = EntityChange, Error = ()> + Send>;\n \n /// An entity operation that can be transacted into the store.\n-#[derive(Clone, Debug)]\n+#[derive(Clone, Debug, PartialEq)]\n pub enum EntityOperation {\n     /// An entity is created or updated.\n-    Set {\n-        subgraph: String,\n-        entity: String,\n-        id: String,\n-        data: Entity,\n-    },\n+    Set { key: EntityKey, data: Entity },\n     /// An entity is removed.\n-    Remove {\n-        subgraph: String,\n-        entity: String,\n-        id: String,\n-    },\n+    Remove { key: EntityKey },\n }\n \n impl EntityOperation {\n@@ -137,31 +127,23 @@ impl EntityOperation {\n         }\n     }\n \n-    pub fn entity_info(&self) -> (&String, &String, &String) {\n+    pub fn entity_key(&self) -> &EntityKey {\n         use self::EntityOperation::*;\n+\n         match self {\n-            Set {\n-                subgraph,\n-                entity,\n-                id,\n-                ..\n-            } => (subgraph, entity, id),\n-            Remove {\n-                subgraph,\n-                entity,\n-                id,\n-            } => (subgraph, entity, id),\n+            Set { ref key, .. } => key,\n+            Remove { ref key } => key,\n         }\n     }\n \n     /// Returns true if the operation matches a given store key.\n-    pub fn matches_entity(&self, key: &StoreKey) -> bool {\n-        self.entity_info() == (&key.subgraph, &key.entity, &key.id)\n+    pub fn matches_entity(&self, key: &EntityKey) -> bool {\n+        self.entity_key() == key\n     }\n \n     /// Returns true if the two operations match the same entity.\n     pub fn matches_same_entity(&self, other: &EntityOperation) -> bool {\n-        self.entity_info() == other.entity_info()\n+        self.entity_key() == other.entity_key()\n     }\n \n     /// Applies the operation to an existing entity (may be None).\n@@ -170,6 +152,7 @@ impl EntityOperation {\n     /// Returns `None` if the operation is a `Remove`.\n     pub fn apply(&self, entity: Option<Entity>) -> Option<Entity> {\n         use self::EntityOperation::*;\n+\n         match self {\n             Set { data, .. } => Some(\n                 entity\n@@ -189,19 +172,12 @@ impl EntityOperation {\n     pub fn merge(&self, other: &EntityOperation) -> Self {\n         use self::EntityOperation::*;\n \n-        assert_eq!(self.entity_info(), other.entity_info());\n+        assert_eq!(self.entity_key(), other.entity_key());\n \n         match other {\n             Remove { .. } => other.clone(),\n-            Set {\n-                subgraph,\n-                entity,\n-                id,\n-                data,\n-            } => EntityOperation::Set {\n-                subgraph: subgraph.clone(),\n-                entity: entity.clone(),\n-                id: id.clone(),\n+            Set { key, data } => Set {\n+                key: key.clone(),\n                 data: {\n                     let mut entity = match self {\n                         Set { data, .. } => data.clone(),\n@@ -247,23 +223,6 @@ impl EntityOperation {\n     }\n }\n \n-/// The source of the events being sent to the store\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-pub enum EventSource {\n-    EthereumBlock(H256),\n-}\n-\n-// Implementing the display trait also provides a ToString trait implementation\n-impl fmt::Display for EventSource {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let printable_source = match *self {\n-            // Use LowerHex to format hash as hex string\n-            EventSource::EthereumBlock(hash) => format!(\"{:x}\", hash),\n-        };\n-        write!(f, \"{}\", printable_source)\n-    }\n-}\n-\n /// A pair of subgraph ID and entity type name.\n pub type SubgraphEntityPair = (SubgraphId, String);\n \n@@ -311,11 +270,11 @@ pub trait Store: Send + Sync + 'static {\n \n     /// Looks up an entity using the given store key.\n     // TODO need to validate block ptr\n-    fn get(&self, key: StoreKey) -> Result<Option<Entity>, QueryExecutionError>;\n+    fn get(&self, key: EntityKey) -> Result<Option<Entity>, QueryExecutionError>;\n \n     /// Queries the store for entities that match the store query.\n     // TODO need to validate block ptr\n-    fn find(&self, query: StoreQuery) -> Result<Vec<Entity>, QueryExecutionError>;\n+    fn find(&self, query: EntityQuery) -> Result<Vec<Entity>, QueryExecutionError>;\n \n     /// Updates the block pointer.  Careful: this is only safe to use if it is known that no store\n     /// changes are needed to go from `block_ptr_from` to `block_ptr_to`."
    },
    {
      "filename": "graph/src/lib.rs",
      "status": "modified",
      "patch": "@@ -66,8 +66,8 @@ pub mod prelude {\n     pub use components::server::query::GraphQLServer;\n     pub use components::server::subscription::SubscriptionServer;\n     pub use components::store::{\n-        ChainStore, EntityChange, EntityChangeOperation, EntityChangeStream, EntityOperation,\n-        EventSource, Store, StoreFilter, StoreKey, StoreOrder, StoreQuery, StoreRange,\n+        ChainStore, EntityChange, EntityChangeOperation, EntityChangeStream, EntityFilter,\n+        EntityKey, EntityOperation, EntityOrder, EntityQuery, EntityRange, Store,\n         SubgraphEntityPair,\n     };\n     pub use components::subgraph::{"
    },
    {
      "filename": "graphql/src/store/query.rs",
      "status": "modified",
      "patch": "@@ -4,25 +4,25 @@ use schema::ast as sast;\n use std::collections::{BTreeMap, HashMap, HashSet, VecDeque};\n use std::mem::discriminant;\n \n-/// Builds a StoreQuery from GraphQL arguments.\n+/// Builds a EntityQuery from GraphQL arguments.\n pub fn build_query(\n     entity: &s::ObjectType,\n     arguments: &HashMap<&q::Name, q::Value>,\n-) -> Result<StoreQuery, QueryExecutionError> {\n-    Ok(StoreQuery {\n-        subgraph: parse_subgraph_id(entity)?,\n-        entity: entity.name.to_owned(),\n+) -> Result<EntityQuery, QueryExecutionError> {\n+    Ok(EntityQuery {\n+        subgraph_id: parse_subgraph_id(entity)?,\n+        entity_type: entity.name.to_owned(),\n         range: build_range(arguments)?,\n         filter: build_filter(entity, arguments)?,\n         order_by: build_order_by(entity, arguments)?,\n         order_direction: build_order_direction(arguments)?,\n     })\n }\n \n-/// Parses GraphQL arguments into a StoreRange, if present.\n+/// Parses GraphQL arguments into a EntityRange, if present.\n fn build_range(\n     arguments: &HashMap<&q::Name, q::Value>,\n-) -> Result<Option<StoreRange>, QueryExecutionError> {\n+) -> Result<Option<EntityRange>, QueryExecutionError> {\n     let first = arguments\n         .get(&\"first\".to_string())\n         .map_or(Ok(None), |value| {\n@@ -66,17 +66,17 @@ fn build_range(\n \n     Ok(match (first.unwrap(), skip.unwrap()) {\n         (None, None) => None,\n-        (Some(first), None) => Some(StoreRange { first, skip: 0 }),\n-        (Some(first), Some(skip)) => Some(StoreRange { first, skip }),\n-        (None, Some(skip)) => Some(StoreRange { first: 100, skip }),\n+        (Some(first), None) => Some(EntityRange { first, skip: 0 }),\n+        (Some(first), Some(skip)) => Some(EntityRange { first, skip }),\n+        (None, Some(skip)) => Some(EntityRange { first: 100, skip }),\n     })\n }\n \n-/// Parses GraphQL arguments into a StoreFilter, if present.\n+/// Parses GraphQL arguments into a EntityFilter, if present.\n fn build_filter(\n     entity: &s::ObjectType,\n     arguments: &HashMap<&q::Name, q::Value>,\n-) -> Result<Option<StoreFilter>, QueryExecutionError> {\n+) -> Result<Option<EntityFilter>, QueryExecutionError> {\n     match arguments.get(&\"where\".to_string()) {\n         Some(value) => match value {\n             q::Value::Object(object) => Ok(object),\n@@ -86,12 +86,12 @@ fn build_filter(\n     }.and_then(|object| build_filter_from_object(entity, &object))\n }\n \n-/// Parses a GraphQL input object into a StoreFilter, if present.\n+/// Parses a GraphQL input object into a EntityFilter, if present.\n fn build_filter_from_object(\n     entity: &s::ObjectType,\n     object: &BTreeMap<q::Name, q::Value>,\n-) -> Result<Option<StoreFilter>, QueryExecutionError> {\n-    Ok(Some(StoreFilter::And({\n+) -> Result<Option<EntityFilter>, QueryExecutionError> {\n+    Ok(Some(EntityFilter::And({\n         object\n             .iter()\n             .map(|(key, value)| {\n@@ -107,22 +107,22 @@ fn build_filter_from_object(\n                 let store_value = Value::from_query_value(value, &ty)?;\n \n                 Ok(match op {\n-                    Not => StoreFilter::Not(field_name, store_value),\n-                    GreaterThan => StoreFilter::GreaterThan(field_name, store_value),\n-                    LessThan => StoreFilter::LessThan(field_name, store_value),\n-                    GreaterOrEqual => StoreFilter::GreaterOrEqual(field_name, store_value),\n-                    LessOrEqual => StoreFilter::LessOrEqual(field_name, store_value),\n-                    In => StoreFilter::In(field_name, list_values(store_value, \"_in\")?),\n-                    NotIn => StoreFilter::NotIn(field_name, list_values(store_value, \"_not_in\")?),\n-                    Contains => StoreFilter::Contains(field_name, store_value),\n-                    NotContains => StoreFilter::NotContains(field_name, store_value),\n-                    StartsWith => StoreFilter::StartsWith(field_name, store_value),\n-                    NotStartsWith => StoreFilter::NotStartsWith(field_name, store_value),\n-                    EndsWith => StoreFilter::EndsWith(field_name, store_value),\n-                    NotEndsWith => StoreFilter::NotEndsWith(field_name, store_value),\n-                    Equal => StoreFilter::Equal(field_name, store_value),\n+                    Not => EntityFilter::Not(field_name, store_value),\n+                    GreaterThan => EntityFilter::GreaterThan(field_name, store_value),\n+                    LessThan => EntityFilter::LessThan(field_name, store_value),\n+                    GreaterOrEqual => EntityFilter::GreaterOrEqual(field_name, store_value),\n+                    LessOrEqual => EntityFilter::LessOrEqual(field_name, store_value),\n+                    In => EntityFilter::In(field_name, list_values(store_value, \"_in\")?),\n+                    NotIn => EntityFilter::NotIn(field_name, list_values(store_value, \"_not_in\")?),\n+                    Contains => EntityFilter::Contains(field_name, store_value),\n+                    NotContains => EntityFilter::NotContains(field_name, store_value),\n+                    StartsWith => EntityFilter::StartsWith(field_name, store_value),\n+                    NotStartsWith => EntityFilter::NotStartsWith(field_name, store_value),\n+                    EndsWith => EntityFilter::EndsWith(field_name, store_value),\n+                    NotEndsWith => EntityFilter::NotEndsWith(field_name, store_value),\n+                    Equal => EntityFilter::Equal(field_name, store_value),\n                 })\n-            }).collect::<Result<Vec<StoreFilter>, QueryExecutionError>>()?\n+            }).collect::<Result<Vec<EntityFilter>, QueryExecutionError>>()?\n     })))\n }\n \n@@ -178,15 +178,15 @@ fn build_order_by(\n         })\n }\n \n-/// Parses GraphQL arguments into a StoreOrder, if present.\n+/// Parses GraphQL arguments into a EntityOrder, if present.\n fn build_order_direction(\n     arguments: &HashMap<&q::Name, q::Value>,\n-) -> Result<Option<StoreOrder>, QueryExecutionError> {\n+) -> Result<Option<EntityOrder>, QueryExecutionError> {\n     Ok(arguments\n         .get(&\"orderDirection\".to_string())\n         .and_then(|value| match value {\n-            q::Value::Enum(name) if name == \"asc\" => Some(StoreOrder::Ascending),\n-            q::Value::Enum(name) if name == \"desc\" => Some(StoreOrder::Descending),\n+            q::Value::Enum(name) if name == \"asc\" => Some(EntityOrder::Ascending),\n+            q::Value::Enum(name) if name == \"desc\" => Some(EntityOrder::Descending),\n             _ => None,\n         }))\n }\n@@ -342,13 +342,13 @@ mod tests {\n         assert_eq!(\n             build_query(&object(\"Entity1\"), &HashMap::new())\n                 .unwrap()\n-                .entity,\n+                .entity_type,\n             \"Entity1\".to_string()\n         );\n         assert_eq!(\n             build_query(&object(\"Entity2\"), &HashMap::new())\n                 .unwrap()\n-                .entity,\n+                .entity_type,\n             \"Entity2\".to_string()\n         );\n     }\n@@ -371,13 +371,6 @@ mod tests {\n \n     #[test]\n     fn build_query_parses_order_by_from_enum_values_correctly() {\n-        let order_test = build_query(\n-            &default_object(),\n-            &HashMap::from_iter(\n-                vec![(&\"orderBy\".to_string(), q::Value::Enum(\"name\".to_string()))].into_iter(),\n-            ),\n-        ).unwrap()\n-        .order_by;\n         assert_eq!(\n             build_query(\n                 &default_object(),\n@@ -441,7 +434,7 @@ mod tests {\n                 )\n             ).unwrap()\n             .order_direction,\n-            Some(StoreOrder::Ascending)\n+            Some(EntityOrder::Ascending)\n         );\n         assert_eq!(\n             build_query(\n@@ -454,7 +447,7 @@ mod tests {\n                 )\n             ).unwrap()\n             .order_direction,\n-            Some(StoreOrder::Descending)\n+            Some(EntityOrder::Descending)\n         );\n         assert_eq!(\n             build_query(\n@@ -521,7 +514,7 @@ mod tests {\n                 )\n             ).unwrap()\n             .range,\n-            Some(StoreRange {\n+            Some(EntityRange {\n                 first: 100,\n                 skip: 50,\n             }),\n@@ -538,7 +531,7 @@ mod tests {\n                 )\n             ).unwrap()\n             .range,\n-            Some(StoreRange { first: 70, skip: 0 }),\n+            Some(EntityRange { first: 70, skip: 0 }),\n         );\n     }\n \n@@ -561,7 +554,7 @@ mod tests {\n                 )\n             ).unwrap()\n             .filter,\n-            Some(StoreFilter::And(vec![StoreFilter::EndsWith(\n+            Some(EntityFilter::And(vec![EntityFilter::EndsWith(\n                 \"name\".to_string(),\n                 Value::String(\"ello\".to_string()),\n             )]))"
    },
    {
      "filename": "graphql/src/store/resolver.rs",
      "status": "modified",
      "patch": "@@ -55,7 +55,7 @@ where\n     /// Returns true if the field is a derived field (i.e., if it is defined with\n     /// a @derivedFrom directive).\n     fn add_filter_for_derived_field(\n-        query: &mut StoreQuery,\n+        query: &mut EntityQuery,\n         parent: &Option<q::Value>,\n         field_definition: &s::Field,\n         object_type: &s::ObjectType,\n@@ -98,22 +98,22 @@ where\n             // single value type, we either create a `Contains` or `Equal`\n             // filter argument\n             let filter = match derived_from_field.field_type {\n-                s::Type::ListType(_) => StoreFilter::Contains(field_name, parent_id),\n+                s::Type::ListType(_) => EntityFilter::Contains(field_name, parent_id),\n                 s::Type::NonNullType(ref inner) => match inner.deref() {\n-                    s::Type::ListType(_) => StoreFilter::Contains(field_name, parent_id),\n-                    _ => StoreFilter::Equal(field_name, parent_id),\n+                    s::Type::ListType(_) => EntityFilter::Contains(field_name, parent_id),\n+                    _ => EntityFilter::Equal(field_name, parent_id),\n                 },\n-                _ => StoreFilter::Equal(field_name, parent_id),\n+                _ => EntityFilter::Equal(field_name, parent_id),\n             };\n \n             // Add the `Contains`/`Equal` filter to the top-level `And` filter, creating one\n             // if necessary\n-            let top_level_filter = query.filter.get_or_insert(StoreFilter::And(vec![]));\n+            let top_level_filter = query.filter.get_or_insert(EntityFilter::And(vec![]));\n             *top_level_filter = match top_level_filter {\n-                StoreFilter::And(ref mut filters) => {\n+                EntityFilter::And(ref mut filters) => {\n                     let mut filters = filters.clone();\n                     filters.push(filter);\n-                    StoreFilter::And(filters)\n+                    EntityFilter::And(filters)\n                 }\n                 _ => top_level_filter.clone(),\n             };\n@@ -126,7 +126,7 @@ where\n \n     /// Adds a filter for matching entities that are referenced by the given field.\n     fn add_filter_for_reference_field(\n-        query: &mut StoreQuery,\n+        query: &mut EntityQuery,\n         parent: &Option<q::Value>,\n         field_definition: &s::Field,\n         _object_type: &s::ObjectType,\n@@ -138,14 +138,14 @@ where\n                 .get(&field_definition.name)\n                 .and_then(|value| match value {\n                     q::Value::String(id) => {\n-                        Some(StoreFilter::Equal(String::from(\"id\"), Value::from(id)))\n+                        Some(EntityFilter::Equal(String::from(\"id\"), Value::from(id)))\n                     }\n-                    q::Value::List(ids) => Some(StoreFilter::Or(\n+                    q::Value::List(ids) => Some(EntityFilter::Or(\n                         ids.iter()\n                             .filter_map(|id| match id {\n                                 q::Value::String(s) => Some(s),\n                                 _ => None,\n-                            }).map(|id| StoreFilter::Equal(String::from(\"id\"), Value::from(id)))\n+                            }).map(|id| EntityFilter::Equal(String::from(\"id\"), Value::from(id)))\n                             .collect(),\n                     )),\n                     _ => None,\n@@ -157,12 +157,12 @@ where\n                 });\n \n             // Add the `Or` filter to the top-level `And` filter, creating one if necessary\n-            let top_level_filter = query.filter.get_or_insert(StoreFilter::And(vec![]));\n+            let top_level_filter = query.filter.get_or_insert(EntityFilter::And(vec![]));\n             *top_level_filter = match top_level_filter {\n-                StoreFilter::And(ref mut filters) => {\n+                EntityFilter::And(ref mut filters) => {\n                     let mut filters = filters.clone();\n                     filters.push(filter);\n-                    StoreFilter::And(filters)\n+                    EntityFilter::And(filters)\n                 }\n                 _ => top_level_filter.clone(),\n             };\n@@ -243,25 +243,25 @@ where\n         if let Some(id) = id {\n             return Ok(self\n                 .store\n-                .get(StoreKey {\n-                    subgraph: parse_subgraph_id(object_type).unwrap_or_else(|_| {\n+                .get(EntityKey {\n+                    subgraph_id: parse_subgraph_id(object_type).unwrap_or_else(|_| {\n                         panic!(\"Failed to get subgraph ID from type: {}\", object_type.name)\n                     }),\n-                    entity: object_type.name.to_owned(),\n-                    id: id.to_owned(),\n+                    entity_type: object_type.name.to_owned(),\n+                    entity_id: id.to_owned(),\n                 })?.map_or(q::Value::Null, |entity| entity.into()));\n         }\n \n         match parent {\n             Some(q::Value::Object(parent_object)) => match parent_object.get(field) {\n                 Some(q::Value::String(id)) => Ok(self\n                     .store\n-                    .get(StoreKey {\n-                        subgraph: parse_subgraph_id(object_type).unwrap_or_else(|_| {\n+                    .get(EntityKey {\n+                        subgraph_id: parse_subgraph_id(object_type).unwrap_or_else(|_| {\n                             panic!(\"Failed to get subgraph ID from type: {}\", object_type.name)\n                         }),\n-                        entity: object_type.name.to_owned(),\n-                        id: id.to_owned(),\n+                        entity_type: object_type.name.to_owned(),\n+                        entity_id: id.to_owned(),\n                     })?.map_or(q::Value::Null, |entity| entity.into())),\n                 _ => Ok(q::Value::Null),\n             },\n@@ -276,7 +276,7 @@ where\n                     object_type,\n                 );\n \n-                query.range = Some(StoreRange { first: 1, skip: 0 });\n+                query.range = Some(EntityRange { first: 1, skip: 0 });\n \n                 self.store.find(query).map(|entities| {\n                     entities"
    },
    {
      "filename": "graphql/tests/query.rs",
      "status": "modified",
      "patch": "@@ -1,4 +1,3 @@\n-#[macro_use]\n extern crate failure;\n extern crate futures;\n extern crate graphql_parser;\n@@ -9,11 +8,8 @@ extern crate graph_core;\n extern crate graph_graphql;\n \n use graphql_parser::query as q;\n-use std::sync::Mutex;\n \n-use graph::components::store::EventSource;\n use graph::prelude::*;\n-use graph::web3::types::{Block, Transaction, H256};\n use graph_graphql::prelude::*;\n \n fn test_schema() -> Schema {\n@@ -148,7 +144,7 @@ impl Store for TestStore {\n         unimplemented!()\n     }\n \n-    fn write_subgraph_name(&self, _: String, id: Option<SubgraphId>) -> Result<(), Error> {\n+    fn write_subgraph_name(&self, _: String, _: Option<SubgraphId>) -> Result<(), Error> {\n         unimplemented!()\n     }\n \n@@ -200,12 +196,12 @@ impl Store for TestStore {\n         unimplemented!()\n     }\n \n-    fn get(&self, key: StoreKey) -> Result<Option<Entity>, QueryExecutionError> {\n+    fn get(&self, key: EntityKey) -> Result<Option<Entity>, QueryExecutionError> {\n         self.entities\n             .iter()\n             .find(|entity| {\n-                entity.get(\"id\") == Some(&Value::String(key.id.clone()))\n-                    && entity.get(\"__typename\") == Some(&Value::String(key.entity.clone()))\n+                entity.get(\"id\") == Some(&Value::String(key.entity_id.clone()))\n+                    && entity.get(\"__typename\") == Some(&Value::String(key.entity_type.clone()))\n             }).map_or(\n                 Err(QueryExecutionError::ResolveEntitiesError(String::from(\n                     \"Mock get query error\",\n@@ -214,8 +210,8 @@ impl Store for TestStore {\n             )\n     }\n \n-    fn find(&self, query: StoreQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n-        let entity_name = Value::String(query.entity.clone());\n+    fn find(&self, query: EntityQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n+        let entity_name = Value::String(query.entity_type.clone());\n \n         let entities = self\n             .entities\n@@ -232,16 +228,16 @@ impl Store for TestStore {\n                     .filter\n                     .as_ref()\n                     .and_then(|filter| match filter {\n-                        StoreFilter::And(filters) => filters.get(0),\n+                        EntityFilter::And(filters) => filters.get(0),\n                         _ => None,\n                     }).map(|filter| match filter {\n-                        StoreFilter::Equal(k, v) => entity.get(k) == Some(&v),\n-                        StoreFilter::Contains(k, v) => match entity.get(k) {\n+                        EntityFilter::Equal(k, v) => entity.get(k) == Some(&v),\n+                        EntityFilter::Contains(k, v) => match entity.get(k) {\n                             Some(Value::List(values)) => values.contains(v),\n                             _ => false,\n                         },\n-                        StoreFilter::Or(filters) => filters.iter().any(|filter| match filter {\n-                            StoreFilter::Equal(k, v) => entity.get(k) == Some(&v),\n+                        EntityFilter::Or(filters) => filters.iter().any(|filter| match filter {\n+                            EntityFilter::Equal(k, v) => entity.get(k) == Some(&v),\n                             _ => unimplemented!(),\n                         }),\n                         _ => unimplemented!(),\n@@ -253,47 +249,6 @@ impl Store for TestStore {\n     }\n }\n \n-#[cfg(any())]\n-impl ChainStore for TestStore {\n-    type ChainHeadUpdateListener = graph::store::ChainHeadUpdateListener;\n-\n-    fn genesis_block_ptr(&self) -> Result<EthereumBlockPointer, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn upsert_blocks<'a, B: Stream<Item = EthereumBlock, Error = Error> + Send + 'a>(\n-        &self,\n-        _: B,\n-    ) -> Box<Future<Item = (), Error = Error> + Send + 'a> {\n-        unimplemented!()\n-    }\n-\n-    fn attempt_chain_head_update(&self, _: u64) -> Result<Vec<H256>, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn chain_head_updates(&self) -> Self::ChainHeadUpdateListener {\n-        unimplemented!()\n-    }\n-\n-    fn chain_head_ptr(&self) -> Result<Option<EthereumBlockPointer>, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn block(&self, _: H256) -> Result<Option<EthereumBlock>, Error> {\n-        unimplemented!()\n-    }\n-\n-    fn ancestor_block(\n-        &self,\n-        _: EthereumBlockPointer,\n-        _: u64,\n-    ) -> Result<Option<EthereumBlock>, Error> {\n-        unimplemented!()\n-    }\n-}\n-\n-#[cfg(any())]\n fn execute_query_document(query: q::Document) -> QueryResult {\n     let query = Query {\n         schema: test_schema(),\n@@ -302,7 +257,7 @@ fn execute_query_document(query: q::Document) -> QueryResult {\n     };\n \n     let logger = Logger::root(slog::Discard, o!());\n-    let store = Arc::new(Mutex::new(TestStore::new()));\n+    let store = Arc::new(TestStore::new());\n     let store_resolver = StoreResolver::new(&logger, store);\n \n     let options = QueryExecutionOptions {\n@@ -314,7 +269,6 @@ fn execute_query_document(query: q::Document) -> QueryResult {\n }\n \n #[test]\n-#[cfg(any())]\n fn can_query_one_to_one_relationship() {\n     let result = execute_query_document(\n         graphql_parser::parse_query(\n@@ -381,7 +335,6 @@ fn can_query_one_to_one_relationship() {\n }\n \n #[test]\n-#[cfg(any())]\n fn can_query_one_to_many_relationships_in_both_directions() {\n     let result = execute_query_document(\n         graphql_parser::parse_query(\n@@ -476,7 +429,6 @@ fn can_query_one_to_many_relationships_in_both_directions() {\n }\n \n #[test]\n-#[cfg(any())]\n fn can_query_many_to_many_relationship() {\n     let result = execute_query_document(\n         graphql_parser::parse_query("
    },
    {
      "filename": "mock/src/block_stream.rs",
      "status": "added",
      "patch": "@@ -0,0 +1,53 @@\n+use futures::sync::mpsc::{channel, Receiver, Sender};\n+\n+use graph::prelude::*;\n+\n+pub struct MockBlockStream {\n+    chain_head_update_sink: Sender<ChainHeadUpdate>,\n+    _chain_head_update_stream: Receiver<ChainHeadUpdate>,\n+}\n+\n+impl MockBlockStream {\n+    fn new() -> Self {\n+        let (chain_head_update_sink, chain_head_update_stream) = channel(100);\n+\n+        Self {\n+            chain_head_update_sink,\n+            _chain_head_update_stream: chain_head_update_stream,\n+        }\n+    }\n+}\n+\n+impl Stream for MockBlockStream {\n+    type Item = EthereumBlock;\n+    type Error = Error;\n+\n+    fn poll(&mut self) -> Result<Async<Option<EthereumBlock>>, Error> {\n+        Ok(Async::Ready(None))\n+    }\n+}\n+\n+impl EventConsumer<ChainHeadUpdate> for MockBlockStream {\n+    fn event_sink(&self) -> Box<Sink<SinkItem = ChainHeadUpdate, SinkError = ()> + Send> {\n+        Box::new(self.chain_head_update_sink.clone().sink_map_err(|_| ()))\n+    }\n+}\n+\n+impl BlockStream for MockBlockStream {}\n+\n+#[derive(Clone)]\n+pub struct MockBlockStreamBuilder;\n+\n+impl MockBlockStreamBuilder {\n+    pub fn new() -> Self {\n+        Self {}\n+    }\n+}\n+\n+impl BlockStreamBuilder for MockBlockStreamBuilder {\n+    type Stream = MockBlockStream;\n+\n+    fn from_subgraph(&self, _manifest: &SubgraphManifest, _logger: Logger) -> Self::Stream {\n+        MockBlockStream::new()\n+    }\n+}"
    },
    {
      "filename": "mock/src/lib.rs",
      "status": "modified",
      "patch": "@@ -4,11 +4,13 @@ extern crate graph;\n extern crate graph_graphql;\n extern crate graphql_parser;\n \n+mod block_stream;\n mod graphql;\n mod server;\n mod store;\n mod subgraph;\n \n+pub use self::block_stream::{MockBlockStream, MockBlockStreamBuilder};\n pub use self::graphql::MockGraphQlRunner;\n pub use self::server::MockGraphQLServer;\n pub use self::store::{FakeStore, MockStore};"
    },
    {
      "filename": "mock/src/store.rs",
      "status": "modified",
      "patch": "@@ -47,14 +47,14 @@ impl MockStore {\n }\n \n impl Store for MockStore {\n-    fn get(&self, key: StoreKey) -> Result<Option<Entity>, QueryExecutionError> {\n-        if key.entity == \"User\" {\n+    fn get(&self, key: EntityKey) -> Result<Option<Entity>, QueryExecutionError> {\n+        if key.entity_type == \"User\" {\n             self.entities\n                 .iter()\n                 .find(|entity| {\n                     let id = entity.get(\"id\").unwrap();\n                     match *id {\n-                        Value::String(ref s) => s == &key.id,\n+                        Value::String(ref s) => s == &key.entity_id,\n                         _ => false,\n                     }\n                 }).map(|entity| Some(entity.clone()))\n@@ -64,7 +64,7 @@ impl Store for MockStore {\n         }\n     }\n \n-    fn find(&self, _query: StoreQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n+    fn find(&self, _query: EntityQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n         Ok(self.entities.clone())\n     }\n \n@@ -194,11 +194,11 @@ impl ChainStore for MockStore {\n pub struct FakeStore;\n \n impl Store for FakeStore {\n-    fn get(&self, _: StoreKey) -> Result<Option<Entity>, QueryExecutionError> {\n+    fn get(&self, _: EntityKey) -> Result<Option<Entity>, QueryExecutionError> {\n         unimplemented!();\n     }\n \n-    fn find(&self, _: StoreQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n+    fn find(&self, _: EntityQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n         unimplemented!();\n     }\n "
    },
    {
      "filename": "runtime/wasm/src/host_exports.rs",
      "status": "modified",
      "patch": "@@ -1,7 +1,7 @@\n use ethabi::Token;\n use futures::sync::oneshot;\n use graph::components::ethereum::*;\n-use graph::components::store::StoreKey;\n+use graph::components::store::EntityKey;\n use graph::data::store::scalar;\n use graph::data::subgraph::DataSource;\n use graph::prelude::*;\n@@ -95,27 +95,27 @@ where\n \n     pub(crate) fn store_set(\n         &mut self,\n-        entity: String,\n-        id: String,\n+        entity_type: String,\n+        entity_id: String,\n         mut data: HashMap<String, Value>,\n     ) -> Result<(), HostExportError<impl ExportError>> {\n         // Automatically add an \"id\" value\n-        match data.insert(\"id\".to_string(), Value::String(id.clone())) {\n-            Some(ref v) if v != &Value::String(id.clone()) => {\n+        match data.insert(\"id\".to_string(), Value::String(entity_id.clone())) {\n+            Some(ref v) if v != &Value::String(entity_id.clone()) => {\n                 return Err(HostExportError(format!(\n                     \"Conflicting 'id' value set by mapping for {} entity: {} != {}\",\n-                    entity, v, id,\n+                    entity_type, v, entity_id,\n                 )))\n             }\n             _ => (),\n         }\n \n         // Automatically add a \"__typename\" value\n-        match data.insert(\"__typename\".to_string(), Value::String(entity.clone())) {\n-            Some(ref v) if v != &Value::String(entity.clone()) => {\n+        match data.insert(\"__typename\".to_string(), Value::String(entity_type.clone())) {\n+            Some(ref v) if v != &Value::String(entity_type.clone()) => {\n                 return Err(HostExportError(format!(\n                     \"Conflicting '__typename' value set by mapping for {} entity: {} != {}\",\n-                    entity, v, entity\n+                    entity_type, v, entity_type\n                 )))\n             }\n             _ => (),\n@@ -126,36 +126,40 @@ where\n             .map(|ctx| &mut ctx.entity_operations)\n             .expect(\"processing event without context\")\n             .push(EntityOperation::Set {\n-                subgraph: self.subgraph.id.clone(),\n-                entity,\n-                id,\n+                key: EntityKey {\n+                    subgraph_id: self.subgraph.id.clone(),\n+                    entity_type,\n+                    entity_id,\n+                },\n                 data: Entity::from(data),\n             });\n \n         Ok(())\n     }\n \n-    pub(crate) fn store_remove(&mut self, entity: String, id: String) {\n+    pub(crate) fn store_remove(&mut self, entity_type: String, entity_id: String) {\n         self.ctx\n             .as_mut()\n             .map(|ctx| &mut ctx.entity_operations)\n             .expect(\"processing event without context\")\n             .push(EntityOperation::Remove {\n-                subgraph: self.subgraph.id.clone(),\n-                entity,\n-                id,\n+                key: EntityKey {\n+                    subgraph_id: self.subgraph.id.clone(),\n+                    entity_type,\n+                    entity_id,\n+                },\n             });\n     }\n \n     pub(crate) fn store_get(\n         &self,\n-        entity: String,\n-        id: String,\n+        entity_type: String,\n+        entity_id: String,\n     ) -> Result<Option<Entity>, HostExportError<impl ExportError>> {\n-        let store_key = StoreKey {\n-            subgraph: self.subgraph.id.clone(),\n-            entity,\n-            id,\n+        let store_key = EntityKey {\n+            subgraph_id: self.subgraph.id.clone(),\n+            entity_type,\n+            entity_id,\n         };\n \n         // Get all operations for this entity"
    },
    {
      "filename": "runtime/wasm/src/module/test.rs",
      "status": "modified",
      "patch": "@@ -7,22 +7,21 @@ extern crate parity_wasm;\n use self::graph_mock::FakeStore;\n use ethabi::{LogParam, Token};\n use failure::Error;\n-use futures::sync::mpsc::{channel, Receiver, Sender};\n+use futures::sync::mpsc::{channel, Sender};\n use graph::components::ethereum::*;\n use graph::components::store::*;\n use graph::components::subgraph::*;\n use graph::data::store::scalar;\n use graph::data::subgraph::*;\n use graph::util;\n-use graph::web3::types::{Address, H256, U256};\n+use graph::web3::types::{Bytes, *};\n use hex;\n use std::collections::HashMap;\n use std::io::Cursor;\n use std::iter::FromIterator;\n use std::str::FromStr;\n-use std::sync::Mutex;\n \n-use super::{Error as WasmiError, *};\n+use super::*;\n \n use self::graphql_parser::schema::Document;\n \n@@ -40,41 +39,41 @@ impl EthereumAdapter for MockEthereumAdapter {\n     fn block_by_hash(\n         &self,\n         _: &Logger,\n-        block_hash: H256,\n+        _: H256,\n     ) -> Box<Future<Item = Option<EthereumBlock>, Error = Error> + Send> {\n         unimplemented!();\n     }\n \n     fn block_hash_by_block_number(\n         &self,\n         _: &Logger,\n-        block_number: u64,\n+        _: u64,\n     ) -> Box<Future<Item = Option<H256>, Error = Error> + Send> {\n         unimplemented!();\n     }\n \n     fn is_on_main_chain(\n         &self,\n         _: &Logger,\n-        block_ptr: EthereumBlockPointer,\n+        _: EthereumBlockPointer,\n     ) -> Box<Future<Item = bool, Error = Error> + Send> {\n         unimplemented!();\n     }\n \n     fn find_first_blocks_with_logs(\n         &self,\n         _: &Logger,\n-        from: u64,\n-        to: u64,\n-        log_filter: EthereumLogFilter,\n+        _: u64,\n+        _: u64,\n+        _: EthereumLogFilter,\n     ) -> Box<Future<Item = Vec<EthereumBlockPointer>, Error = Error> + Send> {\n         unimplemented!();\n     }\n \n     fn contract_call(\n         &self,\n         _: &Logger,\n-        call: EthereumContractCall,\n+        _: EthereumContractCall,\n     ) -> Box<Future<Item = Vec<Token>, Error = EthereumContractCallError> + Send> {\n         unimplemented!();\n     }\n@@ -161,35 +160,93 @@ where\n     }\n }\n \n-#[cfg(any())]\n+/// Create mock Ethereum data\n+fn generate_fake_block() -> (EthereumBlock, Transaction, Log) {\n+    let block_hash = H256::random();\n+    let transaction = Transaction {\n+        hash: H256::random(),\n+        nonce: U256::zero(),\n+        block_hash: Some(block_hash),\n+        block_number: Some(5.into()),\n+        transaction_index: Some(0.into()),\n+        from: H160::random(),\n+        to: None,\n+        value: 0.into(),\n+        gas_price: 0.into(),\n+        gas: 0.into(),\n+        input: Bytes::default(),\n+    };\n+    let log = Log {\n+        address: Address::from(\"22843e74c59580b3eaf6c233fa67d8b7c561a835\"),\n+        topics: vec![util::ethereum::string_to_h256(\"ExampleEvent(string)\")],\n+        data: Bytes::default(),\n+        block_hash: Some(block_hash),\n+        block_number: Some(5.into()),\n+        transaction_hash: Some(transaction.hash),\n+        transaction_index: Some(0.into()),\n+        log_index: Some(0.into()),\n+        transaction_log_index: Some(0.into()),\n+        log_type: None,\n+        removed: None,\n+    };\n+    let block = EthereumBlock {\n+        block: Block {\n+            hash: Some(block_hash),\n+            parent_hash: H256::random(),\n+            uncles_hash: H256::zero(),\n+            author: H160::random(),\n+            state_root: H256::random(),\n+            transactions_root: H256::random(),\n+            receipts_root: H256::random(),\n+            number: Some(5.into()),\n+            gas_used: 0.into(),\n+            gas_limit: 0.into(),\n+            extra_data: Bytes::default(),\n+            logs_bloom: H2048::random(),\n+            timestamp: 42.into(),\n+            difficulty: 0.into(),\n+            total_difficulty: 0.into(),\n+            seal_fields: vec![],\n+            uncles: vec![],\n+            transactions: vec![transaction.clone()],\n+            size: None,\n+        },\n+        transaction_receipts: vec![],\n+    };\n+\n+    (block, transaction, log)\n+}\n+\n #[test]\n fn call_invalid_event_handler_and_dont_crash() {\n     // This test passing means the module doesn't crash when an invalid\n     // event handler is called or when the event handler execution fails.\n \n-    let (mut module, _) = test_module(mock_data_source(\"wasm_test/example_event_handler.wasm\"));\n+    let mut module = test_module(mock_data_source(\"wasm_test/example_event_handler.wasm\"));\n \n-    // Create a mock Ethereum event\n-    let ethereum_event = EthereumEvent {\n-        address: Address::from(\"22843e74c59580b3eaf6c233fa67d8b7c561a835\"),\n-        event_signature: util::ethereum::string_to_h256(\"ExampleEvent(string)\"),\n-        block_hash: util::ethereum::string_to_h256(\"example block hash\"),\n-        params: vec![LogParam {\n-            name: String::from(\"exampleParam\"),\n-            value: Token::String(String::from(\"some data\")),\n-        }],\n-        removed: false,\n+    let (block, transaction, log) = generate_fake_block();\n+\n+    let ctx = EventHandlerContext {\n+        logger: Logger::root(slog::Discard, o!()),\n+        block: Arc::new(block),\n+        transaction: Arc::new(transaction),\n+        entity_operations: vec![],\n     };\n \n-    // Call a non-existent event handler in the test module; if the test hasn't\n-    // crashed until now, it means it survives Ethereum event handler errors\n-    assert_eq!(\n-        module.handle_ethereum_event(\"handleNonExistentExampleEvent\", ethereum_event),\n-        ()\n+    // Call a non-existent event handler in the test module\n+    let _result = module.handle_ethereum_event(\n+        ctx,\n+        \"handleNonExistentExampleEvent\",\n+        Arc::new(log),\n+        vec![LogParam {\n+            name: \"exampleParam\".to_owned(),\n+            value: Token::String(\"some data\".to_owned()),\n+        }],\n     );\n+\n+    // If the test hasn't crashed, it means it survives Ethereum event handler errors\n }\n \n-#[cfg(any())]\n #[test]\n fn call_event_handler_and_receive_store_event() {\n     // Load the example_event_handler.wasm test module. All this module does\n@@ -199,47 +256,44 @@ fn call_event_handler_and_receive_store_event() {\n     // This test verifies that the event is delivered and the example data\n     // is returned to the RuntimeHostEvent stream.\n \n-    let (mut module, receiver) =\n-        test_module(mock_data_source(\"wasm_test/example_event_handler.wasm\"));\n+    let mut module = test_module(mock_data_source(\"wasm_test/example_event_handler.wasm\"));\n \n-    // Create a mock Ethereum event\n-    let ethereum_event = EthereumEvent {\n-        address: Address::from(\"22843e74c59580b3eaf6c233fa67d8b7c561a835\"),\n-        event_signature: util::ethereum::string_to_h256(\"ExampleEvent(string)\"),\n-        block_hash: util::ethereum::string_to_h256(\"example block hash\"),\n-        params: vec![LogParam {\n-            name: String::from(\"exampleParam\"),\n-            value: Token::String(String::from(\"some data\")),\n-        }],\n-        removed: false,\n+    let (block, transaction, log) = generate_fake_block();\n+\n+    let ctx = EventHandlerContext {\n+        logger: Logger::root(slog::Discard, o!()),\n+        block: Arc::new(block),\n+        transaction: Arc::new(transaction),\n+        entity_operations: vec![],\n     };\n \n     // Call the event handler in the test module and pass the event to it\n-    module.handle_ethereum_event(\"handleExampleEvent\", ethereum_event);\n-\n-    // Expect a store set call to be made by the handler and a\n-    // RuntimeHostEvent::EntitySet event to be written to the event stream\n-    let work = receiver.take(1).into_future();\n-    let store_event = work\n-        .wait()\n-        .expect(\"No store event received from runtime\")\n-        .0\n-        .expect(\"Store event must not be None\");\n-\n-    // Verify that this event matches what the test module is sending\n+    let result = module.handle_ethereum_event(\n+        ctx,\n+        \"handleExampleEvent\",\n+        Arc::new(log),\n+        vec![LogParam {\n+            name: \"exampleParam\".to_owned(),\n+            value: Token::String(\"some data\".to_owned()),\n+        }],\n+    );\n+\n     assert_eq!(\n-        store_event,\n-        RuntimeHostEvent::EntitySet(\n-            StoreKey {\n-                subgraph: String::from(\"example subgraph\"),\n-                entity: String::from(\"ExampleEntity\"),\n-                id: String::from(\"example id\"),\n+        result.unwrap(),\n+        vec![EntityOperation::Set {\n+            key: EntityKey {\n+                subgraph_id: \"example subgraph\".to_owned(),\n+                entity_type: \"ExampleEntity\".to_owned(),\n+                entity_id: \"example id\".to_owned(),\n             },\n-            Entity::from(HashMap::from_iter(\n-                vec![(String::from(\"exampleAttribute\"), Value::from(\"some data\"))].into_iter()\n+            data: Entity::from(HashMap::from_iter(\n+                vec![\n+                    (\"id\".to_owned(), \"example id\".into()),\n+                    (\"__typename\".to_owned(), \"ExampleEntity\".into()),\n+                    (\"exampleAttribute\".to_owned(), \"some data\".into()),\n+                ].into_iter()\n             )),\n-            EventSource::EthereumBlock(util::ethereum::string_to_h256(\"example block hash\",)),\n-        )\n+        }]\n     );\n }\n "
    },
    {
      "filename": "runtime/wasm/src/to_from/external.rs",
      "status": "modified",
      "patch": "@@ -1,10 +1,9 @@\n use ethabi;\n-use std::cmp;\n use std::collections::HashMap;\n \n use graph::components::ethereum::{EthereumBlockData, EthereumEventData, EthereumTransactionData};\n use graph::data::store;\n-use graph::prelude::{BigInt, BigIntSign};\n+use graph::prelude::BigInt;\n use graph::serde_json;\n use graph::web3::types as web3;\n "
    },
    {
      "filename": "store/postgres/migrations/2018-08-16-143800_create_entity_change_triggers/up.sql",
      "status": "modified",
      "patch": "@@ -11,9 +11,9 @@ $$\n DECLARE\n BEGIN\n     PERFORM pg_notify('entity_changes', json_build_object(\n-      'subgraph', NEW.subgraph,\n-      'entity', NEW.entity,\n-      'id', NEW.id,\n+      'subgraph_id', NEW.subgraph,\n+      'entity_type', NEW.entity,\n+      'entity_id', NEW.id,\n       'operation', 'added'\n     )::text);\n     RETURN NEW;\n@@ -33,9 +33,9 @@ $$\n DECLARE\n BEGIN\n     PERFORM pg_notify('entity_changes', json_build_object(\n-        'subgraph', NEW.subgraph,\n-        'entity', NEW.entity,\n-        'id', NEW.id,\n+        'subgraph_id', NEW.subgraph,\n+        'entity_type', NEW.entity,\n+        'entity_id', NEW.id,\n         'operation', 'updated'\n     )::text);\n     RETURN NEW;\n@@ -55,9 +55,9 @@ $$\n DECLARE\n BEGIN\n     PERFORM pg_notify('entity_changes', json_build_object(\n-        'subgraph', OLD.subgraph,\n-        'entity', OLD.entity,\n-        'id', OLD.id,\n+        'subgraph_id', OLD.subgraph,\n+        'entity_type', OLD.entity,\n+        'entity_id', OLD.id,\n         'operation', 'removed'\n     )::text);\n     RETURN NEW;"
    },
    {
      "filename": "store/postgres/src/filter.rs",
      "status": "modified",
      "patch": "@@ -10,7 +10,7 @@ use diesel::query_builder::{BoxedSelectStatement, QueryFragment};\n use diesel::sql_types::{Array, Bool, Float, Integer, Jsonb, Numeric, Text};\n use diesel::AppearsOnTable;\n \n-use graph::components::store::StoreFilter;\n+use graph::components::store::EntityFilter;\n use graph::data::store::*;\n use graph::serde_json;\n use models::SqlValue;\n@@ -28,7 +28,7 @@ enum FilterMode {\n /// Adds `filter` to a `SELECT data FROM entities` statement.\n pub(crate) fn store_filter(\n     query: BoxedSelectStatement<Jsonb, entities::table, Pg>,\n-    filter: StoreFilter,\n+    filter: EntityFilter,\n ) -> Result<BoxedSelectStatement<Jsonb, entities::table, Pg>, UnsupportedFilter> {\n     store_filter_by_mode(query, filter, FilterMode::And)\n }\n@@ -53,20 +53,20 @@ where\n /// Adds `filter` to a `SELECT data FROM entities` statement.\n fn store_filter_by_mode(\n     query: BoxedSelectStatement<Jsonb, entities::table, Pg>,\n-    filter: StoreFilter,\n+    filter: EntityFilter,\n     filter_mode: FilterMode,\n ) -> Result<BoxedSelectStatement<Jsonb, entities::table, Pg>, UnsupportedFilter> {\n     Ok(match filter {\n-        StoreFilter::And(filters) => filters\n+        EntityFilter::And(filters) => filters\n             .into_iter()\n             .try_fold(query, |q, f| store_filter_by_mode(q, f, FilterMode::And))?,\n-        StoreFilter::Or(filters) => filters\n+        EntityFilter::Or(filters) => filters\n             .into_iter()\n             .try_fold(query, |q, f| store_filter_by_mode(q, f, FilterMode::Or))?,\n-        StoreFilter::Contains(..) | StoreFilter::NotContains(..) => {\n+        EntityFilter::Contains(..) | EntityFilter::NotContains(..) => {\n             let (attribute, not, value) = match filter {\n-                StoreFilter::Contains(attribute, value) => (attribute, false, value),\n-                StoreFilter::NotContains(attribute, value) => (attribute, true, value),\n+                EntityFilter::Contains(attribute, value) => (attribute, false, value),\n+                EntityFilter::NotContains(attribute, value) => (attribute, true, value),\n                 _ => unreachable!(),\n             };\n             let op = if not { \" NOT LIKE \" } else { \" LIKE \" };\n@@ -115,10 +115,10 @@ fn store_filter_by_mode(\n                 }\n             }\n         }\n-        StoreFilter::Equal(..) | StoreFilter::Not(..) => {\n+        EntityFilter::Equal(..) | EntityFilter::Not(..) => {\n             let (attribute, op, value) = match filter {\n-                StoreFilter::Equal(attribute, value) => (attribute, \" = \", value),\n-                StoreFilter::Not(attribute, value) => (attribute, \" != \", value),\n+                EntityFilter::Equal(attribute, value) => (attribute, \" = \", value),\n+                EntityFilter::Not(attribute, value) => (attribute, \" != \", value),\n                 _ => unreachable!(),\n             };\n \n@@ -212,15 +212,15 @@ fn store_filter_by_mode(\n                 ),\n             }\n         }\n-        StoreFilter::GreaterThan(..)\n-        | StoreFilter::LessThan(..)\n-        | StoreFilter::GreaterOrEqual(..)\n-        | StoreFilter::LessOrEqual(..) => {\n+        EntityFilter::GreaterThan(..)\n+        | EntityFilter::LessThan(..)\n+        | EntityFilter::GreaterOrEqual(..)\n+        | EntityFilter::LessOrEqual(..) => {\n             let (attribute, op, value) = match filter {\n-                StoreFilter::GreaterThan(attribute, value) => (attribute, \" > \", value),\n-                StoreFilter::LessThan(attribute, value) => (attribute, \" < \", value),\n-                StoreFilter::GreaterOrEqual(attribute, value) => (attribute, \" >= \", value),\n-                StoreFilter::LessOrEqual(attribute, value) => (attribute, \" <= \", value),\n+                EntityFilter::GreaterThan(attribute, value) => (attribute, \" > \", value),\n+                EntityFilter::LessThan(attribute, value) => (attribute, \" < \", value),\n+                EntityFilter::GreaterOrEqual(attribute, value) => (attribute, \" >= \", value),\n+                EntityFilter::LessOrEqual(attribute, value) => (attribute, \" <= \", value),\n                 _ => unreachable!(),\n             };\n             match value {\n@@ -278,7 +278,7 @@ fn store_filter_by_mode(\n             }\n         }\n         // Is `attribute` equal to some `v` in `query_values`?\n-        StoreFilter::In(attribute, query_values) => {\n+        EntityFilter::In(attribute, query_values) => {\n             let op = \" = ANY (\";\n             if query_values.is_empty() {\n                 return Ok(add_filter(query, filter_mode, sql(\"false\")));\n@@ -352,18 +352,18 @@ fn store_filter_by_mode(\n             }\n         }\n         // Is `attribute` different from all `query_values`?\n-        StoreFilter::NotIn(attribute, query_values) => {\n+        EntityFilter::NotIn(attribute, query_values) => {\n             if query_values.is_empty() {\n                 return Ok(add_filter(query, filter_mode, sql(\"true\")));\n             }\n             query_values.into_iter().try_fold(query, |q, v| {\n-                store_filter_by_mode(q, StoreFilter::Not(attribute.clone(), v), FilterMode::And)\n+                store_filter_by_mode(q, EntityFilter::Not(attribute.clone(), v), FilterMode::And)\n             })?\n         }\n-        StoreFilter::StartsWith(..) | StoreFilter::NotStartsWith(..) => {\n+        EntityFilter::StartsWith(..) | EntityFilter::NotStartsWith(..) => {\n             let (attribute, op, value) = match filter {\n-                StoreFilter::StartsWith(attribute, value) => (attribute, \" LIKE \", value),\n-                StoreFilter::NotStartsWith(attribute, value) => (attribute, \" NOT LIKE \", value),\n+                EntityFilter::StartsWith(attribute, value) => (attribute, \" LIKE \", value),\n+                EntityFilter::NotStartsWith(attribute, value) => (attribute, \" NOT LIKE \", value),\n                 _ => unreachable!(),\n             };\n             match value {\n@@ -395,10 +395,10 @@ fn store_filter_by_mode(\n             }\n         }\n \n-        StoreFilter::EndsWith(..) | StoreFilter::NotEndsWith(..) => {\n+        EntityFilter::EndsWith(..) | EntityFilter::NotEndsWith(..) => {\n             let (attribute, op, value) = match filter {\n-                StoreFilter::EndsWith(attribute, value) => (attribute, \" LIKE \", value),\n-                StoreFilter::NotEndsWith(attribute, value) => (attribute, \" NOT LIKE \", value),\n+                EntityFilter::EndsWith(attribute, value) => (attribute, \" LIKE \", value),\n+                EntityFilter::NotEndsWith(attribute, value) => (attribute, \" NOT LIKE \", value),\n                 _ => unreachable!(),\n             };\n             match value {"
    },
    {
      "filename": "store/postgres/src/lib.rs",
      "status": "modified",
      "patch": "@@ -4,7 +4,6 @@ extern crate diesel;\n extern crate diesel_dynamic_schema;\n #[macro_use]\n extern crate diesel_migrations;\n-#[macro_use]\n extern crate failure;\n extern crate fallible_iterator;\n extern crate futures;"
    },
    {
      "filename": "store/postgres/src/store.rs",
      "status": "modified",
      "patch": "@@ -192,9 +192,9 @@ impl Store {\n \n         tokio::spawn(entity_changes.for_each(move |change| {\n             trace!(logger, \"Received entity change event\";\n-                           \"subgraph_id\" => &change.subgraph,\n-                           \"entity\" => &change.entity,\n-                           \"id\" => &change.id);\n+                           \"subgraph_id\" => &change.subgraph_id,\n+                           \"entity_type\" => &change.entity_type,\n+                           \"entity_id\" => &change.entity_id);\n \n             // Obtain IDs and senders of subscriptions matching the entity change\n             let matches = subscriptions\n@@ -204,7 +204,7 @@ impl Store {\n                 .filter(|(_, subscription)| {\n                     subscription\n                         .entities\n-                        .contains(&(change.subgraph.clone(), change.entity.clone()))\n+                        .contains(&(change.subgraph_id.clone(), change.entity_type.clone()))\n                 }).map(|(id, subscription)| (id.clone(), subscription.sender.clone()))\n                 .collect::<Vec<_>>();\n \n@@ -303,47 +303,52 @@ impl Store {\n     ) -> Result<usize, Error> {\n         use db_schema::entities::dsl::*;\n \n-        let (op_subgraph, op_entity, op_id) = operation.entity_info();\n+        let EntityKey {\n+            subgraph_id: op_subgraph_id,\n+            entity_type: op_entity_type,\n+            entity_id: op_entity_id,\n+        } = operation.entity_key();\n \n         // Load the entity if exists\n-        let existing_entity = self.get_entity(conn, op_subgraph, op_entity, op_id)?;\n+        let existing_entity =\n+            self.get_entity(conn, op_subgraph_id, op_entity_type, op_entity_id)?;\n \n         // Apply the operation\n         let updated_entity = operation.apply(existing_entity);\n         let updated_json: serde_json::Value =\n             serde_json::to_value(&updated_entity).map_err(|e| {\n                 format_err!(\n                     \"Failed to set entity ({}, {}, {}) as setting it would break it: {}\",\n-                    op_subgraph,\n-                    op_entity,\n-                    op_id,\n+                    op_subgraph_id,\n+                    op_entity_type,\n+                    op_entity_id,\n                     e\n                 )\n             })?;\n \n         // Either add or update the entity in Postgres\n         insert_into(entities)\n             .values((\n-                id.eq(op_id),\n-                entity.eq(op_entity),\n-                subgraph.eq(op_subgraph),\n+                id.eq(op_entity_id),\n+                entity.eq(op_entity_type),\n+                subgraph.eq(op_subgraph_id),\n                 data.eq(&updated_json),\n                 event_source.eq(block_ptr_to.hash_hex()),\n             )).on_conflict((id, entity, subgraph))\n             .do_update()\n             .set((\n-                id.eq(op_id),\n-                entity.eq(op_entity),\n-                subgraph.eq(op_subgraph),\n+                id.eq(op_entity_id),\n+                entity.eq(op_entity_type),\n+                subgraph.eq(op_subgraph_id),\n                 data.eq(&updated_json),\n                 event_source.eq(block_ptr_to.hash_hex()),\n             )).execute(conn)\n             .map_err(|e| {\n                 format_err!(\n                     \"Failed to set entity ({}, {}, {}): {}\",\n-                    op_subgraph,\n-                    op_entity,\n-                    op_id,\n+                    op_subgraph_id,\n+                    op_entity_type,\n+                    op_entity_id,\n                     e\n                 )\n             })\n@@ -358,7 +363,11 @@ impl Store {\n     ) -> Result<usize, Error> {\n         use db_schema::entities::dsl::*;\n \n-        let (op_subgraph, op_entity, op_id) = operation.entity_info();\n+        let EntityKey {\n+            subgraph_id: op_subgraph_id,\n+            entity_type: op_entity_type,\n+            entity_id: op_entity_id,\n+        } = operation.entity_key();\n \n         select(set_config(\n             \"vars.current_event_source\",\n@@ -370,16 +379,16 @@ impl Store {\n \n         delete(\n             entities\n-                .filter(subgraph.eq(op_subgraph))\n-                .filter(entity.eq(op_entity))\n-                .filter(id.eq(op_id)),\n+                .filter(subgraph.eq(op_subgraph_id))\n+                .filter(entity.eq(op_entity_type))\n+                .filter(id.eq(op_entity_id)),\n         ).execute(conn)\n         .map_err(|e| {\n             format_err!(\n                 \"Failed to remove entity ({}, {}, {}): {}\",\n-                op_subgraph,\n-                op_entity,\n-                op_id,\n+                op_subgraph_id,\n+                op_entity_type,\n+                op_entity_id,\n                 e\n             )\n         })\n@@ -580,19 +589,19 @@ impl StoreTrait for Store {\n             }).map_err(Error::from)\n     }\n \n-    fn get(&self, key: StoreKey) -> Result<Option<Entity>, QueryExecutionError> {\n+    fn get(&self, key: EntityKey) -> Result<Option<Entity>, QueryExecutionError> {\n         let conn = self.conn.lock().unwrap();\n-        self.get_entity(&*conn, &key.subgraph, &key.entity, &key.id)\n+        self.get_entity(&*conn, &key.subgraph_id, &key.entity_type, &key.entity_id)\n     }\n \n-    fn find(&self, query: StoreQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n+    fn find(&self, query: EntityQuery) -> Result<Vec<Entity>, QueryExecutionError> {\n         use db_schema::entities::dsl::*;\n \n         // Create base boxed query; this will be added to based on the\n         // query parameters provided\n         let mut diesel_query = entities\n-            .filter(entity.eq(query.entity))\n-            .filter(subgraph.eq(query.subgraph))\n+            .filter(entity.eq(query.entity_type))\n+            .filter(subgraph.eq(query.subgraph_id))\n             .select(data)\n             .into_boxed::<Pg>();\n \n@@ -608,8 +617,8 @@ impl StoreTrait for Store {\n             let direction = query\n                 .order_direction\n                 .map(|direction| match direction {\n-                    StoreOrder::Ascending => \"ASC\",\n-                    StoreOrder::Descending => \"DESC\",\n+                    EntityOrder::Ascending => \"ASC\",\n+                    EntityOrder::Descending => \"DESC\",\n                 }).unwrap_or(\"ASC\");\n             let cast_type = match value_type {\n                 ValueType::BigInt => \"::numeric\",\n@@ -641,8 +650,7 @@ impl StoreTrait for Store {\n                 values\n                     .into_iter()\n                     .map(|value| {\n-                        serde_json::from_value::<Entity>(value)\n-                            .expect(\"Error to deserialize entity\")\n+                        serde_json::from_value::<Entity>(value).expect(\"Error parsing entity JSON\")\n                     }).collect()\n             }).map_err(|e| QueryExecutionError::ResolveEntitiesError(e.to_string()))\n     }\n@@ -664,6 +672,11 @@ impl StoreTrait for Store {\n         block_ptr_to: EthereumBlockPointer,\n         operations: Vec<EntityOperation>,\n     ) -> Result<(), Error> {\n+        // Sanity check on block numbers\n+        if block_ptr_from.number != block_ptr_to.number - 1 {\n+            panic!(\"transact_block_operations must transact a single block only\");\n+        }\n+\n         // Fold the operations of each entity into a single one\n         let operations = EntityOperation::fold(&operations);\n "
    },
    {
      "filename": "store/postgres/tests/store.rs",
      "status": "modified",
      "patch": "@@ -9,14 +9,10 @@ extern crate hex;\n use diesel::pg::PgConnection;\n use diesel::*;\n use std::fmt::Debug;\n-use std::mem;\n-use std::panic;\n use std::str::FromStr;\n use std::sync::Mutex;\n \n-use graph::components::store::{\n-    EventSource, StoreFilter, StoreKey, StoreOrder, StoreQuery, StoreRange,\n-};\n+use graph::components::store::{EntityFilter, EntityKey, EntityOrder, EntityQuery, EntityRange};\n use graph::data::store::scalar;\n use graph::prelude::*;\n use graph::web3::types::H256;\n@@ -32,11 +28,51 @@ fn postgres_test_url() -> String {\n \n lazy_static! {\n     static ref TEST_MUTEX: Mutex<()> = Mutex::new(());\n+    static ref TEST_SUBGRAPH_ID: SubgraphId = \"test_subgraph\".to_owned();\n+    static ref TEST_BLOCK_0_PTR: EthereumBlockPointer = (\n+        H256::from(\"0xbd34884280958002c51d3f7b5f853e6febeba33de0f40d15b0363006533c924f\"),\n+        0u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_1_PTR: EthereumBlockPointer = (\n+        H256::from(\"0x8511fa04b64657581e3f00e14543c1d522d5d7e771b54aa3060b662ade47da13\"),\n+        1u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_2_PTR: EthereumBlockPointer = (\n+        H256::from(\"0xb98fb783b49de5652097a989414c767824dff7e7fd765a63b493772511db81c1\"),\n+        2u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_3_PTR: EthereumBlockPointer = (\n+        H256::from(\"0x977c084229c72a0fa377cae304eda9099b6a2cb5d83b25cdf0f0969b69874255\"),\n+        3u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_3A_PTR: EthereumBlockPointer = (\n+        H256::from(\"0xd163aec0592c7cb00c2700ab65dcaac93289f5d250b3b889b39198b07e1fbe4a\"),\n+        3u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_4_PTR: EthereumBlockPointer = (\n+        H256::from(\"0x007a03cdf635ebb66f5e79ae66cc90ca23d98031665649db056ff9c6aac2d74d\"),\n+        4u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_4A_PTR: EthereumBlockPointer = (\n+        H256::from(\"0x8fab27e9e9285b0a39110f4d9877f05d0f43d2effa157e55f4dcc49c3cf8cbd7\"),\n+        4u64\n+    )\n+        .into();\n+    static ref TEST_BLOCK_5_PTR: EthereumBlockPointer = (\n+        H256::from(\"0xe8b3b02b936c4a4a331ac691ac9a86e197fb7731f14e3108602c87d4dac55160\"),\n+        5u64\n+    )\n+        .into();\n }\n \n /// Test harness for running database integration tests.\n-#[cfg(any())]\n-fn run_test<R, F>(test: F) -> ()\n+fn run_test<R, F>(test: F)\n where\n     F: FnOnce(Arc<DieselStore>) -> R + Send + 'static,\n     R: IntoFuture + Send + 'static,\n@@ -50,288 +86,299 @@ where\n         Err(err) => err.into_inner(),\n     };\n \n-    // Set up Store\n-    let logger = Logger::root(slog::Discard, o!());\n-    let url = postgres_test_url();\n-    let net_identifiers = EthereumNetworkIdentifier {\n-        net_version: \"graph test suite\".to_owned(),\n-        genesis_block_hash: H256::random(),\n-    };\n-    let network_name = \"fake_network\".to_owned();\n-    let store = Arc::new(DieselStore::new(\n-        StoreConfig { url, network_name },\n-        &logger,\n-        net_identifiers,\n-    ));\n-\n     let mut runtime = tokio::runtime::Runtime::new().unwrap();\n-\n     runtime\n         .block_on(future::lazy(move || {\n-            insert_test_data(store.clone());\n-            future::ok::<_, ()>(())\n-        })).expect(\"Failed to insert test data\");\n-\n-    let result = panic::catch_unwind(panic::AssertUnwindSafe(move || {\n-        runtime.block_on(future::lazy(move || test(store.clone())))\n-    }));\n-\n-    mem::drop(store);\n-\n-    runtime\n-        .block_on(future::lazy(|| {\n+            // Set up Store\n+            let logger = Logger::root(slog::Discard, o!());\n+            let url = postgres_test_url();\n+            let net_identifiers = EthereumNetworkIdentifier {\n+                net_version: \"graph test suite\".to_owned(),\n+                genesis_block_hash: TEST_BLOCK_0_PTR.hash,\n+            };\n+            let network_name = \"fake_network\".to_owned();\n+            let store = Arc::new(DieselStore::new(\n+                StoreConfig { url, network_name },\n+                &logger,\n+                net_identifiers,\n+            ));\n+\n+            // Reset state before starting\n             remove_test_data();\n-            future::ok::<_, ()>(())\n-        })).expect(\"Failed to remove test data\");\n \n-    result.expect(\"Failed to run test\").expect(\"Test failed\");\n-}\n+            // Seed database with test data\n+            insert_test_data(store.clone());\n \n-/// Creates a test entity.\n-fn create_test_entity(\n-    id: String,\n-    entity: String,\n-    name: String,\n-    email: String,\n-    age: i32,\n-    weight: f32,\n-    coffee: bool,\n-    block_hash: String,\n-) -> (StoreKey, Entity, EventSource) {\n-    let test_key = StoreKey {\n-        subgraph: String::from(\"test_subgraph\"),\n-        entity: entity,\n-        id: id,\n-    };\n-    let mut test_entity = Entity::new();\n-    let hex_name = scalar::Bytes::from_str(&hex::encode(&name)).unwrap();\n-    test_entity.insert(String::from(\"name\"), Value::String(name));\n-    test_entity.insert(String::from(\"hex_name\"), Value::Bytes(hex_name));\n-    test_entity.insert(String::from(\"email\"), Value::String(email));\n-    test_entity.insert(String::from(\"age\"), Value::Int(age));\n-    test_entity.insert(String::from(\"weight\"), Value::Float(weight));\n-    test_entity.insert(String::from(\"coffee\"), Value::Bool(coffee));\n-    (\n-        test_key,\n-        test_entity,\n-        EventSource::EthereumBlock(H256::from_slice(&block_hash.as_bytes())),\n-    )\n+            // Run test\n+            test(store.clone())\n+        })).expect(\"Failed to run Store test\");\n }\n \n /// Inserts test data into the store.\n-#[cfg(any())]\n+///\n+/// Inserts data in test blocks 1, 2, and 3, leaving test blocks 3A, 4, and 4A for the tests to\n+/// use.\n fn insert_test_data(store: Arc<DieselStore>) {\n+    store\n+        .add_subgraph_if_missing(TEST_SUBGRAPH_ID.clone(), *TEST_BLOCK_0_PTR)\n+        .unwrap();\n+\n     let test_entity_1 = create_test_entity(\n-        String::from(\"1\"),\n-        String::from(\"user\"),\n-        String::from(\"Johnton\"),\n-        String::from(\"tonofjohn@email.com\"),\n+        \"1\",\n+        \"user\",\n+        \"Johnton\",\n+        \"tonofjohn@email.com\",\n         67 as i32,\n         184.4 as f32,\n         false,\n-        String::from(\"1cYsEjD7LKVExSj0aFA8\"),\n     );\n     store\n-        .set(test_entity_1.0, test_entity_1.1, test_entity_1.2)\n-        .expect(\"Failed to insert test entity into the store\");\n+        .transact_block_operations(\n+            TEST_SUBGRAPH_ID.clone(),\n+            *TEST_BLOCK_0_PTR,\n+            *TEST_BLOCK_1_PTR,\n+            vec![test_entity_1],\n+        ).unwrap();\n \n     let test_entity_2 = create_test_entity(\n-        String::from(\"2\"),\n-        String::from(\"user\"),\n-        String::from(\"Cindini\"),\n-        String::from(\"dinici@email.com\"),\n+        \"2\",\n+        \"user\",\n+        \"Cindini\",\n+        \"dinici@email.com\",\n         43 as i32,\n         159.1 as f32,\n         true,\n-        String::from(\"b7kJ8ghP6PSITWx4lUZB\"),\n     );\n-    store\n-        .set(test_entity_2.0, test_entity_2.1, test_entity_2.2)\n-        .expect(\"Failed to insert test entity into the store\");\n-\n-    let test_entity_3 = create_test_entity(\n-        String::from(\"3\"),\n-        String::from(\"user\"),\n-        String::from(\"Shaqueeena\"),\n-        String::from(\"queensha@email.com\"),\n+    let test_entity_3_1 = create_test_entity(\n+        \"3\",\n+        \"user\",\n+        \"Shaqueeena\",\n+        \"queensha@email.com\",\n         28 as i32,\n         111.7 as f32,\n         false,\n-        String::from(\"TA7xjCbrczBiGFuZAW9Q\"),\n     );\n     store\n-        .set(test_entity_3.0, test_entity_3.1, test_entity_3.2)\n-        .expect(\"Failed to insert test entity into the store\");\n+        .transact_block_operations(\n+            TEST_SUBGRAPH_ID.clone(),\n+            *TEST_BLOCK_1_PTR,\n+            *TEST_BLOCK_2_PTR,\n+            vec![test_entity_2, test_entity_3_1],\n+        ).unwrap();\n \n     let test_entity_3_2 = create_test_entity(\n-        String::from(\"3\"),\n-        String::from(\"user\"),\n-        String::from(\"Shaqueeena\"),\n-        String::from(\"teeko@email.com\"),\n+        \"3\",\n+        \"user\",\n+        \"Shaqueeena\",\n+        \"teeko@email.com\",\n         28 as i32,\n         111.7 as f32,\n         false,\n-        String::from(\"znuyjijnezBiGFuZAW9Q\"),\n     );\n-\n     store\n-        .set(test_entity_3_2.0, test_entity_3_2.1, test_entity_3_2.2)\n-        .expect(\"Failed to insert test entity into the store\");\n+        .transact_block_operations(\n+            TEST_SUBGRAPH_ID.clone(),\n+            *TEST_BLOCK_2_PTR,\n+            *TEST_BLOCK_3_PTR,\n+            vec![test_entity_3_2],\n+        ).unwrap();\n+}\n+\n+/// Creates a test entity.\n+fn create_test_entity(\n+    id: &str,\n+    entity_type: &str,\n+    name: &str,\n+    email: &str,\n+    age: i32,\n+    weight: f32,\n+    coffee: bool,\n+) -> EntityOperation {\n+    let mut test_entity = Entity::new();\n+\n+    test_entity.insert(\"id\".to_owned(), Value::String(id.to_owned()));\n+    test_entity.insert(\"name\".to_owned(), Value::String(name.to_owned()));\n+    let bin_name = scalar::Bytes::from_str(&hex::encode(name)).unwrap();\n+    test_entity.insert(\"bin_name\".to_owned(), Value::Bytes(bin_name));\n+    test_entity.insert(\"email\".to_owned(), Value::String(email.to_owned()));\n+    test_entity.insert(\"age\".to_owned(), Value::Int(age));\n+    test_entity.insert(\"weight\".to_owned(), Value::Float(weight));\n+    test_entity.insert(\"coffee\".to_owned(), Value::Bool(coffee));\n+\n+    EntityOperation::Set {\n+        key: EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: entity_type.to_owned(),\n+            entity_id: id.to_owned(),\n+        },\n+        data: test_entity,\n+    }\n }\n \n /// Removes test data from the database behind the store.\n fn remove_test_data() {\n     use db_schema::entities::dsl::*;\n+    use db_schema::subgraphs::dsl::*;\n+\n     let url = postgres_test_url();\n     let conn = PgConnection::establish(url.as_str()).expect(\"Failed to connect to Postgres\");\n     delete(entities)\n         .execute(&conn)\n-        .expect(\"Failed to remove test data\");\n+        .expect(\"Failed to remove entity test data\");\n+    delete(subgraphs)\n+        .execute(&conn)\n+        .expect(\"Failed to remove subgraph test data\");\n }\n \n #[test]\n-#[cfg(any())]\n fn delete_entity() {\n     run_test(|store| -> Result<(), ()> {\n         use db_schema::entities::dsl::*;\n \n-        let test_key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"3\"),\n-        };\n-        let source = EventSource::EthereumBlock(H256::random());\n-        store.delete(test_key, source).unwrap();\n+        store\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![EntityOperation::Remove {\n+                    key: EntityKey {\n+                        subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+                        entity_type: \"user\".to_owned(),\n+                        entity_id: \"3\".to_owned(),\n+                    },\n+                }],\n+            ).unwrap();\n \n-        //Get all ids in table\n+        // Get all ids in table\n         let all_ids = entities\n             .select(id)\n             .load::<String>(&*store.conn.lock().unwrap())\n             .unwrap();\n \n         // Check that that the deleted entity id is not present\n-        assert!(!all_ids.contains(&String::from(\"3\")));\n+        assert!(!all_ids.contains(&\"3\".to_owned()));\n \n         Ok(())\n     })\n }\n \n #[test]\n-#[cfg(any())]\n fn get_entity() {\n     run_test(|store| -> Result<(), ()> {\n-        let key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"1\"),\n+        let key = EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            entity_id: \"1\".to_owned(),\n         };\n         let result = store.get(key).unwrap();\n \n         let mut expected_entity = Entity::new();\n \n-        let name = \"Johnton\".to_owned();\n-        let hex_name = format!(\"0x{}\", hex::encode(&name));\n-        expected_entity.insert(String::from(\"hex_name\"), Value::String(hex_name));\n-        expected_entity.insert(String::from(\"name\"), Value::String(name));\n+        expected_entity.insert(\"id\".to_owned(), \"1\".into());\n+        expected_entity.insert(\"name\".to_owned(), \"Johnton\".into());\n         expected_entity.insert(\n-            String::from(\"email\"),\n-            Value::String(String::from(\"tonofjohn@email.com\")),\n+            \"bin_name\".to_owned(),\n+            Value::Bytes(\"Johnton\".as_bytes().into()),\n         );\n-        expected_entity.insert(String::from(\"age\"), Value::Int(67 as i32));\n-        expected_entity.insert(String::from(\"weight\"), Value::Float(184.4 as f32));\n-        expected_entity.insert(String::from(\"coffee\"), Value::Bool(false));\n+        expected_entity.insert(\"email\".to_owned(), \"tonofjohn@email.com\".into());\n+        expected_entity.insert(\"age\".to_owned(), Value::Int(67 as i32));\n+        expected_entity.insert(\"weight\".to_owned(), Value::Float(184.4 as f32));\n+        expected_entity.insert(\"coffee\".to_owned(), Value::Bool(false));\n \n         // Check that the expected entity was returned\n-        assert_eq!(result, expected_entity);\n+        assert_eq!(result, Some(expected_entity));\n \n         Ok(())\n     })\n }\n \n #[test]\n-#[cfg(any())]\n fn insert_entity() {\n     run_test(|store| -> Result<(), ()> {\n         use db_schema::entities::dsl::*;\n \n-        let test_entity_1 = create_test_entity(\n-            String::from(\"7\"),\n-            String::from(\"user\"),\n-            String::from(\"Wanjon\"),\n-            String::from(\"wanawana@email.com\"),\n+        let test_entity = create_test_entity(\n+            \"7\",\n+            \"user\",\n+            \"Wanjon\",\n+            \"wanawana@email.com\",\n             76 as i32,\n             111.7 as f32,\n             true,\n-            String::from(\"MSjZmOE7UqBOzzYibsw9\"),\n         );\n         store\n-            .set(test_entity_1.0, test_entity_1.1, test_entity_1.2)\n-            .expect(\"Failed to set entity in the store\");\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![test_entity],\n+            ).unwrap();\n \n         // Check that new record is in the store\n         let all_ids = entities\n             .select(id)\n             .load::<String>(&*store.conn.lock().unwrap())\n             .unwrap();\n-        assert!(all_ids.iter().any(|x| x == &String::from(\"7\")));\n+        assert!(all_ids.iter().any(|x| x == &\"7\".to_owned()));\n \n         Ok(())\n     })\n }\n \n #[test]\n-#[cfg(any())]\n fn update_existing() {\n     run_test(|store| -> Result<(), ()> {\n-        let entity_key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"1\"),\n+        let entity_key = EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            entity_id: \"1\".to_owned(),\n         };\n \n-        let mut test_entity_1 = create_test_entity(\n-            String::from(\"1\"),\n-            String::from(\"user\"),\n-            String::from(\"Wanjon\"),\n-            String::from(\"wanawana@email.com\"),\n+        let op = create_test_entity(\n+            \"1\",\n+            \"user\",\n+            \"Wanjon\",\n+            \"wanawana@email.com\",\n             76 as i32,\n             111.7 as f32,\n             true,\n-            String::from(\"6SFIlpqNoDy6FfJQryNM\"),\n         );\n+        let mut new_data = match op {\n+            EntityOperation::Set { ref data, .. } => data.clone(),\n+            _ => unreachable!(),\n+        };\n \n         // Verify that the entity before updating is different from what we expect afterwards\n-        assert_ne!(store.get(entity_key.clone()).unwrap(), test_entity_1.1);\n+        assert_ne!(store.get(entity_key.clone()).unwrap().unwrap(), new_data);\n \n         // Set test entity; as the entity already exists an update should be performed\n         store\n-            .set(test_entity_1.0, test_entity_1.1.clone(), test_entity_1.2)\n-            .expect(\"Failed to update entity that already exists\");\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![op],\n+            ).unwrap();\n \n         // Verify that the entity in the store has changed to what we have set.\n-        // The `hex_name` will be returned as a `Value::String`.\n-        let hex_name = match test_entity_1.1.get(\"hex_name\") {\n+        let bin_name = match new_data.get(\"bin_name\") {\n             Some(Value::Bytes(bytes)) => bytes.clone(),\n             _ => unreachable!(),\n         };\n-        test_entity_1.1.insert(\n-            String::from(\"hex_name\"),\n-            Value::String(hex_name.to_string()),\n-        );\n-        assert_eq!(store.get(entity_key).unwrap(), test_entity_1.1);\n+        new_data.insert(\"bin_name\".to_owned(), Value::Bytes(bin_name));\n+        assert_eq!(store.get(entity_key).unwrap(), Some(new_data));\n \n         Ok(())\n     })\n }\n \n #[test]\n-#[cfg(any())]\n fn partially_update_existing() {\n     run_test(|store| -> Result<(), ()> {\n-        let entity_key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"1\"),\n+        let entity_key = EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            entity_id: \"1\".to_owned(),\n         };\n \n         let partial_entity = Entity::from(vec![\n@@ -340,18 +387,25 @@ fn partially_update_existing() {\n             (\"email\", Value::Null),\n         ]);\n \n-        let original_entity = store.get(entity_key.clone()).unwrap();\n-        let event_source = EventSource::EthereumBlock(H256::random());\n-        // Verify that the entity before updating is different from what we expect afterwards\n-        assert_ne!(original_entity, partial_entity);\n+        let original_entity = store\n+            .get(entity_key.clone())\n+            .unwrap()\n+            .expect(\"entity not found\");\n \n         // Set test entity; as the entity already exists an update should be performed\n         store\n-            .set(entity_key.clone(), partial_entity.clone(), event_source)\n-            .expect(\"Failed to update entity that already exists\");\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![EntityOperation::Set {\n+                    key: entity_key.clone(),\n+                    data: partial_entity.clone(),\n+                }],\n+            ).unwrap();\n \n         // Obtain the updated entity from the store\n-        let updated_entity = store.get(entity_key).unwrap();\n+        let updated_entity = store.get(entity_key).unwrap().expect(\"entity not found\");\n \n         // Verify that the values of all attributes we have set were either unset\n         // (in the case of Value::Null) or updated to the new values\n@@ -368,1108 +422,698 @@ fn partially_update_existing() {\n     })\n }\n \n-#[test]\n-#[cfg(any())]\n-fn find_string_contains() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Contains(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"%ind%\")),\n-            )])),\n-            order_by: None,\n-            order_direction: None,\n-            range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n+fn test_find(expected_entity_ids: Vec<&str>, query: EntityQuery) {\n+    let expected_entity_ids: Vec<String> =\n+        expected_entity_ids.into_iter().map(str::to_owned).collect();\n+\n+    run_test(move |store| -> Result<(), ()> {\n+        let entities = store\n+            .find(query)\n+            .expect(\"store.find failed to execute query\");\n+\n+        let entity_ids: Vec<_> = entities\n+            .into_iter()\n+            .map(|entity| match entity.get(\"id\") {\n+                Some(Value::String(id)) => id.to_owned(),\n+                Some(_) => panic!(\"store.find returned entity with non-string ID attribute\"),\n+                None => panic!(\"store.find returned entity with no ID attribute\"),\n+            }).collect();\n \n-        // Make sure the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert_eq!(&test_value, returned_name.unwrap());\n+        assert_eq!(entity_ids, expected_entity_ids);\n \n         Ok(())\n     })\n }\n \n #[test]\n-#[cfg(any())]\n-fn find_string_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Cindini\")),\n+fn find_string_contains() {\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Contains(\n+                \"name\".into(),\n+                \"%ind%\".into(),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Make sure the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n-fn find_string_not_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Not(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Cindini\")),\n+fn find_string_equal() {\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"name\".to_owned(),\n+                \"Cindini\".into(),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"; fail if it is\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_ne!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n-fn find_string_greater_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::GreaterThan(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Kundi\")),\n+fn find_string_not_equal() {\n+    test_find(\n+        vec![\"1\", \"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Not(\n+                \"name\".to_owned(),\n+                \"Cindini\".into(),\n             )])),\n-            order_by: None,\n-            order_direction: None,\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"; fail if it is\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_ne!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n-fn find_string_less_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Kundi\")),\n+fn find_string_greater_than() {\n+    test_find(\n+        vec![\"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::GreaterThan(\n+                \"name\".to_owned(),\n+                \"Kundi\".into(),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"; fail if it is\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_ne!(&test_value, returned_name.unwrap());\n-\n-        //There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_less_than_order_by_asc() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Kundi\")),\n+    test_find(\n+        vec![\"2\", \"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"name\".to_owned(),\n+                \"Kundi\".into(),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let result = store\n-            .find(this_query)\n-            .expect(\"Failed to fetch entities from the store\");\n-\n-        // Check that the number and order of users is correct\n-        assert_eq!(2, result.len());\n-        let names: Vec<&Value> = result\n-            .iter()\n-            .map(|entity| {\n-                entity\n-                    .get(&String::from(\"name\"))\n-                    .expect(\"Entity without \\\"name\\\" attribute returned\")\n-            }).collect();\n-        assert_eq!(\n-            names,\n-            vec![\n-                &Value::String(String::from(\"Cindini\")),\n-                &Value::String(String::from(\"Johnton\")),\n-            ]\n-        );\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_less_than_order_by_desc() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Kundi\")),\n+    test_find(\n+        vec![\"1\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"name\".to_owned(),\n+                \"Kundi\".into(),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let result = store\n-            .find(this_query)\n-            .expect(\"Failed to fetch entities from the store\");\n-\n-        // Check that the number and order of users is correct\n-        assert_eq!(2, result.len());\n-        let names: Vec<&Value> = result\n-            .iter()\n-            .map(|entity| {\n-                entity\n-                    .get(&String::from(\"name\"))\n-                    .expect(\"Entity without \\\"name\\\" attribute returned\")\n-            }).collect();\n-        assert_eq!(\n-            names,\n-            vec![\n-                &Value::String(String::from(\"Johnton\")),\n-                &Value::String(String::from(\"Cindini\")),\n-            ]\n-        );\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_less_than_range() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"ZZZ\")),\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"name\".to_owned(),\n+                \"ZZZ\".into(),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 1, skip: 1 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 1, skip: 1 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_multiple_and() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![\n-                StoreFilter::LessThan(String::from(\"name\"), Value::String(String::from(\"Cz\"))),\n-                StoreFilter::Equal(String::from(\"name\"), Value::String(String::from(\"Cindini\"))),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![\n+                EntityFilter::LessThan(\"name\".to_owned(), \"Cz\".into()),\n+                EntityFilter::Equal(\"name\".to_owned(), \"Cindini\".into()),\n             ])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_ends_with() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::EndsWith(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"ini\")),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::EndsWith(\n+                \"name\".to_owned(),\n+                \"ini\".into(),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_not_ends_with() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::NotEndsWith(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"ini\")),\n+    test_find(\n+        vec![\"3\", \"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::NotEndsWith(\n+                \"name\".to_owned(),\n+                \"ini\".into(),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::In(\n-                String::from(\"name\"),\n-                vec![Value::String(String::from(\"Johnton\"))],\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::In(\n+                \"name\".to_owned(),\n+                vec![\"Johnton\".into()],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_string_not_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::NotIn(\n-                String::from(\"name\"),\n-                vec![Value::String(String::from(\"Shaqueeena\"))],\n+    test_find(\n+        vec![\"1\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::NotIn(\n+                \"name\".to_owned(),\n+                vec![\"Shaqueeena\".into()],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 user returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"weight\".to_owned(),\n                 Value::Float(184.4 as f32),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_not_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Not(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"3\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Not(\n+                \"weight\".to_owned(),\n                 Value::Float(184.4 as f32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_greater_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::GreaterThan(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::GreaterThan(\n+                \"weight\".to_owned(),\n                 Value::Float(160 as f32),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_less_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"2\", \"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"weight\".to_owned(),\n                 Value::Float(160 as f32),\n             )])),\n-            order_by: Some((String::From(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\";\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_less_than_order_by_desc() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"3\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"weight\".to_owned(),\n                 Value::Float(160 as f32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_less_than_range() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"weight\".to_owned(),\n                 Value::Float(161 as f32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 1, skip: 1 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 1, skip: 1 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::In(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"3\", \"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::In(\n+                \"weight\".to_owned(),\n                 vec![Value::Float(184.4 as f32), Value::Float(111.7 as f32)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_float_not_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::NotIn(\n-                String::from(\"weight\"),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::NotIn(\n+                \"weight\".to_owned(),\n                 vec![Value::Float(184.4 as f32), Value::Float(111.7 as f32)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 users returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"age\".to_owned(),\n                 Value::Int(67 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 users returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_not_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Not(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"3\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Not(\n+                \"age\".to_owned(),\n                 Value::Int(67 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_greater_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::GreaterThan(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::GreaterThan(\n+                \"age\".to_owned(),\n                 Value::Int(43 as i32),\n             )])),\n             order_by: None,\n             order_direction: None,\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_greater_or_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::GreaterOrEqual(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"2\", \"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::GreaterOrEqual(\n+                \"age\".to_owned(),\n                 Value::Int(43 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_less_than() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"2\", \"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"age\".to_owned(),\n                 Value::Int(50 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        //There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_less_or_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessOrEqual(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"2\", \"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessOrEqual(\n+                \"age\".to_owned(),\n                 Value::Int(43 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\";\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_less_than_order_by_desc() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"3\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"age\".to_owned(),\n                 Value::Int(50 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_less_than_range() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::LessThan(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::LessThan(\n+                \"age\".to_owned(),\n                 Value::Int(67 as i32),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 1, skip: 1 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 1, skip: 1 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::In(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"1\", \"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::In(\n+                \"age\".to_owned(),\n                 vec![Value::Int(67 as i32), Value::Int(43 as i32)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_int_not_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::NotIn(\n-                String::from(\"age\"),\n+    test_find(\n+        vec![\"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::NotIn(\n+                \"age\".to_owned(),\n                 vec![Value::Int(67 as i32), Value::Int(43 as i32)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 users returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n }\n \n+// Disabled due to issue #565\n #[test]\n-#[cfg(any())]\n+#[ignore]\n fn find_bool_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"coffee\"),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"coffee\".to_owned(),\n                 Value::Bool(true),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n+// Disabled due to issue #565\n #[test]\n-#[cfg(any())]\n+#[ignore]\n fn find_bool_not_equal() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Not(\n-                String::from(\"coffee\"),\n+    test_find(\n+        vec![\"1\", \"3\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Not(\n+                \"coffee\".to_owned(),\n                 Value::Bool(true),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Ascending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Ascending),\n             range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find query failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n-\n-        Ok(())\n-    })\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn find_bool_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::In(\n-                String::from(\"coffee\"),\n+    test_find(\n+        vec![\"2\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::In(\n+                \"coffee\".to_owned(),\n                 vec![Value::Bool(true)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Cindini\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Cindini\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 user returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n }\n \n+// Disabled due to issue #565\n #[test]\n-#[cfg(any())]\n+#[ignore]\n fn find_bool_not_in() {\n-    run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::NotIn(\n-                String::from(\"coffee\"),\n+    test_find(\n+        vec![\"3\", \"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::NotIn(\n+                \"coffee\".to_owned(),\n                 vec![Value::Bool(true)],\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: Some(StoreRange { first: 5, skip: 0 }),\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Shaqueeena\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Shaqueeena\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 2 users returned in results\n-        assert_eq!(2, returned_entities.len());\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: Some(EntityRange { first: 5, skip: 0 }),\n+        },\n+    )\n+}\n \n-        Ok(())\n-    })\n+#[test]\n+fn find_bytes_equal() {\n+    test_find(\n+        vec![\"1\"],\n+        EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"bin_name\".to_owned(),\n+                Value::Bytes(\"Johnton\".as_bytes().into()),\n+            )])),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n+            range: None,\n+        },\n+    )\n }\n \n #[test]\n-#[cfg(any())]\n fn revert_block() {\n     run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Shaqueeena\")),\n+        let this_query = EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"name\".to_owned(),\n+                Value::String(\"Shaqueeena\".to_owned()),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n         };\n \n-        let block_hash = \"znuyjijnezBiGFuZAW9Q\";\n-        let event_source =\n-            EventSource::EthereumBlock(H256::from_slice(&block_hash.as_bytes())).to_string();\n-\n-        // Revert all events associated with event_source, \"znuyjijnezBiGFuZAW9Q\"\n-        store.revert_events(event_source, this_query.subgraph.clone());\n+        // Revert block 3\n+        store\n+            .revert_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_2_PTR,\n+            ).unwrap();\n \n         let returned_entities = store\n             .find(this_query.clone())\n             .expect(\"store.find operation failed\");\n \n-        // Check if the first user in the result vector has email \"queensha@email.com\"\n-        let returned_name = returned_entities[0].get(&String::from(\"email\"));\n-        let test_value = Value::String(String::from(\"queensha@email.com\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n         // There should be 1 user returned in results\n         assert_eq!(1, returned_entities.len());\n \n-        // Perform revert operation again to confirm idempotent nature of revert_events()\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-        let returned_name = returned_entities[0].get(&String::from(\"email\"));\n-        let test_value = Value::String(String::from(\"queensha@email.com\"));\n+        // Check if the first user in the result vector has email \"queensha@email.com\"\n+        let returned_name = returned_entities[0].get(&\"email\".to_owned());\n+        let test_value = Value::String(\"queensha@email.com\".to_owned());\n         assert!(returned_name.is_some());\n         assert_eq!(&test_value, returned_name.unwrap());\n \n@@ -1478,65 +1122,55 @@ fn revert_block() {\n }\n \n #[test]\n-#[cfg(any())]\n fn revert_block_with_delete() {\n     run_test(|store| -> Result<(), ()> {\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"name\"),\n-                Value::String(String::from(\"Cindini\")),\n+        let this_query = EntityQuery {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            filter: Some(EntityFilter::And(vec![EntityFilter::Equal(\n+                \"name\".to_owned(),\n+                Value::String(\"Cindini\".to_owned()),\n             )])),\n-            order_by: Some((String::from(\"name\"), ValueType::String)),\n-            order_direction: Some(StoreOrder::Descending),\n+            order_by: Some((\"name\".to_owned(), ValueType::String)),\n+            order_direction: Some(EntityOrder::Descending),\n             range: None,\n         };\n \n-        // Delete an entity using a randomly created event source\n-        let del_key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"2\"),\n+        // Delete entity with id=2\n+        let del_key = EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            entity_id: \"2\".to_owned(),\n         };\n \n-        let block_hash = \"test_block_to_revert\";\n-        let event_source = EventSource::EthereumBlock(H256::from_slice(&block_hash.as_bytes()));\n-        let revert_event_source = event_source.to_string();\n+        // Process deletion\n         store\n-            .delete(del_key.clone(), event_source)\n-            .expect(\"Store.delete operation failed\");\n-\n-        // Revert all events associated with our random event_source\n-        store.revert_events(revert_event_source, this_query.subgraph.clone());\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![EntityOperation::Remove { key: del_key }],\n+            ).unwrap();\n+\n+        // Revert deletion\n+        store\n+            .revert_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_4_PTR,\n+                *TEST_BLOCK_3_PTR,\n+            ).unwrap();\n \n+        // Query after revert\n         let returned_entities = store\n             .find(this_query.clone())\n             .expect(\"store.find operation failed\");\n \n-        // Check if \"dinici@email.com\" is in result set\n-        let returned_name = returned_entities[0].get(&String::from(\"email\"));\n-        let test_value = Value::String(String::from(\"dinici@email.com\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n         // There should be 1 entity returned in results\n         assert_eq!(1, returned_entities.len());\n \n-        // Perform revert operation again to confirm idempotent nature of revert_events()\n-        // Delete an entity using a randomly created event source\n-        let block_hash = \"test_block_to_revert\";\n-        let event_source = EventSource::EthereumBlock(H256::from_slice(&block_hash.as_bytes()));\n-        let revert_event_source = event_source.to_string();\n-        store\n-            .delete(del_key.clone(), event_source)\n-            .expect(\"Store.delete operation failed\");\n-        store.revert_events(revert_event_source, this_query.subgraph.clone());\n-        let returned_entities = store\n-            .find(this_query.clone())\n-            .expect(\"store.find operation failed\");\n-        let returned_name = returned_entities[0].get(&String::from(\"email\"));\n-        let test_value = Value::String(String::from(\"dinici@email.com\"));\n+        // Check if \"dinici@email.com\" is in result set\n+        let returned_name = returned_entities[0].get(&\"email\".to_owned());\n+        let test_value = Value::String(\"dinici@email.com\".to_owned());\n         assert!(returned_name.is_some());\n         assert_eq!(&test_value, returned_name.unwrap());\n \n@@ -1545,13 +1179,12 @@ fn revert_block_with_delete() {\n }\n \n #[test]\n-#[cfg(any())]\n fn revert_block_with_partial_update() {\n     run_test(|store| -> Result<(), ()> {\n-        let entity_key = StoreKey {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            id: String::from(\"1\"),\n+        let entity_key = EntityKey {\n+            subgraph_id: TEST_SUBGRAPH_ID.clone(),\n+            entity_type: \"user\".to_owned(),\n+            entity_id: \"1\".to_owned(),\n         };\n \n         let partial_entity = Entity::from(vec![\n@@ -1560,101 +1193,122 @@ fn revert_block_with_partial_update() {\n             (\"email\", Value::Null),\n         ]);\n \n-        let original_entity = store.get(entity_key.clone()).unwrap();\n-        let event_source = EventSource::EthereumBlock(H256::random());\n-        let revert_event_source = event_source.to_string();\n-\n-        // Verify that the entity before updating is different from what we expect afterwards\n-        assert_ne!(original_entity, partial_entity);\n+        let original_entity = store\n+            .get(entity_key.clone())\n+            .unwrap()\n+            .expect(\"missing entity\");\n \n         // Set test entity; as the entity already exists an update should be performed\n         store\n-            .set(entity_key.clone(), partial_entity, event_source)\n-            .expect(\"Failed to update entity that already exists\");\n+            .transact_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_3_PTR,\n+                *TEST_BLOCK_4_PTR,\n+                vec![EntityOperation::Set {\n+                    key: entity_key.clone(),\n+                    data: partial_entity.clone(),\n+                }],\n+            ).unwrap();\n \n         // Perform revert operation, reversing the partial update\n-        store.revert_events(revert_event_source.clone(), entity_key.subgraph.clone());\n+        store\n+            .revert_block_operations(\n+                TEST_SUBGRAPH_ID.clone(),\n+                *TEST_BLOCK_4_PTR,\n+                *TEST_BLOCK_3_PTR,\n+            ).unwrap();\n \n         // Obtain the reverted entity from the store\n-        let reverted_entity = store.get(entity_key.clone()).unwrap();\n+        let reverted_entity = store\n+            .get(entity_key.clone())\n+            .unwrap()\n+            .expect(\"missing entity\");\n \n         // Verify that the entity has been returned to its original state\n         assert_eq!(reverted_entity, original_entity);\n \n-        // Perform revert operation again and verify the same results to confirm the\n-        // idempotent nature of the revert_events function\n-        store.revert_events(revert_event_source, entity_key.subgraph.clone());\n-        let reverted_entity = store.get(entity_key).unwrap();\n-        assert_eq!(reverted_entity, original_entity);\n-\n         Ok(())\n     })\n }\n \n+// Disabled due to issue #332\n #[test]\n-#[cfg(any())]\n+#[ignore]\n fn entity_changes_are_fired_and_forwarded_to_subscriptions() {\n     run_test(|store| {\n+        let subgraph_id: SubgraphId = \"entity-change-test-subgraph\".to_owned();\n+        store\n+            .add_subgraph_if_missing(subgraph_id.clone(), *TEST_BLOCK_0_PTR)\n+            .unwrap();\n+\n         // Create a store subscription\n-        let subscription =\n-            store.subscribe(vec![(String::from(\"subgraph-id\"), String::from(\"User\"))]);\n+        let subscription = store.subscribe(vec![(subgraph_id.clone(), \"User\".to_owned())]);\n \n         // Add two entities to the store\n         let added_entities = vec![\n             (\n-                String::from(\"1\"),\n+                \"1\".to_owned(),\n                 Entity::from(vec![\n                     (\"id\", Value::from(\"1\")),\n                     (\"name\", Value::from(\"Johnny Boy\")),\n                 ]),\n             ),\n             (\n-                String::from(\"2\"),\n+                \"2\".to_owned(),\n                 Entity::from(vec![\n                     (\"id\", Value::from(\"2\")),\n                     (\"name\", Value::from(\"Tessa\")),\n                 ]),\n             ),\n         ];\n-        for (id, entity) in added_entities.iter() {\n-            store\n-                .set(\n-                    StoreKey {\n-                        subgraph: String::from(\"subgraph-id\"),\n-                        entity: String::from(\"User\"),\n-                        id: id.clone(),\n-                    },\n-                    entity.clone(),\n-                    EventSource::EthereumBlock(H256::random()),\n-                ).expect(\"failed to add entity to the store\");\n-        }\n+        store\n+            .transact_block_operations(\n+                subgraph_id.clone(),\n+                *TEST_BLOCK_0_PTR,\n+                *TEST_BLOCK_1_PTR,\n+                added_entities\n+                    .iter()\n+                    .map(|(id, data)| EntityOperation::Set {\n+                        key: EntityKey {\n+                            subgraph_id: subgraph_id.clone(),\n+                            entity_type: \"user\".to_owned(),\n+                            entity_id: id.to_owned(),\n+                        },\n+                        data: data.to_owned(),\n+                    }).collect(),\n+            ).unwrap();\n \n         // Update an entity in the store\n         let updated_entity = Entity::from(vec![\n             (\"id\", Value::from(\"1\")),\n             (\"name\", Value::from(\"Johnny\")),\n         ]);\n-        store\n-            .set(\n-                StoreKey {\n-                    subgraph: String::from(\"subgraph-id\"),\n-                    entity: String::from(\"User\"),\n-                    id: String::from(\"1\"),\n-                },\n-                updated_entity.clone(),\n-                EventSource::EthereumBlock(H256::random()),\n-            ).expect(\"failed to update entity in the store\");\n+        let update_op = EntityOperation::Set {\n+            key: EntityKey {\n+                subgraph_id: subgraph_id.clone(),\n+                entity_type: \"User\".to_owned(),\n+                entity_id: \"1\".to_owned(),\n+            },\n+            data: updated_entity.clone(),\n+        };\n \n         // Delete an entity in the store\n+        let delete_op = EntityOperation::Remove {\n+            key: EntityKey {\n+                subgraph_id: subgraph_id.clone(),\n+                entity_type: \"User\".to_owned(),\n+                entity_id: \"2\".to_owned(),\n+            },\n+        };\n+\n+        // Commit update & delete ops\n         store\n-            .delete(\n-                StoreKey {\n-                    subgraph: String::from(\"subgraph-id\"),\n-                    entity: String::from(\"User\"),\n-                    id: String::from(\"2\"),\n-                },\n-                EventSource::EthereumBlock(H256::random()),\n-            ).expect(\"failed to delete entity from the store\");\n+            .transact_block_operations(\n+                subgraph_id.clone(),\n+                *TEST_BLOCK_1_PTR,\n+                *TEST_BLOCK_2_PTR,\n+                vec![update_op, delete_op],\n+            ).unwrap();\n \n         // We're expecting four events to be written to the subscription stream\n         subscription\n@@ -1670,27 +1324,27 @@ fn entity_changes_are_fired_and_forwarded_to_subscriptions() {\n                     changes,\n                     vec![\n                         EntityChange {\n-                            subgraph: String::from(\"subgraph-id\"),\n-                            entity: String::from(\"User\"),\n-                            id: added_entities[0].clone().0,\n+                            subgraph_id: subgraph_id.clone(),\n+                            entity_type: \"User\".to_owned(),\n+                            entity_id: added_entities[0].clone().0,\n                             operation: EntityChangeOperation::Added,\n                         },\n                         EntityChange {\n-                            subgraph: String::from(\"subgraph-id\"),\n-                            entity: String::from(\"User\"),\n-                            id: added_entities[1].clone().0,\n+                            subgraph_id: subgraph_id.clone(),\n+                            entity_type: \"User\".to_owned(),\n+                            entity_id: added_entities[1].clone().0,\n                             operation: EntityChangeOperation::Added,\n                         },\n                         EntityChange {\n-                            subgraph: String::from(\"subgraph-id\"),\n-                            entity: String::from(\"User\"),\n-                            id: String::from(\"1\"),\n+                            subgraph_id: subgraph_id.clone(),\n+                            entity_type: \"User\".to_owned(),\n+                            entity_id: \"1\".to_owned(),\n                             operation: EntityChangeOperation::Updated,\n                         },\n                         EntityChange {\n-                            subgraph: String::from(\"subgraph-id\"),\n-                            entity: String::from(\"User\"),\n-                            id: added_entities[1].clone().0,\n+                            subgraph_id: subgraph_id.clone(),\n+                            entity_type: \"User\".to_owned(),\n+                            entity_id: added_entities[1].clone().0,\n                             operation: EntityChangeOperation::Removed,\n                         },\n                     ]\n@@ -1700,36 +1354,3 @@ fn entity_changes_are_fired_and_forwarded_to_subscriptions() {\n             }).and_then(|_| Ok(()))\n     })\n }\n-\n-#[cfg(any())]\n-#[test]\n-fn find_bytes_equal() {\n-    run_test(|| -> Result<(), ()> {\n-        let logger = Logger::root(slog::Discard, o!());\n-        let url = postgres_test_url();\n-        let store = DieselStore::new(StoreConfig { url }, &logger);\n-        let this_query = StoreQuery {\n-            subgraph: String::from(\"test_subgraph\"),\n-            entity: String::from(\"user\"),\n-            filter: Some(StoreFilter::And(vec![StoreFilter::Equal(\n-                String::from(\"hex_name\"),\n-                Value::Bytes(scalar::Bytes::from_str(&hex::encode(\"Johnton\")).unwrap()),\n-            )])),\n-            order_by: Some(String::from(\"name\")),\n-            order_direction: Some(StoreOrder::Descending),\n-            range: None,\n-        };\n-        let returned_entities = store.find(this_query).expect(\"store.find operation failed\");\n-\n-        // Check if the first user in the result vector is \"Johnton\"\n-        let returned_name = returned_entities[0].get(&String::from(\"name\"));\n-        let test_value = Value::String(String::from(\"Johnton\"));\n-        assert!(returned_name.is_some());\n-        assert_eq!(&test_value, returned_name.unwrap());\n-\n-        // There should be 1 users returned in results\n-        assert_eq!(1, returned_entities.len());\n-\n-        Ok(())\n-    })\n-}"
    }
  ],
  "fix_category": "Sorting (Database Query)",
  "root_cause_category": "Unordered collections",
  "root_cause_subcategory": "Sorting"
}