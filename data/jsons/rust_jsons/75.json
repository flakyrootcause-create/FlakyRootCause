{
  "id": 75,
  "repo": "sui",
  "issue_url": "https://github.com/MystenLabs/sui/issues/1624",
  "pr_url": "https://github.com/MystenLabs/sui/pull/1677",
  "issue_description": "Encountered on CI of a PR modifying purely github metadata:\r\nhttps://github.com/MystenLabs/sui/runs/6200152939?check_suite_focus=true\r\n\r\nFlaky and non-reproducible.\r\n\r\n```\r\nrunning 2 tests\r\ntest shared_object_transaction ... ok\r\ntest call_shared_object_contract ... FAILED\r\n\r\nfailures:\r\n\r\n---- call_shared_object_contract stdout ----\r\nthread 'call_shared_object_contract' panicked at 'Error acquiring lock for object(s): [UnexpectedSequenceNumber { object_id: 6EE48C2E2A362479E1F5DD836BA27D48C5546E7A, expected_sequence: SequenceNumber(2), given_sequence: SequenceNumber(1) }]', sui/tests/shared_objects_tests.rs:75:30\r\nstack backtrace:\r\n   0: rust_begin_unwind\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/std/src/panicking.rs:584:5\r\n   1: core::panicking::panic_fmt\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/panicking.rs:143:14\r\n   2: shared_objects_tests::submit_shared_object_transaction::{{closure}}\r\n             at ./tests/shared_objects_tests.rs:75:30\r\n   3: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/future/mod.rs:91:19\r\n   4: shared_objects_tests::call_shared_object_contract::{{closure}}\r\n             at ./tests/shared_objects_tests.rs:168:72\r\n   5: <core::future::from_generator::GenFuture<T> as core::future::future::Future>::poll\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/future/mod.rs:91:19\r\n   6: <core::pin::Pin<P> as core::future::future::Future>::poll\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/future/future.rs:124:9\r\n   7: tokio::runtime::basic_scheduler::CoreGuard::block_on::{{closure}}::{{closure}}::{{closure}}\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:498:48\r\n   8: tokio::coop::with_budget::{{closure}}\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/coop.rs:102:9\r\n   9: std::thread::local::LocalKey<T>::try_with\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/std/src/thread/local.rs:442:16\r\n  10: std::thread::local::LocalKey<T>::with\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/std/src/thread/local.rs:418:9\r\n  11: tokio::coop::with_budget\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/coop.rs:95:5\r\n  12: tokio::coop::budget\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/coop.rs:72:5\r\n  13: tokio::runtime::basic_scheduler::CoreGuard::block_on::{{closure}}::{{closure}}\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:498:25\r\n  14: tokio::runtime::basic_scheduler::Context::enter\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:356:19\r\n  15: tokio::runtime::basic_scheduler::CoreGuard::block_on::{{closure}}\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:497:36\r\n  16: tokio::runtime::basic_scheduler::CoreGuard::enter::{{closure}}\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:555:57\r\n  17: tokio::macros::scoped_tls::ScopedKey<T>::set\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/macros/scoped_tls.rs:61:9\r\n  18: tokio::runtime::basic_scheduler::CoreGuard::enter\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:555:27\r\n  19: tokio::runtime::basic_scheduler::CoreGuard::block_on\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:488:9\r\n  20: tokio::runtime::basic_scheduler::BasicScheduler::block_on\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/basic_scheduler.rs:168:24\r\n  21: tokio::runtime::Runtime::block_on\r\n             at /home/ubuntu/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.17.0/src/runtime/mod.rs:475:46\r\n  22: shared_objects_tests::call_shared_object_contract\r\n             at ./tests/shared_objects_tests.rs:186:5\r\n  23: shared_objects_tests::call_shared_object_contract::{{closure}}\r\n             at ./tests/shared_objects_tests.rs:104:7\r\n  24: core::ops::function::FnOnce::call_once\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/ops/function.rs:[227](https://github.com/MystenLabs/sui/runs/6200152939?check_suite_focus=true#step:5:227):5\r\n  25: core::ops::function::FnOnce::call_once\r\n             at /rustc/69a6d12e9f0372e3c6d82bc7c7e410dab02d0500/library/core/src/ops/function.rs:227:5\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\n\r\nfailures:\r\n    call_shared_object_contract\r\n\r\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 8.10s\r\n\r\nerror: test failed, to rerun pass '-p sui --test shared_objects_tests'\r\nError: Process completed with exit code 101.\r\n```\r\n\r\nFull log : https://gist.github.com/huitseeker/e5333b31a45b20fe6e56d1d6e425f78b\r\n\r\ncc @asonnino for shared objects, @velvia for locking service.",
  "files_changed": [
    {
      "filename": "Cargo.lock",
      "status": "modified",
      "patch": "@@ -805,7 +805,7 @@ dependencies = [\n [[package]]\n name = \"config\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"crypto\",\n  \"serde 1.0.136\",\n@@ -833,20 +833,18 @@ dependencies = [\n [[package]]\n name = \"consensus\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"bincode\",\n  \"blake2\",\n  \"bytes\",\n  \"config 0.1.0\",\n  \"crypto\",\n- \"futures\",\n  \"rand 0.7.3\",\n  \"rocksdb\",\n  \"serde 1.0.136\",\n  \"serde_bytes\",\n  \"tokio\",\n- \"tokio-util\",\n  \"tracing\",\n  \"typed-store 0.1.0 (git+https://github.com/mystenlabs/mysten-infra.git?rev=808de09203d147b43d59114b8afd9e51cbcf5778)\",\n  \"types\",\n@@ -981,7 +979,7 @@ dependencies = [\n [[package]]\n name = \"crypto\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"ark-bls12-377\",\n  \"ark-ec\",\n@@ -1096,12 +1094,12 @@ dependencies = [\n \n [[package]]\n name = \"darling\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f1a5d2e8b5a94b2261efb20e99a01255b9c5293797d69bbf04600567b2f9b8d7\"\n+checksum = \"4529658bdda7fd6769b8614be250cdcfc3aeb0ee72fe66f9e41e5e5eb73eac02\"\n dependencies = [\n- \"darling_core 0.14.0\",\n- \"darling_macro 0.14.0\",\n+ \"darling_core 0.14.1\",\n+ \"darling_macro 0.14.1\",\n ]\n \n [[package]]\n@@ -1120,9 +1118,9 @@ dependencies = [\n \n [[package]]\n name = \"darling_core\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8f1c7d56716be82d9c6adb967cfe700955179ea88806e898483dad6987330a54\"\n+checksum = \"649c91bc01e8b1eac09fb91e8dbc7d517684ca6be8ebc75bb9cafc894f9fdb6f\"\n dependencies = [\n  \"fnv\",\n  \"ident_case\",\n@@ -1145,24 +1143,24 @@ dependencies = [\n \n [[package]]\n name = \"darling_macro\"\n-version = \"0.14.0\"\n+version = \"0.14.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"64dd7e5a75a00cb6799ae9fbbfc3bba0134def6579a9e27564e72c839c837bed\"\n+checksum = \"ddfc69c5bfcbd2fc09a0f38451d2daf0e372e367986a83906d1b0dbc88134fb5\"\n dependencies = [\n- \"darling_core 0.14.0\",\n+ \"darling_core 0.14.1\",\n  \"quote\",\n  \"syn\",\n ]\n \n [[package]]\n name = \"dashmap\"\n-version = \"5.2.0\"\n+version = \"5.3.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c8858831f7781322e539ea39e72449c46b059638250c14344fec8d0aa6e539c\"\n+checksum = \"084c61a88f94d7557441d01e89fc3800b0b80658462b05aa7b55dfae069da09b\"\n dependencies = [\n  \"cfg-if 1.0.0\",\n- \"num_cpus\",\n- \"parking_lot 0.12.0\",\n+ \"hashbrown 0.12.0\",\n+ \"lock_api 0.4.7\",\n ]\n \n [[package]]\n@@ -1202,7 +1200,7 @@ version = \"0.11.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"1f91d4cfa921f1c05904dc3c57b4a32c38aed3340cce209f3a6fd1478babafc4\"\n dependencies = [\n- \"darling 0.14.0\",\n+ \"darling 0.14.1\",\n  \"proc-macro2\",\n  \"quote\",\n  \"syn\",\n@@ -1433,7 +1431,7 @@ checksum = \"77f3309417938f28bf8228fcff79a4a37103981e3e186d2ccd19c74b38f4eb71\"\n [[package]]\n name = \"executor\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"async-trait\",\n  \"bincode\",\n@@ -1804,9 +1802,9 @@ dependencies = [\n \n [[package]]\n name = \"http\"\n-version = \"0.2.6\"\n+version = \"0.2.7\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"31f4c6746584866f0feabcc69893c5b51beef3831656a968ed7ae254cdc4fd03\"\n+checksum = \"ff8670570af52249509a86f5e3e18a08c60b177071826898fde8997cf5f6bfbb\"\n dependencies = [\n  \"bytes\",\n  \"fnv\",\n@@ -1920,12 +1918,12 @@ dependencies = [\n \n [[package]]\n name = \"im\"\n-version = \"15.0.0\"\n+version = \"15.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"111c1983f3c5bb72732df25cddacee9b546d08325fb584b5ebd38148be7b0246\"\n+checksum = \"d0acd33ff0285af998aaf9b57342af478078f53492322fafc47450e09397e0e9\"\n dependencies = [\n  \"bitmaps\",\n- \"rand_core 0.5.1\",\n+ \"rand_core 0.6.3\",\n  \"rand_xoshiro\",\n  \"sized-chunks\",\n  \"typenum\",\n@@ -2216,9 +2214,9 @@ dependencies = [\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.124\"\n+version = \"0.2.125\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"21a41fed9d98f27ab1c6d161da622a4fa35e8a54a8adc24bbf3ddd0ef70b0e50\"\n+checksum = \"5916d2ae698f6de9bfb891ad7a8d65c09d232dc58cc4ac433c7da3b2fd84bc2b\"\n \n [[package]]\n name = \"libloading\"\n@@ -2247,9 +2245,9 @@ dependencies = [\n \n [[package]]\n name = \"libz-sys\"\n-version = \"1.1.5\"\n+version = \"1.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6f35facd4a5673cb5a48822be2be1d4236c1c99cb4113cab7061ac720d5bf859\"\n+checksum = \"92e7e15d7610cce1d9752e137625f14e61a28cd45929b6e12e47b50fe154ee2e\"\n dependencies = [\n  \"cc\",\n  \"pkg-config\",\n@@ -2264,9 +2262,9 @@ checksum = \"7fb9b38af92608140b86b693604b9ffcc5824240a484d1ecd4795bacb2fe88f3\"\n \n [[package]]\n name = \"linux-raw-sys\"\n-version = \"0.0.42\"\n+version = \"0.0.46\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5284f00d480e1c39af34e72f8ad60b94f47007e3481cd3b731c1d67190ddc7b7\"\n+checksum = \"d4d2456c373231a208ad294c33dc5bff30051eafd954cd4caae83a712b12854d\"\n \n [[package]]\n name = \"lock_api\"\n@@ -3069,7 +3067,7 @@ dependencies = [\n [[package]]\n name = \"network\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"async-trait\",\n  \"bytes\",\n@@ -3106,7 +3104,7 @@ dependencies = [\n [[package]]\n name = \"node\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"anyhow\",\n  \"async-trait\",\n@@ -3691,7 +3689,7 @@ dependencies = [\n [[package]]\n name = \"primary\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"async-recursion\",\n  \"async-trait\",\n@@ -3876,11 +3874,11 @@ dependencies = [\n \n [[package]]\n name = \"rand_xoshiro\"\n-version = \"0.4.0\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a9fcdd2e881d02f1d9390ae47ad8e5696a9e4be7b547a1da2afbc61973217004\"\n+checksum = \"6f97cdb2a36ed4183de61b2f824cc45c9f1037f28afe0a322e9fff4c108b5aaa\"\n dependencies = [\n- \"rand_core 0.5.1\",\n+ \"rand_core 0.6.3\",\n ]\n \n [[package]]\n@@ -4080,9 +4078,9 @@ dependencies = [\n \n [[package]]\n name = \"rustix\"\n-version = \"0.34.4\"\n+version = \"0.34.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3f5d1c6ed6d1c6915aa64749b809fc1bafff49d160f5d927463658093d7d62ab\"\n+checksum = \"f3e74b3f02f2b6eb33790923756784614f456de79d821d6b2670dc7d5fbea807\"\n dependencies = [\n  \"bitflags\",\n  \"errno\",\n@@ -4933,9 +4931,9 @@ dependencies = [\n \n [[package]]\n name = \"syn\"\n-version = \"1.0.91\"\n+version = \"1.0.92\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b683b2b825c8eef438b77c36a06dc262294da3d5a5813fac20da149241dcd44d\"\n+checksum = \"7ff7c592601f11445996a06f8ad0c27f094a58857c2f89e97974ab9235b92c52\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5149,9 +5147,9 @@ dependencies = [\n \n [[package]]\n name = \"tokio\"\n-version = \"1.17.0\"\n+version = \"1.18.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2af73ac49756f3f7c01172e34a23e5d0216f6c32333757c2c61feb2bbff5a5ee\"\n+checksum = \"0f48b6d60512a392e34dbf7fd456249fd2de3c83669ab642e021903f4015185b\"\n dependencies = [\n  \"bytes\",\n  \"libc\",\n@@ -5244,9 +5242,9 @@ dependencies = [\n \n [[package]]\n name = \"tower-http\"\n-version = \"0.3.0\"\n+version = \"0.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"79dd37121c38240c4b4fe6520332406218bbf876f2f690fe9e406020189366fd\"\n+checksum = \"e980386f06883cf4d0578d6c9178c81f68b45d77d00f2c2c1bc034b3439c2c56\"\n dependencies = [\n  \"bitflags\",\n  \"bytes\",\n@@ -5299,9 +5297,9 @@ dependencies = [\n \n [[package]]\n name = \"tracing-attributes\"\n-version = \"0.1.20\"\n+version = \"0.1.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2e65ce065b4b5c53e73bb28912318cb8c9e9ad3921f1d669eb0e68b4c8143a2b\"\n+checksum = \"cc6b8ad3567499f98a1db7a752b07a7c8c7c7c34c332ec00effb2b0027974b7c\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -5455,7 +5453,7 @@ checksum = \"dcf81ac59edc17cc8697ff311e8f5ef2d99fcbd9817b34cec66f90b6c3dfd987\"\n [[package]]\n name = \"types\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"base64\",\n  \"bincode\",\n@@ -5465,13 +5463,10 @@ dependencies = [\n  \"crypto\",\n  \"derive_builder\",\n  \"ed25519-dalek\",\n- \"futures\",\n  \"rand 0.7.3\",\n  \"serde 1.0.136\",\n- \"tempfile\",\n  \"thiserror\",\n  \"tokio\",\n- \"tokio-util\",\n  \"typed-store 0.1.0 (git+https://github.com/mystenlabs/mysten-infra.git?rev=808de09203d147b43d59114b8afd9e51cbcf5778)\",\n ]\n \n@@ -5867,7 +5862,7 @@ checksum = \"d19538ccc21819d01deaf88d6a17eae6596a12e9aafdbb97916fb49896d89de9\"\n [[package]]\n name = \"worker\"\n version = \"0.1.0\"\n-source = \"git+https://github.com/MystenLabs/narwhal?rev=976355d2ff75aefc6b7ec7fd32742d3d7188c4e0#976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\"\n+source = \"git+https://github.com/MystenLabs/narwhal?rev=72efe71f0615f91f861cc658e031b763ba30fd5b#72efe71f0615f91f861cc658e031b763ba30fd5b\"\n dependencies = [\n  \"async-trait\",\n  \"bincode\","
    },
    {
      "filename": "sui/Cargo.toml",
      "status": "modified",
      "patch": "@@ -56,9 +56,9 @@ move-binary-format = { git = \"https://github.com/move-language/move\", rev = \"4e0\n move-bytecode-utils = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\" }\n move-unit-test = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\" }\n \n-narwhal-node = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"node\" }\n-narwhal-config = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"config\" }\n-narwhal-crypto = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"crypto\" }\n+narwhal-node = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"node\" }\n+narwhal-config = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"config\" }\n+narwhal-crypto = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"crypto\" }\n \n once_cell = \"1.10.0\"\n "
    },
    {
      "filename": "sui/src/sui_commands.rs",
      "status": "modified",
      "patch": "@@ -553,11 +553,7 @@ pub async fn make_authority(\n \n     // Spawn a consensus listener. It listen for consensus outputs and notifies the\n     // authority server when a sequenced transaction is ready for execution.\n-    ConsensusListener::spawn(\n-        authority_state.clone(),\n-        rx_sui_to_consensus,\n-        rx_consensus_to_sui,\n-    );\n+    ConsensusListener::spawn(rx_sui_to_consensus, rx_consensus_to_sui);\n \n     // If we have network information make authority clients\n     // to all authorities in the system."
    },
    {
      "filename": "sui/tests/shared_objects_tests.rs",
      "status": "modified",
      "patch": "@@ -3,15 +3,17 @@\n use bytes::Bytes;\n use futures::{sink::SinkExt, stream::StreamExt};\n use sui::config::AuthorityPrivateInfo;\n-use sui_types::error::SuiError;\n+use sui_types::base_types::ObjectRef;\n+use sui_types::error::{SuiError, SuiResult};\n use sui_types::messages::CallArg;\n use sui_types::messages::Transaction;\n use sui_types::messages::TransactionInfoResponse;\n use sui_types::messages::{ConsensusTransaction, ExecutionStatus};\n+use sui_types::object::Object;\n use sui_types::serialize::{\n-    deserialize_message, deserialize_transaction_info, serialize_consensus_transaction,\n+    deserialize_message, deserialize_transaction_info, serialize_cert,\n+    serialize_consensus_transaction, SerializedMessage,\n };\n-use sui_types::serialize::{serialize_cert, SerializedMessage};\n use test_utils::authority::{spawn_test_authorities, test_authority_configs};\n use test_utils::messages::{make_certificates, move_transaction, publish_move_package_transaction};\n use test_utils::messages::{parse_package_ref, test_shared_object_transactions};\n@@ -48,37 +50,65 @@ async fn submit_single_owner_transaction(\n     responses\n }\n \n-// Keep submitting the certificate until it is sequenced by consensus. We use the loop\n-// since some consensus protocols (like Tusk) are not guaranteed to include the transaction\n-// (but it has high probability to do so, so it should virtually never be used).\n+/// Keep submitting the certificates of a shared-object transaction until it is sequenced by\n+/// at least one consensus node. We use the loop since some consensus protocols (like Tusk)\n+/// may drop transactions. The certificate is submitted to every Sui authority.\n async fn submit_shared_object_transaction(\n     transaction: Transaction,\n     configs: &[AuthorityPrivateInfo],\n-) -> TransactionInfoResponse {\n+) -> Vec<Option<SuiResult<TransactionInfoResponse>>> {\n     let certificate = make_certificates(vec![transaction]).pop().unwrap();\n     let message = ConsensusTransaction::UserTransaction(certificate);\n     let serialized = Bytes::from(serialize_consensus_transaction(&message));\n \n-    'main: loop {\n-        match transmit(serialized.clone(), &configs[0]).await {\n-            SerializedMessage::TransactionResp(reply) => {\n-                // We got a reply from the Sui authority.\n-                break 'main *reply;\n-            }\n-            SerializedMessage::Error(error) => match *error {\n-                SuiError::ConsensusConnectionBroken(_) => {\n-                    // This is the (confusing) error message returned by the consensus\n-                    // adapter. It means it didn't hear back from consensus and timed out.\n+    loop {\n+        let futures: Vec<_> = configs\n+            .iter()\n+            .map(|config| transmit(serialized.clone(), config))\n+            .collect();\n+\n+        let mut replies = Vec::new();\n+        for result in futures::future::join_all(futures).await {\n+            match result {\n+                SerializedMessage::TransactionResp(reply) => {\n+                    // We got a reply from the Sui authority.\n+                    replies.push(Some(Ok(*reply)));\n                 }\n-                error => panic!(\"{error}\"),\n-            },\n-            message => panic!(\"Unexpected protocol message: {message:?}\"),\n+                SerializedMessage::Error(error) => match *error {\n+                    SuiError::ConsensusConnectionBroken(_) => {\n+                        // This is the (confusing) error message returned by the consensus\n+                        // adapter. It means it didn't hear back from consensus and timed out.\n+                        replies.push(None);\n+                    }\n+                    error => replies.push(Some(Err(error))),\n+                },\n+                message => panic!(\"Unexpected protocol message: {message:?}\"),\n+            }\n+        }\n+        if replies.iter().any(|x| x.is_some()) {\n+            break replies;\n         }\n     }\n }\n \n+/// Helper function to publish the move package of a simple shared counter.\n+async fn publish_counter_package(\n+    gas_object: Object,\n+    configs: &[AuthorityPrivateInfo],\n+) -> ObjectRef {\n+    let transaction = publish_move_package_transaction(gas_object);\n+    let replies = submit_single_owner_transaction(transaction, configs).await;\n+    let mut package_refs = Vec::new();\n+    for reply in replies {\n+        let effects = reply.signed_effects.unwrap().effects;\n+        assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+        package_refs.push(parse_package_ref(&effects).unwrap());\n+    }\n+    package_refs.pop().unwrap()\n+}\n+\n+/// Send a simple shared object transaction to Sui and ensures the client gets back a response.\n #[tokio::test]\n-#[ignore = \"Flaky, see #1624\"]\n async fn shared_object_transaction() {\n     let mut objects = test_gas_objects();\n     objects.push(test_shared_object());\n@@ -94,12 +124,44 @@ async fn shared_object_transaction() {\n     // Submit the transaction. Note that this transaction is random and we do not expect\n     // it to be successfully executed by the Move execution engine.\n     tokio::task::yield_now().await;\n-    let reply = submit_shared_object_transaction(transaction, &configs).await;\n-    assert!(reply.signed_effects.is_some());\n+    let reply = submit_shared_object_transaction(transaction, &configs[0..1])\n+        .await\n+        .pop()\n+        .unwrap();\n+    let info = reply.unwrap().unwrap();\n+    assert!(info.signed_effects.is_some());\n }\n \n+/// Same as `shared_object_transaction` but every authorities submit the transaction.\n+#[tokio::test]\n+async fn many_shared_object_transactions() {\n+    let mut objects = test_gas_objects();\n+    objects.push(test_shared_object());\n+\n+    // Get the authority configs and spawn them. Note that it is important to not drop\n+    // the handles (or the authorities will stop).\n+    let configs = test_authority_configs();\n+    let _handles = spawn_test_authorities(objects, &configs).await;\n+\n+    // Make a test shared object certificate.\n+    let transaction = test_shared_object_transactions().pop().unwrap();\n+\n+    // Submit the transaction. Note that this transaction is random and we do not expect\n+    // it to be successfully executed by the Move execution engine.\n+    tokio::task::yield_now().await;\n+    let replies = submit_shared_object_transaction(transaction, &configs).await;\n+    for reply in replies {\n+        match reply {\n+            Some(Ok(_)) => (),\n+            Some(Err(error)) => panic!(\"{error}\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n+}\n+\n+/// End-to-end shared transaction test for a Sui validator. It does not test the client, wallet,\n+/// or gateway but tests the end-to-end flow from Sui to consensus.\n #[tokio::test]\n-#[ignore = \"Flaky, see #1624\"]\n async fn call_shared_object_contract() {\n     let mut gas_objects = test_gas_objects();\n \n@@ -110,15 +172,99 @@ async fn call_shared_object_contract() {\n \n     // Publish the move package to all authorities and get the new package ref.\n     tokio::task::yield_now().await;\n-    let transaction = publish_move_package_transaction(gas_objects.pop().unwrap());\n+    let package_ref = publish_counter_package(gas_objects.pop().unwrap(), &configs).await;\n+\n+    // Make a transaction to create a counter.\n+    tokio::task::yield_now().await;\n+    let transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"create\",\n+        package_ref,\n+        /* arguments */ Vec::default(),\n+    );\n     let replies = submit_single_owner_transaction(transaction, &configs).await;\n-    let mut package_refs = Vec::new();\n+    let mut counter_ids = Vec::new();\n     for reply in replies {\n         let effects = reply.signed_effects.unwrap().effects;\n         assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n-        package_refs.push(parse_package_ref(&effects).unwrap());\n+        let ((shared_object_id, _, _), _) = effects.created[0];\n+        counter_ids.push(shared_object_id);\n     }\n-    let package_ref = package_refs.pop().unwrap();\n+    let counter_id = counter_ids.pop().unwrap();\n+\n+    // Ensure the value of the counter is `0`.\n+    tokio::task::yield_now().await;\n+    let transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"assert_value\",\n+        package_ref,\n+        vec![\n+            CallArg::SharedObject(counter_id),\n+            CallArg::Pure(0u64.to_le_bytes().to_vec()),\n+        ],\n+    );\n+    let reply = submit_shared_object_transaction(transaction, &configs[0..1])\n+        .await\n+        .pop()\n+        .unwrap();\n+    let info = reply.unwrap().unwrap();\n+    let effects = info.signed_effects.unwrap().effects;\n+    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+\n+    // Make a transaction to increment the counter.\n+    tokio::task::yield_now().await;\n+    let transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"increment\",\n+        package_ref,\n+        vec![CallArg::SharedObject(counter_id)],\n+    );\n+    let reply = submit_shared_object_transaction(transaction, &configs[0..1])\n+        .await\n+        .pop()\n+        .unwrap();\n+    let info = reply.unwrap().unwrap();\n+    let effects = info.signed_effects.unwrap().effects;\n+    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+\n+    // Ensure the value of the counter is `1`.\n+    tokio::task::yield_now().await;\n+    let transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"assert_value\",\n+        package_ref,\n+        vec![\n+            CallArg::SharedObject(counter_id),\n+            CallArg::Pure(1u64.to_le_bytes().to_vec()),\n+        ],\n+    );\n+    let reply = submit_shared_object_transaction(transaction, &configs[0..1])\n+        .await\n+        .pop()\n+        .unwrap();\n+    let info = reply.unwrap().unwrap();\n+    let effects = info.signed_effects.unwrap().effects;\n+    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+}\n+\n+/// Same test as `call_shared_object_contract` but the clients submits many times the same\n+/// transaction (one copy per authority).\n+#[tokio::test]\n+async fn shared_object_flood() {\n+    let mut gas_objects = test_gas_objects();\n+\n+    // Get the authority configs and spawn them. Note that it is important to not drop\n+    // the handles (or the authorities will stop).\n+    let configs = test_authority_configs();\n+    let _handles = spawn_test_authorities(gas_objects.clone(), &configs).await;\n+\n+    // Publish the move package to all authorities and get the new pacakge ref.\n+    tokio::task::yield_now().await;\n+    let package_ref = publish_counter_package(gas_objects.pop().unwrap(), &configs).await;\n \n     // Make a transaction to create a counter.\n     tokio::task::yield_now().await;\n@@ -151,9 +297,17 @@ async fn call_shared_object_contract() {\n             CallArg::Pure(0u64.to_le_bytes().to_vec()),\n         ],\n     );\n-    let reply = submit_shared_object_transaction(transaction, &configs).await;\n-    let effects = reply.signed_effects.unwrap().effects;\n-    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+    let replies = submit_shared_object_transaction(transaction, &configs).await;\n+    for reply in replies {\n+        match reply {\n+            Some(Ok(info)) => {\n+                let effects = info.signed_effects.unwrap().effects;\n+                assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+            }\n+            Some(Err(error)) => panic!(\"{error}\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n \n     // Make a transaction to increment the counter.\n     tokio::task::yield_now().await;\n@@ -164,9 +318,17 @@ async fn call_shared_object_contract() {\n         package_ref,\n         vec![CallArg::SharedObject(counter_id)],\n     );\n-    let reply = submit_shared_object_transaction(transaction, &configs).await;\n-    let effects = reply.signed_effects.unwrap().effects;\n-    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+    let replies = submit_shared_object_transaction(transaction, &configs).await;\n+    for reply in replies {\n+        match reply {\n+            Some(Ok(info)) => {\n+                let effects = info.signed_effects.unwrap().effects;\n+                assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+            }\n+            Some(Err(error)) => panic!(\"{error}\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n \n     // Ensure the value of the counter is `1`.\n     tokio::task::yield_now().await;\n@@ -180,7 +342,101 @@ async fn call_shared_object_contract() {\n             CallArg::Pure(1u64.to_le_bytes().to_vec()),\n         ],\n     );\n-    let reply = submit_shared_object_transaction(transaction, &configs).await;\n+    let replies = submit_shared_object_transaction(transaction, &configs).await;\n+    for reply in replies {\n+        match reply {\n+            Some(Ok(info)) => {\n+                let effects = info.signed_effects.unwrap().effects;\n+                assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+            }\n+            Some(Err(error)) => panic!(\"{error}\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n+}\n+\n+#[tokio::test]\n+async fn shared_object_sync() {\n+    let mut gas_objects = test_gas_objects();\n+\n+    // Get the authority configs and spawn them. Note that it is important to not drop\n+    // the handles (or the authorities will stop).\n+    let configs = test_authority_configs();\n+    let _handles = spawn_test_authorities(gas_objects.clone(), &configs).await;\n+\n+    // Publish the move package to all authorities and get the new pacakge ref.\n+    tokio::task::yield_now().await;\n+    let package_ref = publish_counter_package(gas_objects.pop().unwrap(), &configs).await;\n+\n+    // Send a transaction to create a counter, but only to one authority.\n+    tokio::task::yield_now().await;\n+    let create_counter_transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"create\",\n+        package_ref,\n+        /* arguments */ Vec::default(),\n+    );\n+    let mut replies =\n+        submit_single_owner_transaction(create_counter_transaction.clone(), &configs[0..1]).await;\n+    let reply = replies.pop().unwrap();\n     let effects = reply.signed_effects.unwrap().effects;\n     assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+    let ((counter_id, _, _), _) = effects.created[0];\n+\n+    // Make a transaction to increment the counter.\n+    tokio::task::yield_now().await;\n+    let increment_counter_transaction = move_transaction(\n+        gas_objects.pop().unwrap(),\n+        \"Counter\",\n+        \"increment\",\n+        package_ref,\n+        vec![CallArg::SharedObject(counter_id)],\n+    );\n+\n+    // Let's submit the transaction to the first authority (the only one up-to-date).\n+    let reply =\n+        submit_shared_object_transaction(increment_counter_transaction.clone(), &configs[0..1])\n+            .await\n+            .pop()\n+            .unwrap();\n+    let info = reply.unwrap().unwrap();\n+    let effects = info.signed_effects.unwrap().effects;\n+    assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+\n+    // Let's submit the transaction to the out-of-date authorities.\n+    let replies =\n+        submit_shared_object_transaction(increment_counter_transaction.clone(), &configs[1..])\n+            .await;\n+    for reply in replies {\n+        match reply {\n+            Some(Err(SuiError::SharedObjectLockingFailure(_))) => (),\n+            Some(_) => panic!(\"Unexpected protocol message\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n+\n+    // Now send the missing certificates to the outdated authorities. We also re-send\n+    // the transaction to the first authority who should simply ignore it.\n+    tokio::task::yield_now().await;\n+    let replies = submit_single_owner_transaction(create_counter_transaction, &configs).await;\n+    for reply in replies {\n+        let effects = reply.signed_effects.unwrap().effects;\n+        assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+    }\n+\n+    // Now we can try again with the shared-object transaction who failed before.\n+    tokio::task::yield_now().await;\n+    let replies =\n+        submit_shared_object_transaction(increment_counter_transaction, &configs[1..]).await;\n+    for reply in replies {\n+        match reply {\n+            Some(Ok(info)) => {\n+                let effects = info.signed_effects.unwrap().effects;\n+                assert!(matches!(effects.status, ExecutionStatus::Success { .. }));\n+            }\n+            Some(Err(error)) => panic!(\"{error}\"),\n+            None => (), // May happen rarely (see above comment on consensus)\n+        }\n+    }\n }"
    },
    {
      "filename": "sui_core/Cargo.toml",
      "status": "modified",
      "patch": "@@ -42,7 +42,7 @@ move-vm-types = { git = \"https://github.com/move-language/move\", rev = \"4e025186\n \n typed-store = { git = \"https://github.com/MystenLabs/mysten-infra\", rev = \"d2976a45420147ad821baae96e6fe4b12215f743\"}\n \n-narwhal-executor = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"executor\" }\n+narwhal-executor = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"executor\" }\n \n [dev-dependencies]\n serde-reflection = \"0.3.5\""
    },
    {
      "filename": "sui_core/src/authority.rs",
      "status": "modified",
      "patch": "@@ -24,6 +24,7 @@ use std::{\n     sync::Arc,\n };\n use sui_adapter::adapter;\n+use sui_types::serialize::serialize_transaction_info;\n use sui_types::{\n     base_types::*,\n     batch::UpdateItem,\n@@ -257,8 +258,9 @@ impl AuthorityState {\n \n         // Ensure an idempotent answer.\n         if self._database.effects_exists(&transaction_digest)? {\n-            let transaction_info = self.make_transaction_info(&transaction_digest).await?;\n-            return Ok(transaction_info);\n+            let info = self.make_transaction_info(&transaction_digest).await?;\n+            debug!(\"Transaction {transaction_digest:?} already executed\");\n+            return Ok(info);\n         }\n \n         // Check the certificate and retrieve the transfer data.\n@@ -302,7 +304,9 @@ impl AuthorityState {\n                 } else if shared_locks[object_id] != *version {\n                     Some(SuiError::UnexpectedSequenceNumber {\n                         object_id: *object_id,\n+                        // This sequence number is the one attributed by consensus.\n                         expected_sequence: shared_locks[object_id],\n+                        // This sequence number is the one we currently have in the database.\n                         given_sequence: *version,\n                     })\n                 } else {\n@@ -313,6 +317,8 @@ impl AuthorityState {\n \n         fp_ensure!(\n             lock_errors.is_empty(),\n+            // NOTE: the error message here will say 'Error acquiring lock' but what it means is\n+            // 'error checking lock'.\n             SuiError::LockErrors {\n                 errors: lock_errors\n             }\n@@ -720,7 +726,7 @@ impl AuthorityState {\n     }\n \n     /// Make an information response for a transaction\n-    async fn make_transaction_info(\n+    pub async fn make_transaction_info(\n         &self,\n         transaction_digest: &TransactionDigest,\n     ) -> Result<TransactionInfoResponse, SuiError> {\n@@ -838,10 +844,34 @@ impl ExecutionState for AuthorityState {\n         &self,\n         execution_indices: ExecutionIndices,\n         transaction: Self::Transaction,\n-    ) -> Result<(), Self::Error> {\n+    ) -> Result<Vec<u8>, Self::Error> {\n         let ConsensusTransaction::UserTransaction(certificate) = transaction;\n-        self.handle_consensus_certificate(certificate, execution_indices)\n-            .await\n+\n+        // Ensure an idempotent answer.\n+        let digest = certificate.digest();\n+        if self._database.effects_exists(digest)? {\n+            let info = self.make_transaction_info(digest).await?;\n+            debug!(\"Shared-object transaction {digest:?} already executed\");\n+            return Ok(serialize_transaction_info(&info));\n+        }\n+\n+        // Assign locks to shared objects.\n+        self.handle_consensus_certificate(certificate.clone(), execution_indices)\n+            .await?;\n+        debug!(\"Shared objects locks successfully attributed to transaction {digest:?}\");\n+\n+        // Attempt to execute the transaction. This will only succeed if the authority\n+        // already executed all its dependencies.\n+        let confirmation_transaction = ConfirmationTransaction {\n+            certificate: certificate.clone(),\n+        };\n+        let info = self\n+            .handle_confirmation_transaction(confirmation_transaction.clone())\n+            .await?;\n+        debug!(\"Executed transaction {digest:?}\");\n+\n+        // Return a serialized transaction info response. This will be sent back to the client.\n+        Ok(serialize_transaction_info(&info))\n     }\n \n     fn ask_consensus_write_lock(&self) -> bool {"
    },
    {
      "filename": "sui_core/src/authority/authority_store.rs",
      "status": "modified",
      "patch": "@@ -838,9 +838,7 @@ impl<const ALL_OBJ_VER: bool, S: Eq + Serialize + for<'de> Deserialize<'de>>\n                 // sequence number (`OBJECT_START_VERSION`). Otherwise use the `scheduled` map to\n                 // to assign the next sequence number.\n                 let version = v.unwrap_or_else(|| OBJECT_START_VERSION);\n-                let next_version = v\n-                    .map(|v| v.increment())\n-                    .unwrap_or_else(|| SequenceNumber::from(2));\n+                let next_version = version.increment();\n \n                 let sequenced = ((transaction_digest, *id), version);\n                 let scheduled = (id, next_version);"
    },
    {
      "filename": "sui_core/src/authority_server.rs",
      "status": "modified",
      "patch": "@@ -256,11 +256,9 @@ impl AuthorityServer {\n                 .handle_batch_streaming(*message, channel)\n                 .await\n                 .map(|_| None),\n-            SerializedMessage::ConsensusTransaction(message) => self\n-                .consensus_adapter\n-                .submit(&message)\n-                .await\n-                .map(|info| Some(serialize_transaction_info(&info))),\n+            SerializedMessage::ConsensusTransaction(message) => {\n+                self.consensus_adapter.submit(&message).await.map(Some)\n+            }\n \n             _ => Err(SuiError::UnexpectedMessage),\n         };"
    },
    {
      "filename": "sui_core/src/consensus_adapter.rs",
      "status": "modified",
      "patch": "@@ -1,21 +1,17 @@\n // Copyright (c) 2022, Mysten Labs, Inc.\n // SPDX-License-Identifier: Apache-2.0\n-use crate::authority::AuthorityState;\n use bytes::Bytes;\n use futures::SinkExt;\n use narwhal_executor::SubscriberResult;\n use std::collections::hash_map::DefaultHasher;\n use std::collections::HashMap;\n use std::hash::{Hash, Hasher};\n use std::net::SocketAddr;\n-use std::sync::Arc;\n use sui_network::transport;\n use sui_network::transport::{RwChannel, TcpDataStream};\n use sui_types::committee::Committee;\n use sui_types::error::{SuiError, SuiResult};\n-use sui_types::messages::ConfirmationTransaction;\n use sui_types::messages::ConsensusTransaction;\n-use sui_types::messages::TransactionInfoResponse;\n use tokio::sync::mpsc::{Receiver, Sender};\n use tokio::sync::oneshot;\n use tokio::task::JoinHandle;\n@@ -29,15 +25,14 @@ pub mod consensus_tests;\n /// A serialized consensus transaction.\n type SerializedConsensusTransaction = Vec<u8>;\n \n-/// The digest of a consensus transactions\n+/// The digest of a consensus transactions.\n type ConsensusTransactionDigest = u64;\n \n-/// The message returned by the consensus to notify that a Sui certificate has been sequenced\n-/// and all its shared objects are locked.\n-type ConsensusOutput = (SubscriberResult<()>, SerializedConsensusTransaction);\n+/// Transaction info response serialized by Sui.\n+type SerializedTransactionInfoResponse = Vec<u8>;\n \n /// Channel to notify the called when the Sui certificate has been sequenced.\n-type Replier = oneshot::Sender<SuiResult<TransactionInfoResponse>>;\n+type Replier = oneshot::Sender<SuiResult<SerializedTransactionInfoResponse>>;\n \n /// Message to notify the consensus adapter of a new certificate sent to consensus.\n #[derive(Debug)]\n@@ -46,6 +41,13 @@ pub struct ConsensusInput {\n     replier: Replier,\n }\n \n+/// The message returned by the consensus to notify that a Sui certificate has been sequenced\n+/// and all its shared objects are locked.\n+type ConsensusOutput = (\n+    /* result */ SubscriberResult<SerializedTransactionInfoResponse>,\n+    /* transaction */ SerializedConsensusTransaction,\n+);\n+\n /// Submit Sui certificates to the consensus.\n pub struct ConsensusAdapter {\n     /// The network address of the consensus node.\n@@ -95,7 +97,7 @@ impl ConsensusAdapter {\n     pub async fn submit(\n         &self,\n         certificate: &ConsensusTransaction,\n-    ) -> SuiResult<TransactionInfoResponse> {\n+    ) -> SuiResult<SerializedTransactionInfoResponse> {\n         // Check the Sui certificate (submitted by the user).\n         certificate.check(&self.committee)?;\n \n@@ -139,8 +141,6 @@ impl ConsensusAdapter {\n /// This module interfaces the consensus with Sui. It receives certificates input to consensus and\n /// notify the called when they are sequenced.\n pub struct ConsensusListener {\n-    /// The authority state to execute shared-object transactions.\n-    state: Arc<AuthorityState>,\n     /// Receive messages input to the consensus.\n     rx_consensus_input: Receiver<ConsensusInput>,\n     /// Receive consensus outputs.\n@@ -152,13 +152,11 @@ pub struct ConsensusListener {\n impl ConsensusListener {\n     /// Spawn a new consensus adapter in a dedicated tokio task.\n     pub fn spawn(\n-        state: Arc<AuthorityState>,\n         rx_consensus_input: Receiver<ConsensusInput>,\n         rx_consensus_output: Receiver<ConsensusOutput>,\n     ) -> JoinHandle<()> {\n         tokio::spawn(async move {\n             Self {\n-                state,\n                 rx_consensus_input,\n                 rx_consensus_output,\n                 pending: HashMap::new(),\n@@ -168,35 +166,6 @@ impl ConsensusListener {\n         })\n     }\n \n-    /// Execute sequenced transactions and notify the end-user (if any).\n-    async fn process_consensus_output(&mut self, output: ConsensusOutput) {\n-        let (result, serialized) = output;\n-\n-        // Execute the transaction (if the consensus successfully sequenced it).\n-        let outcome = match result {\n-            Ok(()) => {\n-                let message =\n-                    bincode::deserialize(&serialized).expect(\"Failed to deserialize consensus tx\");\n-                let ConsensusTransaction::UserTransaction(certificate) = message;\n-                let confirmation_transaction = ConfirmationTransaction { certificate };\n-                self.state\n-                    .handle_confirmation_transaction(confirmation_transaction)\n-                    .await\n-            }\n-            Err(e) => Err(SuiError::from(e)),\n-        };\n-\n-        // Notify the caller that the transaction has been sequenced (if there is a caller).\n-        let digest = Self::hash(&serialized);\n-        if let Some(repliers) = self.pending.remove(&digest) {\n-            for replier in repliers {\n-                if replier.send(outcome.clone()).is_err() {\n-                    debug!(\"No replier to listen to consensus output {digest}\");\n-                }\n-            }\n-        }\n-    }\n-\n     /// Main loop receiving messages input to consensus and notifying the caller once the inputs\n     /// are sequenced (of if an error happened).\n     async fn run(&mut self) {\n@@ -210,10 +179,18 @@ impl ConsensusListener {\n                     self.pending.entry(digest).or_insert_with(Vec::new).push(replier);\n                 },\n \n-                // Execute sequenced transactions and notify the end-user (if any).\n-                Some(output) = self.rx_consensus_output.recv() => self\n-                    .process_consensus_output(output)\n-                    .await\n+                // Notify the caller that the transaction has been sequenced (if there is a caller).\n+                Some((result, serialized)) = self.rx_consensus_output.recv() => {\n+                    let outcome = result.map_err(SuiError::from);\n+                    let digest = Self::hash(&serialized);\n+                    if let Some(repliers) = self.pending.remove(&digest) {\n+                        for replier in repliers {\n+                            if replier.send(outcome.clone()).is_err() {\n+                                debug!(\"No replier to listen to consensus output {digest}\");\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n     }"
    },
    {
      "filename": "sui_core/src/unit_tests/consensus_tests.rs",
      "status": "modified",
      "patch": "@@ -11,11 +11,13 @@ use sui_adapter::genesis;\n use sui_types::base_types::{ObjectID, TransactionDigest};\n use sui_types::crypto::Signature;\n use sui_types::gas_coin::GasCoin;\n+use sui_types::messages::ConfirmationTransaction;\n use sui_types::messages::{\n     CallArg, CertifiedTransaction, SignatureAggregator, Transaction, TransactionData,\n };\n use sui_types::object::OBJECT_START_VERSION;\n use sui_types::object::{MoveObject, Object, Owner};\n+use sui_types::serialize::serialize_transaction_info;\n use test_utils::network::test_listener;\n use test_utils::test_keys;\n use tokio::sync::mpsc::channel;\n@@ -114,7 +116,6 @@ async fn listen_to_sequenced_transaction() {\n \n     // Spawn a consensus listener.\n     ConsensusListener::spawn(\n-        Arc::new(state),\n         /* rx_consensus_input */ rx_sui_to_consensus,\n         /* rx_consensus_output */ rx_consensus_to_sui,\n     );\n@@ -129,7 +130,7 @@ async fn listen_to_sequenced_transaction() {\n \n     // Notify the consensus listener that the transaction has been sequenced.\n     tokio::task::yield_now().await;\n-    let output = (Ok(()), serialized);\n+    let output = (Ok(Vec::default()), serialized);\n     tx_consensus_to_sui.send(output).await.unwrap();\n \n     // Ensure the caller get notified from the consensus listener.\n@@ -181,7 +182,8 @@ async fn submit_transaction_to_consensus() {\n         let confirmation_transaction = ConfirmationTransaction { certificate };\n         let result = state\n             .handle_confirmation_transaction(confirmation_transaction)\n-            .await;\n+            .await\n+            .map(|info| serialize_transaction_info(&info));\n \n         // Reply to the submitter.\n         replier.send(result).unwrap();"
    },
    {
      "filename": "sui_types/Cargo.toml",
      "status": "modified",
      "patch": "@@ -43,5 +43,5 @@ move-disassembler = { git = \"https://github.com/move-language/move\", rev = \"4e02\n move-ir-types = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\" }\n move-vm-types = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\" }\n \n-narwhal-executor = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"executor\" }\n-narwhal-crypto = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"crypto\" }\n+narwhal-executor = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"executor\" }\n+narwhal-crypto = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"crypto\" }"
    },
    {
      "filename": "test_utils/Cargo.toml",
      "status": "modified",
      "patch": "@@ -23,7 +23,7 @@ sui-framework = { path = \"../sui_programmability/framework\" }\n move-package = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\" }\n move-core-types = { git = \"https://github.com/move-language/move\", rev = \"4e025186af502c931318884df53c11bf34a664bc\", features = [\"address20\"] }\n typed-store = { git = \"https://github.com/MystenLabs/mysten-infra\", rev =\"d2976a45420147ad821baae96e6fe4b12215f743\"}\n-narwhal-config = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"976355d2ff75aefc6b7ec7fd32742d3d7188c4e0\", package = \"config\" }\n+narwhal-config = { git = \"https://github.com/MystenLabs/narwhal\", rev = \"72efe71f0615f91f861cc658e031b763ba30fd5b\", package = \"config\" }\n \n sui-types = { path = \"../sui_types\" }\n sui_core = { path = \"../sui_core\" }"
    }
  ],
  "fix_category": "Wait/Lock",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": "Wait/Lock"
}