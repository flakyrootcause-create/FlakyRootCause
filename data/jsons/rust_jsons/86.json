{
  "id": 86,
  "repo": "mirrord",
  "issue_url": "https://github.com/metalbear-co/mirrord/issues/1452",
  "pr_url": "https://github.com/metalbear-co/mirrord/pull/1612",
  "issue_description": "https://github.com/metalbear-co/mirrord/actions/runs/5066110644/jobs/9095518984?pr=1451\r\nI think it's similar to the #1451 just need to do same in flask\r\napplication_1_Application__PythonFlaskHTTP\r\n```\r\nthread 'mirroring_with_http::application_1_Application__PythonFlaskHTTP' panicked at 'Timeout 60s expired', /Users/runner/.cargo/registry/src/index.crates.io-6f17d22bba15001f/rstest-0.17.0/src/timeout.rs:42:21\r\nstack backtrace:\r\n   0: rust_begin_unwind\r\n             at /rustc/478cbb42b730ba4739351b72ce2aa928e78e2f81/library/std/src/panicking.rs:577:5\r\n   1: core::panicking::panic_fmt\r\n             at /rustc/478cbb42b730ba4739351b72ce2aa928e78e2f81/library/core/src/panicking.rs:67:14\r\n   2: rstest::timeout::execute_with_timeout_async::{{closure}}\r\n   3: http_mirroring::mirroring_with_http::application_1_Application__PythonFlaskHTTP::{{closure}}\r\n   4: <core::pin::Pin<P> as core::future::future::Future>::poll\r\n   5: tokio::runtime::park::CachedParkThread::block_on::{{closure}}\r\n   6: tokio::runtime::park::CachedParkThread::block_on\r\n   7: tokio::runtime::context::BlockingRegionGuard::block_on\r\n   8: tokio::runtime::scheduler::multi_thread::MultiThread::block_on\r\n   9: tokio::runtime::runtime::Runtime::block_on\r\n  10: http_mirroring::mirroring_with_http::application_1_Application__PythonFlaskHTTP\r\n  11: http_mirroring::mirroring_with_http::application_1_Application__PythonFlaskHTTP::{{closure}}\r\n  12: core::ops::function::FnOnce::call_once\r\n  13: core::ops::function::FnOnce::call_once\r\n             at /rustc/478cbb42b730ba4739351b72ce2aa928e78e2f81/library/core/src/ops/function.rs:250:5\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n```",
  "files_changed": [
    {
      "filename": "changelog.d/+async-mutex-in-tests.internal.md",
      "status": "added",
      "patch": "@@ -0,0 +1 @@\n+Change locks in test process to be async to avoid deadlocks\n\\ No newline at end of file"
    },
    {
      "filename": "mirrord/layer/tests/bash.rs",
      "status": "modified",
      "patch": "@@ -96,6 +96,6 @@ async fn bash_script(dylib_path: &Path) {\n     // and that's okay - it's either file closing then process terminates or process terminates.\n     // which closes the whole session in the agent\n \n-    test_process.assert_no_error_in_stdout();\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stdout().await;\n+    test_process.assert_no_error_in_stderr().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/common/mod.rs",
      "status": "modified",
      "patch": "@@ -1,11 +1,6 @@\n use std::{\n-    assert_matches::assert_matches,\n-    cmp::min,\n-    collections::HashMap,\n-    fmt::Debug,\n-    path::PathBuf,\n-    process::Stdio,\n-    sync::{Arc, Mutex},\n+    assert_matches::assert_matches, cmp::min, collections::HashMap, fmt::Debug, path::PathBuf,\n+    process::Stdio, sync::Arc,\n };\n \n use actix_codec::Framed;\n@@ -25,6 +20,7 @@ use tokio::{\n     io::{AsyncReadExt, AsyncWriteExt, BufReader},\n     net::{TcpListener, TcpStream},\n     process::{Child, Command},\n+    sync::Mutex,\n };\n \n /// Configuration for [`Application::RustOutgoingTcp`] and [`Application::RustOutgoingUdp`].\n@@ -46,23 +42,23 @@ pub struct TestProcess {\n }\n \n impl TestProcess {\n-    pub fn get_stdout(&self) -> String {\n-        self.stdout.lock().unwrap().clone()\n+    pub async fn get_stdout(&self) -> String {\n+        self.stdout.lock().await.clone()\n     }\n \n-    pub fn get_stderr(&self) -> String {\n-        self.stderr.lock().unwrap().clone()\n+    pub async fn get_stderr(&self) -> String {\n+        self.stderr.lock().await.clone()\n     }\n \n-    pub fn assert_log_level(&self, stderr: bool, level: &str) {\n+    pub async fn assert_log_level(&self, stderr: bool, level: &str) {\n         if stderr {\n-            assert!(!self.stderr.lock().unwrap().contains(level));\n+            assert!(!self.stderr.lock().await.contains(level));\n         } else {\n-            assert!(!self.stdout.lock().unwrap().contains(level));\n+            assert!(!self.stdout.lock().await.contains(level));\n         }\n     }\n \n-    fn from_child(mut child: Child) -> TestProcess {\n+    async fn from_child(mut child: Child) -> TestProcess {\n         let stderr_data = Arc::new(Mutex::new(String::new()));\n         let stdout_data = Arc::new(Mutex::new(String::new()));\n         let child_stderr = child.stderr.take().unwrap();\n@@ -82,7 +78,7 @@ impl TestProcess {\n                 let string = String::from_utf8_lossy(&buf[..n]);\n                 eprintln!(\"stderr {} {pid}: {}\", format_time(), string);\n                 {\n-                    stderr_data_reader.lock().unwrap().push_str(&string);\n+                    stderr_data_reader.lock().await.push_str(&string);\n                 }\n             }\n         });\n@@ -97,7 +93,7 @@ impl TestProcess {\n                 let string = String::from_utf8_lossy(&buf[..n]);\n                 print!(\"stdout {} {pid}: {}\", format_time(), string);\n                 {\n-                    stdout_data_reader.lock().unwrap().push_str(&string);\n+                    stdout_data_reader.lock().await.push_str(&string);\n                 }\n             }\n         });\n@@ -125,28 +121,28 @@ impl TestProcess {\n             .spawn()\n             .unwrap();\n         println!(\"Started application.\");\n-        TestProcess::from_child(child)\n+        TestProcess::from_child(child).await\n     }\n \n-    pub fn assert_stdout_contains(&self, string: &str) {\n-        assert!(self.stdout.lock().unwrap().contains(string));\n+    pub async fn assert_stdout_contains(&self, string: &str) {\n+        assert!(self.stdout.lock().await.contains(string));\n     }\n \n-    pub fn assert_stderr_contains(&self, string: &str) {\n-        assert!(self.stderr.lock().unwrap().contains(string));\n+    pub async fn assert_stderr_contains(&self, string: &str) {\n+        assert!(self.stderr.lock().await.contains(string));\n     }\n \n-    pub fn assert_no_error_in_stdout(&self) {\n+    pub async fn assert_no_error_in_stdout(&self) {\n         assert!(!self\n             .error_capture\n-            .is_match(&self.stdout.lock().unwrap())\n+            .is_match(&self.stdout.lock().await)\n             .unwrap());\n     }\n \n-    pub fn assert_no_error_in_stderr(&self) {\n+    pub async fn assert_no_error_in_stderr(&self) {\n         assert!(!self\n             .error_capture\n-            .is_match(&self.stderr.lock().unwrap())\n+            .is_match(&self.stderr.lock().await)\n             .unwrap());\n     }\n "
    },
    {
      "filename": "mirrord/layer/tests/dns_resolve.rs",
      "status": "modified",
      "patch": "@@ -57,6 +57,6 @@ async fn test_dns_resolve(\n     .unwrap();\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/fileops.rs",
      "status": "modified",
      "patch": "@@ -42,8 +42,8 @@ async fn self_open(dylib_path: &PathBuf) {\n     assert!(layer_connection.is_ended().await);\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }\n \n /// Verify that if the user's app is trying to read out of mirrord's temp bin dir for some messed up\n@@ -84,12 +84,12 @@ async fn read_from_mirrord_bin(dylib_path: &PathBuf) {\n     assert!(layer_connection.is_ended().await);\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n \n     // We read the contents from <TMPDIR>/<OUR-FILE> even though the app tried to read from\n     // <TMPDIR>/mirrord-bin/<TMPDIR>/<OUR-FILE>.\n-    test_process.assert_stdout_contains(contents);\n+    test_process.assert_stdout_contains(contents).await;\n }\n \n /// Verifies `pwrite` - if opening a file in write mode and writing to it at an offset of zero\n@@ -206,7 +206,7 @@ async fn pwrite(\n     }\n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n \n     // Assert that fwrite flushed correclty\n     let data = std::fs::read(\"/tmp/test_file2.txt\").unwrap();\n@@ -276,7 +276,7 @@ async fn node_close(\n \n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n #[rstest]\n@@ -337,7 +337,7 @@ async fn go_stat(\n         .await\n         .unwrap();\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n #[rstest]\n@@ -461,7 +461,7 @@ async fn go_dir(\n     layer_connection.expect_file_close(fd).await;\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n #[rstest]\n@@ -553,7 +553,7 @@ async fn go_dir_on_linux(\n     layer_connection.expect_file_close(fd).await;\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Test that the bypass works for reading dirs with Go.\n@@ -590,7 +590,7 @@ async fn go_dir_bypass(\n     assert!(layer_connection.is_ended().await);\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Test go file read and close.\n@@ -641,7 +641,7 @@ async fn read_go(\n \n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Test go file write.\n@@ -670,7 +670,7 @@ async fn write_go(\n \n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Test go file lseek.\n@@ -703,7 +703,7 @@ async fn lseek_go(\n \n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Test go file access.\n@@ -730,5 +730,5 @@ async fn faccessat_go(\n \n     // Assert all clear\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stderr().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/fork.rs",
      "status": "modified",
      "patch": "@@ -30,6 +30,6 @@ async fn fork(dylib_path: &PathBuf) {\n     assert!(connection_from_child_process.is_ended().await);\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/http_mirroring.rs",
      "status": "modified",
      "patch": "@@ -65,12 +65,20 @@ async fn mirroring_with_http(\n         .await;\n \n     test_process.wait().await;\n-    test_process.assert_stdout_contains(\"GET: Request completed\");\n-    test_process.assert_stdout_contains(\"POST: Request completed\");\n-    test_process.assert_stdout_contains(\"PUT: Request completed\");\n-    test_process.assert_stdout_contains(\"DELETE: Request completed\");\n-    test_process.assert_no_error_in_stdout();\n-    test_process.assert_no_error_in_stderr();\n+    test_process\n+        .assert_stdout_contains(\"GET: Request completed\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"POST: Request completed\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"PUT: Request completed\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"DELETE: Request completed\")\n+        .await;\n+    test_process.assert_no_error_in_stdout().await;\n+    test_process.assert_no_error_in_stderr().await;\n }\n \n /// Run the http mirroring test only on MacOS, because of a known crash on Linux."
    },
    {
      "filename": "mirrord/layer/tests/ignore_ports.rs",
      "status": "modified",
      "patch": "@@ -33,6 +33,6 @@ async fn ignore_ports(\n     // Make sure no listen request was made.\n     assert!(layer_connection.is_ended().await);\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/issue1054.rs",
      "status": "modified",
      "patch": "@@ -40,6 +40,10 @@ async fn test_issue1054(\n     layer_connection.send_close(new_connection_id).await;\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_stdout_contains(\"test issue 1054: START\");\n-    test_process.assert_stdout_contains(\"test issue 1054: SUCCESS\");\n+    test_process\n+        .assert_stdout_contains(\"test issue 1054: START\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"test issue 1054: SUCCESS\")\n+        .await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/issue1123.rs",
      "status": "modified",
      "patch": "@@ -32,6 +32,10 @@ async fn test_issue1123(\n     println!(\"Application subscribed to port, sending tcp messages.\");\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_stdout_contains(\"test issue 1123: START\");\n-    test_process.assert_stdout_contains(\"test issue 1123: SUCCESS\");\n+    test_process\n+        .assert_stdout_contains(\"test issue 1123: START\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"test issue 1123: SUCCESS\")\n+        .await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/issue1458.rs",
      "status": "modified",
      "patch": "@@ -77,8 +77,12 @@ async fn test_issue1458(\n         .unwrap();\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_stdout_contains(\"test issue 1458: START\");\n-    test_process.assert_stdout_contains(\"test issue 1458: SUCCESS\");\n+    test_process\n+        .assert_stdout_contains(\"test issue 1458: START\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"test issue 1458: SUCCESS\")\n+        .await;\n }\n \n /// Verify that we don't intercept UDP packets when `sendto` address' port is not `53`.\n@@ -108,6 +112,10 @@ async fn test_issue1458_port_not_53(\n     assert!(layer_connection.codec.try_next().await.unwrap().is_none());\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_stdout_contains(\"test issue 1458 port not 53: START\");\n-    test_process.assert_stdout_contains(\"test issue 1458 port not 53: SUCCESS\");\n+    test_process\n+        .assert_stdout_contains(\"test issue 1458 port not 53: START\")\n+        .await;\n+    test_process\n+        .assert_stdout_contains(\"test issue 1458 port not 53: SUCCESS\")\n+        .await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/issue834.rs",
      "status": "modified",
      "patch": "@@ -28,8 +28,8 @@ async fn test_issue834(\n         .await;\n \n     test_process.wait().await;\n-    test_process.assert_stdout_contains(\"okay\");\n+    test_process.assert_stdout_contains(\"okay\").await;\n \n-    test_process.assert_no_error_in_stdout();\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stdout().await;\n+    test_process.assert_no_error_in_stderr().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/listen_ports.rs",
      "status": "modified",
      "patch": "@@ -60,6 +60,6 @@ async fn listen_ports(\n     }\n     assert!(layer_connection.is_ended().await);\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/recv_from.rs",
      "status": "modified",
      "patch": "@@ -61,6 +61,6 @@ async fn recv_from(\n     .unwrap();\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/self_connect.rs",
      "status": "modified",
      "patch": "@@ -35,6 +35,6 @@ async fn self_connect(dylib_path: &PathBuf) {\n     }\n     assert!(layer_connection.is_ended().await);\n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stderr();\n-    test_process.assert_no_error_in_stdout();\n+    test_process.assert_no_error_in_stderr().await;\n+    test_process.assert_no_error_in_stdout().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/sip.rs",
      "status": "modified",
      "patch": "@@ -41,7 +41,8 @@ async fn tmp_dir_read_locally(dylib_path: &Path) {\n     test_process.wait().await;\n     assert!(!test_process\n         .get_stdout()\n+        .await\n         .contains(\"No such file or directory\"));\n-    test_process.assert_no_error_in_stdout();\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stdout().await;\n+    test_process.assert_no_error_in_stderr().await;\n }"
    },
    {
      "filename": "mirrord/layer/tests/spawn.rs",
      "status": "modified",
      "patch": "@@ -68,6 +68,6 @@ async fn node_spawn(dylib_path: &PathBuf) {\n     };\n \n     test_process.wait_assert_success().await;\n-    test_process.assert_no_error_in_stdout();\n-    test_process.assert_no_error_in_stderr();\n+    test_process.assert_no_error_in_stdout().await;\n+    test_process.assert_no_error_in_stderr().await;\n }"
    },
    {
      "filename": "tests/src/file_ops.rs",
      "status": "modified",
      "patch": "@@ -40,7 +40,7 @@ mod file_ops {\n         .await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        ops.assert(process);\n+        ops.assert(process).await;\n     }\n \n     #[cfg(target_os = \"macos\")]\n@@ -69,7 +69,7 @@ mod file_ops {\n         .await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        process.assert_python_fileops_stderr();\n+        process.assert_python_fileops_stderr().await;\n     }\n \n     #[rstest]\n@@ -102,7 +102,7 @@ mod file_ops {\n         .await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        process.assert_python_fileops_stderr();\n+        process.assert_python_fileops_stderr().await;\n     }\n \n     #[rstest]\n@@ -134,7 +134,7 @@ mod file_ops {\n         .await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        process.assert_python_fileops_stderr();\n+        process.assert_python_fileops_stderr().await;\n     }\n \n     // Currently fails due to Layer >> AddressConversion in ci for some reason"
    },
    {
      "filename": "tests/src/http.rs",
      "status": "modified",
      "patch": "@@ -49,18 +49,22 @@ mod http {\n                 None,\n             )\n             .await;\n-        process.wait_for_line(Duration::from_secs(120), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(120), \"daemon subscribed\")\n+            .await;\n         send_requests(&url, false, Default::default()).await;\n-        process.wait_for_line(Duration::from_secs(10), \"GET\");\n-        process.wait_for_line(Duration::from_secs(10), \"POST\");\n-        process.wait_for_line(Duration::from_secs(10), \"PUT\");\n-        process.wait_for_line(Duration::from_secs(10), \"DELETE\");\n+        process.wait_for_line(Duration::from_secs(10), \"GET\").await;\n+        process.wait_for_line(Duration::from_secs(10), \"POST\").await;\n+        process.wait_for_line(Duration::from_secs(10), \"PUT\").await;\n+        process\n+            .wait_for_line(Duration::from_secs(10), \"DELETE\")\n+            .await;\n         timeout(Duration::from_secs(40), process.child.wait())\n             .await\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&process);\n+        application.assert(&process).await;\n     }\n \n     #[ignore] // TODO: create integration test instead.\n@@ -91,17 +95,21 @@ mod http {\n                 None,\n             )\n             .await;\n-        process.wait_for_line(Duration::from_secs(300), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(300), \"daemon subscribed\")\n+            .await;\n         send_requests(&url, false, Default::default()).await;\n-        process.wait_for_line(Duration::from_secs(10), \"GET\");\n-        process.wait_for_line(Duration::from_secs(10), \"POST\");\n-        process.wait_for_line(Duration::from_secs(10), \"PUT\");\n-        process.wait_for_line(Duration::from_secs(10), \"DELETE\");\n+        process.wait_for_line(Duration::from_secs(10), \"GET\").await;\n+        process.wait_for_line(Duration::from_secs(10), \"POST\").await;\n+        process.wait_for_line(Duration::from_secs(10), \"PUT\").await;\n+        process\n+            .wait_for_line(Duration::from_secs(10), \"DELETE\")\n+            .await;\n         timeout(Duration::from_secs(40), process.child.wait())\n             .await\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&process);\n+        application.assert(&process).await;\n     }\n }"
    },
    {
      "filename": "tests/src/lib.rs",
      "status": "modified",
      "patch": "@@ -17,7 +17,7 @@ mod utils {\n         net::Ipv4Addr,\n         path::PathBuf,\n         process::Stdio,\n-        sync::{Arc, Condvar, Mutex},\n+        sync::{Arc, Condvar},\n         time::Duration,\n     };\n \n@@ -42,7 +42,10 @@ mod utils {\n     use tokio::{\n         io::{AsyncReadExt, AsyncWriteExt, BufReader},\n         process::{Child, Command},\n-        sync::oneshot::{self, Sender},\n+        sync::{\n+            oneshot::{self, Sender},\n+            Mutex,\n+        },\n     };\n \n     const TEXT: &'static str = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n@@ -146,35 +149,35 @@ mod utils {\n     }\n \n     impl TestProcess {\n-        pub fn get_stdout(&self) -> String {\n-            self.stdout.lock().unwrap().clone()\n+        pub async fn get_stdout(&self) -> String {\n+            self.stdout.lock().await.clone()\n         }\n \n-        pub fn get_stderr(&self) -> String {\n-            self.stderr.lock().unwrap().clone()\n+        pub async fn get_stderr(&self) -> String {\n+            self.stderr.lock().await.clone()\n         }\n \n-        pub fn assert_log_level(&self, stderr: bool, level: &str) {\n+        pub async fn assert_log_level(&self, stderr: bool, level: &str) {\n             if stderr {\n-                assert!(!self.stderr.lock().unwrap().contains(level));\n+                assert!(!self.stderr.lock().await.contains(level));\n             } else {\n-                assert!(!self.stdout.lock().unwrap().contains(level));\n+                assert!(!self.stdout.lock().await.contains(level));\n             }\n         }\n \n-        pub fn assert_python_fileops_stderr(&self) {\n-            assert!(!self.stderr.lock().unwrap().contains(\"FAILED\"));\n+        pub async fn assert_python_fileops_stderr(&self) {\n+            assert!(!self.stderr.lock().await.contains(\"FAILED\"));\n         }\n \n         pub async fn wait_assert_success(self) {\n             let output = self.child.wait_with_output().await.unwrap();\n             assert!(output.status.success());\n         }\n \n-        pub fn wait_for_line(&self, timeout: Duration, line: &str) {\n+        pub async fn wait_for_line(&self, timeout: Duration, line: &str) {\n             let now = std::time::Instant::now();\n             while now.elapsed() < timeout {\n-                let stderr = self.get_stderr();\n+                let stderr = self.get_stderr().await;\n                 if stderr.contains(line) {\n                     return;\n                 }\n@@ -190,7 +193,7 @@ mod utils {\n             }\n         }\n \n-        pub fn from_child(mut child: Child, tempdir: TempDir) -> TestProcess {\n+        pub async fn from_child(mut child: Child, tempdir: TempDir) -> TestProcess {\n             let stderr_data = Arc::new(Mutex::new(String::new()));\n             let stdout_data = Arc::new(Mutex::new(String::new()));\n             let child_stderr = child.stderr.take().unwrap();\n@@ -211,7 +214,7 @@ mod utils {\n                     let string = String::from_utf8_lossy(&buf[..n]);\n                     eprintln!(\"stderr {} {pid}: {}\", format_time(), string);\n                     {\n-                        stderr_data_reader.lock().unwrap().push_str(&string);\n+                        stderr_data_reader.lock().await.push_str(&string);\n                     }\n                 }\n             });\n@@ -226,7 +229,7 @@ mod utils {\n                     let string = String::from_utf8_lossy(&buf[..n]);\n                     print!(\"stdout {} {pid}: {}\", format_time(), string);\n                     {\n-                        stdout_data_reader.lock().unwrap().push_str(&string);\n+                        stdout_data_reader.lock().await.push_str(&string);\n                     }\n                 }\n             });\n@@ -296,13 +299,13 @@ mod utils {\n             run_exec_with_target(self.get_cmd(), target, namespace, args, env).await\n         }\n \n-        pub fn assert(&self, process: &TestProcess) {\n+        pub async fn assert(&self, process: &TestProcess) {\n             match self {\n                 Application::PythonFastApiHTTP => {\n-                    process.assert_log_level(true, \"ERROR\");\n-                    process.assert_log_level(false, \"ERROR\");\n-                    process.assert_log_level(true, \"CRITICAL\");\n-                    process.assert_log_level(false, \"CRITICAL\");\n+                    process.assert_log_level(true, \"ERROR\").await;\n+                    process.assert_log_level(false, \"ERROR\").await;\n+                    process.assert_log_level(true, \"CRITICAL\").await;\n+                    process.assert_log_level(false, \"CRITICAL\").await;\n                 }\n                 _ => {}\n             }\n@@ -334,9 +337,9 @@ mod utils {\n         }\n \n         #[cfg(target_os = \"linux\")]\n-        pub fn assert(&self, process: TestProcess) {\n+        pub async fn assert(&self, process: TestProcess) {\n             match self {\n-                FileOps::Python => process.assert_python_fileops_stderr(),\n+                FileOps::Python => process.assert_python_fileops_stderr().await,\n                 _ => {}\n             }\n         }\n@@ -450,11 +453,11 @@ mod utils {\n             server.id().unwrap()\n         );\n         // We need to hold temp dir until the process is finished\n-        TestProcess::from_child(server, temp_dir)\n+        TestProcess::from_child(server, temp_dir).await\n     }\n \n     /// Runs `mirrord ls` command and asserts if the json matches the expected format\n-    pub fn run_ls(args: Option<Vec<&str>>, namespace: Option<&str>) -> TestProcess {\n+    pub async fn run_ls(args: Option<Vec<&str>>, namespace: Option<&str>) -> TestProcess {\n         let path = match option_env!(\"MIRRORD_TESTS_USE_BINARY\") {\n             None => env!(\"CARGO_BIN_FILE_MIRRORD\"),\n             Some(binary_path) => binary_path,\n@@ -479,7 +482,7 @@ mod utils {\n             \"executed mirrord with args {mirrord_args:?} pid {}\",\n             process.id().unwrap()\n         );\n-        TestProcess::from_child(process, temp_dir)\n+        TestProcess::from_child(process, temp_dir).await\n     }\n \n     #[fixture]\n@@ -494,7 +497,7 @@ mod utils {\n     struct ResourceGuard {\n         /// Used in the implementation of [`Drop`] for this struct to block until the background\n         /// task exits.\n-        task_finished: Arc<(Mutex<bool>, Condvar)>,\n+        task_finished: Arc<(std::sync::Mutex<bool>, Condvar)>,\n         /// Used to inform the background task whether this guard was dropped during panic.\n         panic_tx: Option<Sender<bool>>,\n     }\n@@ -511,7 +514,7 @@ mod utils {\n             api.create(&PostParams::default(), data).await?;\n \n             let (panic_tx, panic_rx) = oneshot::channel::<bool>();\n-            let task_finished = Arc::new((Mutex::new(false), Condvar::new()));\n+            let task_finished = Arc::new((std::sync::Mutex::new(false), Condvar::new()));\n             let finished = task_finished.clone();\n \n             tokio::spawn(async move {"
    },
    {
      "filename": "tests/src/target.rs",
      "status": "modified",
      "patch": "@@ -11,10 +11,10 @@ mod target {\n     #[tokio::test(flavor = \"multi_thread\", worker_threads = 2)]\n     pub async fn mirrord_ls(#[future] service: KubeService) {\n         let service = service.await;\n-        let mut process = run_ls(None, None);\n+        let mut process = run_ls(None, None).await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        let stdout = process.get_stdout();\n+        let stdout = process.get_stdout().await;\n         let targets: Vec<String> = serde_json::from_str(&stdout).unwrap();\n         let re = Regex::new(r\"^(pod|deployment)/.+(/container/.+)?$\").unwrap();\n         targets"
    },
    {
      "filename": "tests/src/targetless.rs",
      "status": "modified",
      "patch": "@@ -24,7 +24,7 @@ mod targetless {\n         let mut process = app.run_targetless(None, None, None).await;\n         let res = process.child.wait().await.unwrap();\n         assert!(res.success());\n-        let stdout = process.get_stdout();\n+        let stdout = process.get_stdout().await;\n         assert!(stdout.contains(r#\"\"apiVersion\": \"v1\"\"#))\n     }\n }"
    },
    {
      "filename": "tests/src/traffic/steal.rs",
      "status": "modified",
      "patch": "@@ -44,14 +44,16 @@ mod steal {\n             .run(&service.target, Some(&service.namespace), Some(flags), None)\n             .await;\n \n-        process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n         send_requests(&url, true, Default::default()).await;\n         tokio::time::timeout(Duration::from_secs(40), process.child.wait())\n             .await\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&process);\n+        application.assert(&process).await;\n     }\n \n     #[cfg(target_os = \"linux\")]\n@@ -85,14 +87,16 @@ mod steal {\n             )\n             .await;\n \n-        process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n         send_requests(&url, true, Default::default()).await;\n         tokio::time::timeout(Duration::from_secs(40), process.child.wait())\n             .await\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&process);\n+        application.assert(&process).await;\n     }\n \n     /// Test the app continues running with mirrord and traffic is no longer stolen after the app\n@@ -118,10 +122,14 @@ mod steal {\n             .await;\n \n         // Verify that we hooked the socket operations and the agent started stealing.\n-        process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         // Wait for the test app to close the socket and tell us about it.\n-        process.wait_for_line(Duration::from_secs(40), \"Closed socket\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"Closed socket\")\n+            .await;\n \n         // Flake-proofing the test:\n         // If we connect to the service between the time the test application had closed its socket\n@@ -206,12 +214,16 @@ mod steal {\n         let (addr, port) = get_service_host_and_port(kube_client.clone(), &service).await;\n \n         // Wait for the app to start listening for stolen data before connecting.\n-        process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         let mut tcp_stream = TcpStream::connect((addr, port as u16)).unwrap();\n \n         // Wait for the test app to close the socket and tell us about it.\n-        process.wait_for_line(Duration::from_secs(40), \"Closed socket.\");\n+        process\n+            .wait_for_line(Duration::from_secs(40), \"Closed socket.\")\n+            .await;\n \n         const DATA: &[u8; 16] = b\"upper me please\\n\";\n \n@@ -278,7 +290,9 @@ mod steal {\n             )\n             .await;\n \n-        client.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        client\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         let mut headers = HeaderMap::default();\n         headers.insert(\"x-filter\", \"yes\".parse().unwrap());\n@@ -289,7 +303,7 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&client);\n+        application.assert(&client).await;\n     }\n \n     #[rstest]\n@@ -318,7 +332,9 @@ mod steal {\n             )\n             .await;\n \n-        client.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        client\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         let mut headers = HeaderMap::default();\n         headers.insert(\"x-filter\", \"yes\".parse().unwrap());\n@@ -329,7 +345,7 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&client);\n+        application.assert(&client).await;\n     }\n \n     #[rstest]\n@@ -358,7 +374,9 @@ mod steal {\n             )\n             .await;\n \n-        client.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        client\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         let headers = HeaderMap::default();\n         // Send a GET that should go through to remote\n@@ -384,7 +402,7 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&client);\n+        application.assert(&client).await;\n     }\n \n     #[rstest]\n@@ -413,7 +431,9 @@ mod steal {\n             )\n             .await;\n \n-        mirrored_process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        mirrored_process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         // Send a GET that should be matched and stolen.\n         // And a DELETE that closes the app.\n@@ -449,7 +469,7 @@ mod steal {\n             .expect(\"Timed out waiting for mirrored_process!\")\n             .expect(\"mirrored_process failed!\");\n \n-        application.assert(&mirrored_process);\n+        application.assert(&mirrored_process).await;\n     }\n \n     /// To run on mac, first build universal binary: (from repo root) `scripts/build_fat_mac.sh`\n@@ -485,7 +505,9 @@ mod steal {\n             )\n             .await;\n \n-        mirrorded_process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        mirrorded_process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         // Send a GET that should be matched and stolen.\n         let client = reqwest::Client::new();\n@@ -517,7 +539,7 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&mirrorded_process);\n+        application.assert(&mirrorded_process).await;\n     }\n \n     /// Test the case where running with `steal` set and an http header filter, but getting a\n@@ -551,7 +573,9 @@ mod steal {\n             )\n             .await;\n \n-        mirrorded_process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        mirrorded_process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         let addr = SocketAddr::new(host.trim().parse().unwrap(), port as u16);\n         let mut stream = TcpStream::connect(addr).unwrap();\n@@ -564,7 +588,7 @@ mod steal {\n         assert_eq!(&buf[8..], tcp_data); // The correct data was sent there and back.\n \n         // Verify the data was passed through and nothing was sent to the local app.\n-        let stdout_after = mirrorded_process.get_stdout();\n+        let stdout_after = mirrorded_process.get_stdout().await;\n         assert!(!stdout_after.contains(\"LOCAL APP GOT DATA\"));\n \n         // Send a DELETE that should be matched and thus stolen, closing the app.\n@@ -580,7 +604,7 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&mirrorded_process);\n+        application.assert(&mirrorded_process).await;\n     }\n \n     /// Test the case where running with `steal` set and an http header filter, we get an HTTP\n@@ -621,7 +645,9 @@ mod steal {\n             )\n             .await;\n \n-        mirrorded_process.wait_for_line(Duration::from_secs(40), \"daemon subscribed\");\n+        mirrorded_process\n+            .wait_for_line(Duration::from_secs(40), \"daemon subscribed\")\n+            .await;\n \n         // Create a websocket connection to test the HTTP upgrade bypass.\n         let host = host.trim();\n@@ -649,7 +675,7 @@ mod steal {\n         assert_eq!(&read_message[8..], write_data); // The correct data was sent there and back.\n \n         // Verify the data was passed through and nothing was sent to the local app.\n-        let stdout_after = mirrorded_process.get_stdout();\n+        let stdout_after = mirrorded_process.get_stdout().await;\n         assert!(!stdout_after.contains(\"LOCAL APP GOT DATA\"));\n \n         // Send a DELETE that should be matched and thus stolen, closing the app.\n@@ -665,6 +691,6 @@ mod steal {\n             .unwrap()\n             .unwrap();\n \n-        application.assert(&mirrorded_process);\n+        application.assert(&mirrorded_process).await;\n     }\n }"
    }
  ],
  "fix_category": "Wait/Lock",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": "Deadlock"
}