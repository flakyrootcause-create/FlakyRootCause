{
  "id": 12,
  "repo": "solana",
  "issue_url": "https://github.com/solana-labs/solana/issues/5660",
  "pr_url": "https://github.com/solana-labs/solana/pull/6251",
  "issue_description": "#### Problem\r\n#5659\r\n\r\n#### Proposed Solution\r\nDebug the race condition exposed by test_banking_stage_entryfication, fix it, then revert #5659\r\n",
  "files_changed": [
    {
      "filename": "banking_bench/src/main.rs",
      "status": "modified",
      "patch": "@@ -155,7 +155,7 @@ fn main() {\n             Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n         );\n         let (exit, poh_recorder, poh_service, signal_receiver) =\n-            create_test_recorder(&bank, &blocktree);\n+            create_test_recorder(&bank, &blocktree, None);\n         let cluster_info = ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n         let cluster_info = Arc::new(RwLock::new(cluster_info));\n         let _banking_stage = BankingStage::new("
    },
    {
      "filename": "core/benches/banking_stage.rs",
      "status": "modified",
      "patch": "@@ -66,7 +66,7 @@ fn bench_consume_buffered(bencher: &mut Bencher) {\n             Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n         );\n         let (exit, poh_recorder, poh_service, _signal_receiver) =\n-            create_test_recorder(&bank, &blocktree);\n+            create_test_recorder(&bank, &blocktree, None);\n \n         let tx = test_tx();\n         let len = 4096;\n@@ -198,7 +198,7 @@ fn bench_banking(bencher: &mut Bencher, tx_type: TransactionType) {\n             Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n         );\n         let (exit, poh_recorder, poh_service, signal_receiver) =\n-            create_test_recorder(&bank, &blocktree);\n+            create_test_recorder(&bank, &blocktree, None);\n         let cluster_info = ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n         let cluster_info = Arc::new(RwLock::new(cluster_info));\n         let _banking_stage = BankingStage::new("
    },
    {
      "filename": "core/src/banking_stage.rs",
      "status": "modified",
      "patch": "@@ -928,14 +928,15 @@ impl Service for BankingStage {\n pub fn create_test_recorder(\n     bank: &Arc<Bank>,\n     blocktree: &Arc<Blocktree>,\n+    poh_config: Option<PohConfig>,\n ) -> (\n     Arc<AtomicBool>,\n     Arc<Mutex<PohRecorder>>,\n     PohService,\n     Receiver<WorkingBankEntry>,\n ) {\n     let exit = Arc::new(AtomicBool::new(false));\n-    let poh_config = Arc::new(PohConfig::default());\n+    let poh_config = Arc::new(poh_config.unwrap_or_default());\n     let (mut poh_recorder, entry_receiver) = PohRecorder::new(\n         bank.tick_height(),\n         bank.last_blockhash(),\n@@ -986,7 +987,7 @@ mod tests {\n                 Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n             );\n             let (exit, poh_recorder, poh_service, _entry_receiever) =\n-                create_test_recorder(&bank, &blocktree);\n+                create_test_recorder(&bank, &blocktree, None);\n             let cluster_info = ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n             let cluster_info = Arc::new(RwLock::new(cluster_info));\n             let banking_stage = BankingStage::new(\n@@ -1011,6 +1012,7 @@ mod tests {\n             mut genesis_block, ..\n         } = create_genesis_block(2);\n         genesis_block.ticks_per_slot = 4;\n+        let num_extra_ticks = 2;\n         let bank = Arc::new(Bank::new(&genesis_block));\n         let start_hash = bank.last_blockhash();\n         let (verified_sender, verified_receiver) = unbounded();\n@@ -1020,8 +1022,10 @@ mod tests {\n             let blocktree = Arc::new(\n                 Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n             );\n+            let mut poh_config = PohConfig::default();\n+            poh_config.target_tick_count = Some(bank.max_tick_height() + num_extra_ticks);\n             let (exit, poh_recorder, poh_service, entry_receiver) =\n-                create_test_recorder(&bank, &blocktree);\n+                create_test_recorder(&bank, &blocktree, Some(poh_config));\n             let cluster_info = ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n             let cluster_info = Arc::new(RwLock::new(cluster_info));\n             let banking_stage = BankingStage::new(\n@@ -1031,7 +1035,6 @@ mod tests {\n                 vote_receiver,\n             );\n             trace!(\"sending bank\");\n-            sleep(Duration::from_millis(600));\n             drop(verified_sender);\n             drop(vote_sender);\n             exit.store(true, Ordering::Relaxed);\n@@ -1069,8 +1072,11 @@ mod tests {\n             let blocktree = Arc::new(\n                 Blocktree::open(&ledger_path).expect(\"Expected to be able to open database ledger\"),\n             );\n+            let mut poh_config = PohConfig::default();\n+            // limit tick count to avoid clearing working_bank at PohRecord then PohRecorderError(MaxHeightReached) at BankingStage\n+            poh_config.target_tick_count = Some(bank.max_tick_height() - 1);\n             let (exit, poh_recorder, poh_service, entry_receiver) =\n-                create_test_recorder(&bank, &blocktree);\n+                create_test_recorder(&bank, &blocktree, Some(poh_config));\n             let cluster_info = ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n             let cluster_info = Arc::new(RwLock::new(cluster_info));\n             let banking_stage = BankingStage::new(\n@@ -1120,6 +1126,9 @@ mod tests {\n \n             drop(verified_sender);\n             drop(vote_sender);\n+            // wait until banking_stage to finish up all packets\n+            banking_stage.join().unwrap();\n+\n             exit.store(true, Ordering::Relaxed);\n             poh_service.join().unwrap();\n             drop(poh_recorder);\n@@ -1128,18 +1137,20 @@ mod tests {\n             let bank = Bank::new(&genesis_block);\n             bank.process_transaction(&fund_tx).unwrap();\n             //receive entries + ticks\n-            for _ in 0..10 {\n+            loop {\n                 let entries: Vec<Entry> = entry_receiver\n                     .iter()\n                     .map(|(_bank, (entry, _tick_height))| entry)\n                     .collect();\n \n                 assert!(entries.verify(&blockhash));\n-                blockhash = entries.last().unwrap().hash;\n-                for entry in entries {\n-                    bank.process_transactions(&entry.transactions)\n-                        .iter()\n-                        .for_each(|x| assert_eq!(*x, Ok(())));\n+                if !entries.is_empty() {\n+                    blockhash = entries.last().unwrap().hash;\n+                    for entry in entries {\n+                        bank.process_transactions(&entry.transactions)\n+                            .iter()\n+                            .for_each(|x| assert_eq!(*x, Ok(())));\n+                    }\n                 }\n \n                 if bank.get_balance(&to) == 1 {\n@@ -1153,13 +1164,11 @@ mod tests {\n             assert_eq!(bank.get_balance(&to2), 0);\n \n             drop(entry_receiver);\n-            banking_stage.join().unwrap();\n         }\n         Blocktree::destroy(&ledger_path).unwrap();\n     }\n \n     #[test]\n-    #[ignore]\n     fn test_banking_stage_entryfication() {\n         solana_logger::setup();\n         // In this attack we'll demonstrate that a verifier can interpret the ledger\n@@ -1212,8 +1221,11 @@ mod tests {\n                     Blocktree::open(&ledger_path)\n                         .expect(\"Expected to be able to open database ledger\"),\n                 );\n+                let mut poh_config = PohConfig::default();\n+                // limit tick count to avoid clearing working_bank at PohRecord then PohRecorderError(MaxHeightReached) at BankingStage\n+                poh_config.target_tick_count = Some(bank.max_tick_height() - 1);\n                 let (exit, poh_recorder, poh_service, entry_receiver) =\n-                    create_test_recorder(&bank, &blocktree);\n+                    create_test_recorder(&bank, &blocktree, Some(poh_config));\n                 let cluster_info =\n                     ClusterInfo::new_with_invalid_keypair(Node::new_localhost().info);\n                 let cluster_info = Arc::new(RwLock::new(cluster_info));"
    },
    {
      "filename": "core/src/poh_service.rs",
      "status": "modified",
      "patch": "@@ -32,7 +32,15 @@ impl PohService {\n             .name(\"solana-poh-service-tick_producer\".to_string())\n             .spawn(move || {\n                 if poh_config.hashes_per_tick.is_none() {\n-                    Self::sleepy_tick_producer(poh_recorder, &poh_config, &poh_exit_);\n+                    if poh_config.target_tick_count.is_none() {\n+                        Self::sleepy_tick_producer(poh_recorder, &poh_config, &poh_exit_);\n+                    } else {\n+                        Self::short_lived_sleepy_tick_producer(\n+                            poh_recorder,\n+                            &poh_config,\n+                            &poh_exit_,\n+                        );\n+                    }\n                 } else {\n                     // PoH service runs in a tight loop, generating hashes as fast as possible.\n                     // Let's dedicate one of the CPU cores to this thread so that it can gain\n@@ -60,6 +68,22 @@ impl PohService {\n         }\n     }\n \n+    fn short_lived_sleepy_tick_producer(\n+        poh_recorder: Arc<Mutex<PohRecorder>>,\n+        poh_config: &PohConfig,\n+        poh_exit: &AtomicBool,\n+    ) {\n+        let mut warned = false;\n+        for _ in 0..poh_config.target_tick_count.unwrap() {\n+            sleep(poh_config.target_tick_duration);\n+            poh_recorder.lock().unwrap().tick();\n+            if poh_exit.load(Ordering::Relaxed) && !warned {\n+                warned = true;\n+                warn!(\"exit signal is ignored because PohService is scheduled to exit soon\");\n+            }\n+        }\n+    }\n+\n     fn tick_producer(poh_recorder: Arc<Mutex<PohRecorder>>, poh_exit: &AtomicBool) {\n         let poh = poh_recorder.lock().unwrap().poh.clone();\n         loop {\n@@ -108,6 +132,7 @@ mod tests {\n             let poh_config = Arc::new(PohConfig {\n                 hashes_per_tick: Some(2),\n                 target_tick_duration: Duration::from_millis(42),\n+                target_tick_count: None,\n             });\n             let (poh_recorder, entry_receiver) = PohRecorder::new(\n                 bank.tick_height(),"
    },
    {
      "filename": "core/src/tvu.rs",
      "status": "modified",
      "patch": "@@ -257,7 +257,7 @@ pub mod tests {\n         let blocktree = Arc::new(blocktree);\n         let bank = bank_forks.working_bank();\n         let (exit, poh_recorder, poh_service, _entry_receiver) =\n-            create_test_recorder(&bank, &blocktree);\n+            create_test_recorder(&bank, &blocktree, None);\n         let voting_keypair = Keypair::new();\n         let storage_keypair = Arc::new(Keypair::new());\n         let leader_schedule_cache = Arc::new(LeaderScheduleCache::new_from_bank(&bank));"
    },
    {
      "filename": "runtime/src/bank.rs",
      "status": "modified",
      "patch": "@@ -1675,6 +1675,7 @@ mod tests {\n                         / DEFAULT_TICKS_PER_SLOT,\n                 ),\n                 hashes_per_tick: None,\n+                target_tick_count: None,\n             },\n \n             ..GenesisBlock::default()"
    },
    {
      "filename": "sdk/src/poh_config.rs",
      "status": "modified",
      "patch": "@@ -6,6 +6,9 @@ pub struct PohConfig {\n     /// The target tick rate of the cluster.\n     pub target_tick_duration: Duration,\n \n+    /// The target total tick count to be produced; used for testing only\n+    pub target_tick_count: Option<u64>,\n+\n     /// How many hashes to roll before emitting the next tick entry.\n     /// None enables \"Low power mode\", which implies:\n     /// * sleep for `target_tick_duration` instead of hashing\n@@ -18,6 +21,7 @@ impl PohConfig {\n         Self {\n             target_tick_duration,\n             hashes_per_tick: None,\n+            target_tick_count: None,\n         }\n     }\n }"
    }
  ],
  "fix_category": "Wait/Join",
  "root_cause_category": "Async wait",
  "root_cause_subcategory": "Wait/Join"
}